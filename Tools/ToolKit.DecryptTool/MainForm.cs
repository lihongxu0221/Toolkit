using MethodInvoker = System.Reflection.MethodInvoker;namespace ToolKit.DecryptTool;/// <summary>/// MainForm serves as the primary form for the DecryptTool application./// It is responsible for initializing the user interface and handling the form's load event./// </summary>public partial class MainForm : Form{    private static readonly ILogger logger = LogManager.GetCurrentClassLogger();    /// <summary>    /// MainForm serves as the primary form for the DecryptTool application.    /// It is responsible for initializing the user interface and handling the form's load event.    /// </summary>    public MainForm()    {        this.InitializeComponent();        this.Load += MainForm_Load;    }    private void MainForm_Load(object? sender, EventArgs e)    {        // --- NEW METHOD: MainForm_Load ---        // 在窗体加载时，用代码配置 RichTextBox 日志目标        logger.Info("应用程序启动。");        LogManager.ReconfigExistingLoggers();        // 1. 获取当前的 NLog 配置        var config = LogManager.Configuration ?? new NLog.Config.LoggingConfiguration();        // 2. 创建一个 RichTextBox 目标        var rtbTarget = new RichTextBoxTarget()        {            Name = "rtbLogTarget", // 给它一个名字            Layout = "${longdate}|${level:uppercase=true}| ${message}",            ControlName = this.rtbLog.Name, // *** 核心：直接传递控件实例 ***            FormName = this.Name,            AutoScroll = true,        };        // 3. 将新目标添加到配置中        config.AddTarget(rtbTarget);        // 4. 创建一个规则，将所有日志都发送到这个新目标        //    这将附加到 nlog.config 已有的规则上        config.AddRuleForAllLevels(rtbTarget);        // 5. 重新加载并应用修改后的配置        LogManager.Configuration = config;        logger.Info("应用程序启动完毕，UI日志已就绪。");    }    /// <summary>    /// Handles the Click event of the btnSelectDll button. This method opens a file dialog to allow the user to select a DLL file.    /// The selected file path is then displayed in the txtDllPath text box and logged for informational purposes.    /// </summary>    /// <param name="sender">The source of the event.</param>    /// <param name="e">An EventArgs that contains the event data.</param>    private void btnSelectDll_Click(object sender, EventArgs e)    {        using var dialog = new OpenFileDialog        {            Title = "请选择一个资源 DLL 文件",            Filter = "DLL 文件 (*.dll)|*.dll|所有文件 (*.*)|*.*",            CheckFileExists = true,            CheckPathExists = true        };        if (dialog.ShowDialog(this) == DialogResult.OK)        {            tt.Text = dialog.FileName;            logger.Info($"已选择待还原的 DLL 文件: {dialog.FileName}");        }    }    // "还原文件" 按钮的点击事件    private void btnRestore_Click(object sender, EventArgs e)    {        if (string.IsNullOrWhiteSpace(tt.Text))        {            MessageBox.Show("请先选择一个 DLL 文件！", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);            return;        }        // 弹出对话框，让用户选择还原文件的目标文件夹        folderBrowserDialog1.Description = "请选择一个文件夹来存放还原的文件";        if (folderBrowserDialog1.ShowDialog(this) != DialogResult.OK)        {            return;        }        var dllPath = tt.Text;        var restorePath = folderBrowserDialog1.SelectedPath;        btnRestore.Enabled = false;        logger.Info("================== 开始还原文件 ==================");        try        {            var extractor = new ResourceExtractor(logger);            bool success = extractor.ExtractResources(dllPath, restorePath);            if (success)            {                MessageBox.Show($"文件已成功还原到:\n\n{restorePath}", "还原成功", MessageBoxButtons.OK,                    MessageBoxIcon.Information);            }            else            {                MessageBox.Show("还原过程中发生错误，请查看日志获取详细信息。", "还原失败", MessageBoxButtons.OK, MessageBoxIcon.Error);            }        }        catch (Exception ex)        {            logger.Error(ex, "还原文件时发生未处理的异常。");            MessageBox.Show($"发生严重错误: {ex.Message}", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error);        }        finally        {            btnRestore.Enabled = true;            logger.Info("================== 还原过程结束 ==================");        }    }    private void btnSelectFolder_Click(object sender, EventArgs e)    {        using var dialog = new FolderBrowserDialog        {            Description = "请选择包含资源的文件夹",            UseDescriptionForTitle = true,            ShowNewFolderButton = false        };        if (dialog.ShowDialog(this) == DialogResult.OK)        {            var folderPath = dialog.SelectedPath;            txtSourceFolder.Text = folderPath;            txtProjectName.Text = new DirectoryInfo(folderPath).Name;            logger.Info($"已选择源文件夹: {folderPath}");            PopulateTreeView(folderPath);        }    }    private void PopulateTreeView(string rootPath)    {        tvFiles.Nodes.Clear();        var rootDirectoryInfo = new DirectoryInfo(rootPath);        var rootNode = CreateDirectoryNode(rootDirectoryInfo, true);        tvFiles.Nodes.Add(rootNode);        PopulateNodes(rootNode, rootDirectoryInfo);        rootNode.Expand();        logger.Info("文件结构树已刷新。");    }    private void PopulateNodes(TreeNode parentNode, DirectoryInfo directoryInfo)    {        var filters = txtFilter.Text.Split(';', StringSplitOptions.RemoveEmptyEntries);        if (filters.Length == 0) filters = ["*"];        bool isCheck = true;        string directoryName = directoryInfo.Name.ToLower();        if ("bin" == directoryName ||            "debug" == directoryName ||            "obj" == directoryName ||            ".git" == directoryName ||            ".vs" == directoryName ||            !parentNode.Checked)        {            isCheck = false;        }        foreach (var directory in directoryInfo.GetDirectories())        {            var directoryNode = CreateDirectoryNode(directory, isCheck);            parentNode.Nodes.Add(directoryNode);            PopulateNodes(directoryNode, directory);        }        foreach (var filter in filters)        {            foreach (var file in directoryInfo.GetFiles(filter.Trim()))            {                var fileNode = new TreeNode(file.Name) { Tag = file.FullName, Checked = isCheck };                parentNode.Nodes.Add(fileNode);            }        }        if (!isCheck)        {            parentNode.Checked = false;        }        else        {            foreach (TreeNode node in parentNode.Nodes)            {                if (!node.Checked)                {                    parentNode.Checked = false;                }            }        }    }    private TreeNode CreateDirectoryNode(DirectoryInfo directory, bool isCheck)    {        return new TreeNode(directory.Name) { Tag = directory.FullName, Checked = isCheck };    }    private void tvFiles_AfterCheck(object sender, TreeViewEventArgs e)    {        if (e.Action != TreeViewAction.Unknown)        {            CheckAllChildNodes(e.Node, e.Node.Checked);            CheckParentNode(e.Node);        }    }    private void CheckAllChildNodes(TreeNode node, bool isChecked)    {        foreach (TreeNode child in node.Nodes)        {            child.Checked = isChecked;            if (child.Nodes.Count > 0) CheckAllChildNodes(child, isChecked);        }    }    private void CheckParentNode(TreeNode node)    {        var parent = node.Parent;        if (parent != null)        {            parent.Checked = parent.Nodes.Cast<TreeNode>().All(child => child.Checked);            CheckParentNode(parent);        }    }    private async void btnGenerate_Click(object sender, EventArgs e)    {        if (string.IsNullOrWhiteSpace(txtSourceFolder.Text) || string.IsNullOrWhiteSpace(txtProjectName.Text))        {            MessageBox.Show("请先选择源文件夹！", "警告", MessageBoxButtons.OK, MessageBoxIcon.Warning);            logger.Warn("尝试在未选择源文件夹的情况下生成 DLL。");            return;        }        btnGenerate.Enabled = false;        logger.Info("================== 开始生成 DLL ==================");        try        {            // --- START OF CHANGES ---            // 1. 计算解决方案根目录。            //    Application.StartupPath 通常是 /bin/Debug/net8.0-windows            //    我们需要向上返回四级才能到达解决方案根目录。            string solutionRoot = Path.Combine(Application.StartupPath);            // 2. 定义并创建最终的输出基目录            string projectsBasePath = Path.Combine(solutionRoot, "Projects");            Directory.CreateDirectory(projectsBasePath); // 如果文件夹不存在，则创建它            logger.Info($"所有生成的项目将被放置在: {projectsBasePath}");            var projectName = txtProjectName.Text;            var sourceBasePath = txtSourceFolder.Text;            var selectedFiles = GetSelectedFiles();            if (!selectedFiles.Any())            {                MessageBox.Show("没有选择任何文件作为资源！", "警告", MessageBoxButtons.OK, MessageBoxIcon.Warning);                logger.Warn("没有勾选任何文件，已中止生成。");                return;            }            logger.Info($"共选择了 {selectedFiles.Count} 个文件作为资源。");            var generator = new DllBuilder(logger);            // 3. 将新的基路径传递给生成器            var success = await generator.GenerateAsync(projectsBasePath, projectName, sourceBasePath, selectedFiles);            if (success)            {                // 4. 更新成功消息中的DLL路径                var outputPath = Path.Combine(projectsBasePath, projectName, "bin", "Release", "net8.0",                    $"{projectName}.dll");                logger.Info($"✔✔✔ DLL 生成成功! 输出路径: {outputPath}");                MessageBox.Show($"DLL 生成成功!\n\n路径: {outputPath}", "成功", MessageBoxButtons.OK,                    MessageBoxIcon.Information);            }            else            {                logger.Error("❌❌❌ DLL 生成失败。请查看日志获取详细信息。");                MessageBox.Show("DLL 生成失败！\n\n请查看日志获取详细信息。", "失败", MessageBoxButtons.OK, MessageBoxIcon.Error);            }            // --- END OF CHANGES ---        }        catch (Exception ex)        {            logger.Error(ex, "生成过程中发生未处理的异常。");            MessageBox.Show($"发生严重错误: {ex.Message}", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error);        }        finally        {            btnGenerate.Enabled = true;            logger.Info("================== 生成过程结束 ==================");        }    }    private List<string> GetSelectedFiles()    {        var selectedFiles = new List<string>();        foreach (TreeNode node in tvFiles.Nodes) GetCheckedFilesRecursive(node, selectedFiles);        return selectedFiles;    }    private void GetCheckedFilesRecursive(TreeNode node, List<string> selectedFiles)    {        if (node.Checked && node.Tag is string path && File.Exists(path))        {            selectedFiles.Add(path);        }        foreach (TreeNode childNode in node.Nodes) GetCheckedFilesRecursive(childNode, selectedFiles);    }    private void txtFilter_TextChanged(object sender, EventArgs e)    {        if (!string.IsNullOrEmpty(txtSourceFolder.Text) && Directory.Exists(txtSourceFolder.Text))        {            PopulateTreeView(txtSourceFolder.Text);        }    }    private void btnLoad_Click(object sender, EventArgs e)    {        FolderBrowserDialog dialog = new FolderBrowserDialog        {            UseDescriptionForTitle = true,            Description = "选择工作目录",        };        if (dialog.ShowDialog() == DialogResult.OK)        {            if (sender == this.btnLoadBak)            {                this.txtBak.Text = dialog.SelectedPath;                this.txtBak.Text = FormatHelper.GetBackupDirectoryPath(dialog.SelectedPath);                this.txtFormater.Text = dialog.SelectedPath;                this.btnLoadBak.Enabled = true;                this.btnFormater.Enabled = true;                return;            }            if (sender == this.btnLoadFormater)            {                this.txtFormater.Text = FormatHelper.GetBackupDirectoryPath(dialog.SelectedPath);                this.btnFormater.Enabled = true;                return;            }        }    }    private void btnBak_Click(object sender, EventArgs e)    {        string dirPath = this.txtSourceFolder.Text;        string dirPathBak = this.txtBak.Text;        if (!string.IsNullOrEmpty(dirPathBak))        {            logger.Info("开始文件备份");            FormatHelper.Bak(dirPath, dirPathBak, out int bakCount, out List<string> newFiles, logger);            logger.Info($"备份完成! 备份文件数量{bakCount},待格式化文件数量{newFiles.Count}");            if (newFiles.Count > 0)            {                logger.Info("如下所示：", Color.LightGreen);                for (int i = 0; i < newFiles.Count; i++)                {                    logger.Info(Path.GetFileName(newFiles[i]) ?? "", Color.LightGreen);                }            }        }    }    private async void btnFormater_Click(object sender, EventArgs e)    {        string dirPath = this.txtFormater.Text;        string dirPathBak = this.txtBak.Text;        if (!string.IsNullOrEmpty(dirPath))        {            logger.Info("开始格式化");            (int, int, int) ret = await Task.Run(() => FormatHelper.Format(dirPath, dirPathBak, logger, ShowProgress))                .ConfigureAwait(continueOnCapturedContext: true);            logger.Info($"格式化完成:文件总数量{ret.Item1}，修改文件数量{ret.Item2},新建文件数量{ret.Item3}");        }    }    private void ShowProgress(int current, int total)    {        if (this.InvokeRequired)        {            this.Invoke(() =>            {                this.ShowProgress(current, total);            });        }        else        {            // progressBar1.Value = current;            // progressBar1.Maximum = total;        }    }}