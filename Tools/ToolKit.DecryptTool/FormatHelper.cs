namespace ToolKit.DecryptTool;/// <summary>/// Provides helper methods for formatting and backing up files./// </summary>public class FormatHelper{    private static readonly string Extension = ".jj";    private static readonly string BackupDirectory = "Bak";    private static readonly string[] BinaryExtensions = new string[]    {        "*.ttf",        "*.png",        "*.ico",        "*.jpg",        "*.bmp",        "*.dll",        "*.exe",        "*.pdb",    };    private static readonly string[] TextExtensions = new string[]    {        "*.css",        "*.html",        "*.js",        "*.json",        "*.resx",        "*.cs",        "*.xaml",        "*.xaml.cs",        "*.csproj",        "*.config",        "*.props",        "*.targets",        ".editorconfig",        ".gitattributes",        ".gitignore",        "*.sln"    };    private static readonly string[] IgnoredDirectories = new string[]    {        "\\.git\\",        "\\build\\",        "\\doc\\",        "\\_bak\\",        "\\bak\\",        "\\.vs\\",        "\\bin\\",        "\\debug\\",        "\\obj\\",        "\\packages\\"    };    static string? ReadFileContent(string filePath)    {        if (string.IsNullOrEmpty(filePath) || !File.Exists(filePath))        {            return null;        }        return File.ReadAllText(filePath, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));    }    private static bool IsBinaryFile(string filePath)    {        return BinaryExtensions.Any(ext => ext.EndsWith(Path.GetExtension(filePath)));    }    private static (object?, object?) LoadFiles(string file, string backupFile, bool isBinary)    {        object? fileContent = null;        object? backupFileContent = null;        if (isBinary)        {            if (File.Exists(file))            {                fileContent = File.ReadAllBytes(file);            }            if (File.Exists(backupFile))            {                backupFileContent = File.ReadAllBytes(backupFile);            }        }        else        {            fileContent = ReadFileContent(file);            backupFileContent = ReadFileContent(backupFile);        }        return (fileContent, backupFileContent);    }    private static bool AreContentsEqual(object? content1, object? content2)    {        if (content1 is byte[] bytes1 && content2 is byte[] bytes2)        {            return bytes1.SequenceEqual(bytes2);        }        return content1?.Equals(content2) ?? false;    }    /// <summary>    /// 检查两个文件是否内容一致，并判断是否为二进制文件    /// </summary>    /// <param name="file">主文件路径</param>    /// <param name="backupFile">备份文件路径</param>    /// <returns>元组 (是否内容一致, 是否为二进制文件, 主文件是否存在, 备份文件是否存在, 主文件内容, 备份文件内容)</returns>    static (bool, bool, bool, bool, object?, object?) CheckFilesEquality(string file, string backupFile)    {        bool fileExists = File.Exists(file);        bool backupFileExists = File.Exists(backupFile);        bool isBinary = IsBinaryFile(file);        (object? fileContent, object? backupFileContent) = LoadFiles(file, backupFile, isBinary);        if (fileExists && backupFileExists)        {            return (AreContentsEqual(fileContent, backupFileContent),                isBinary,                fileExists,                backupFileExists,                fileContent,                backupFileContent);        }        return (false, isBinary, fileExists, backupFileExists, fileContent, backupFileContent);    }    public static string GetBackupDirectoryPath(string dir)    {        if (dir.EndsWith($"\\{BackupDirectory}\\") || dir.EndsWith($"\\{BackupDirectory}"))        {            return dir;        }        return Path.Combine(dir, BackupDirectory);    }    private static List<string> GetFilteredFiles(string dirPath)    {        return Directory.GetFiles(dirPath, "*.*", SearchOption.AllDirectories)            .Where(p =>                TextExtensions.Any(ext => ext.Equals(Path.GetExtension(p), StringComparison.OrdinalIgnoreCase)) ||                BinaryExtensions.Any(ext => ext.Equals(Path.GetExtension(p), StringComparison.OrdinalIgnoreCase)))            .Where(p => !IgnoredDirectories.Any(s => p.ToLowerInvariant().Contains(s)))            .ToList();    }    private static void EnsureDirectoryExists(string dirBak)    {        if (!Directory.Exists(dirBak))        {            Directory.CreateDirectory(dirBak);        }    }    public static void Bak(string dirPath, string dirBakRoot, out int bakCount, out List<string> newList, ILogger logger)    {        bakCount = 0;        newList = new List<string>();        string newDirPath = dirBakRoot;        if (!newDirPath.EndsWith($"\\{BackupDirectory}"))        {            newDirPath = Path.Combine(dirBakRoot, BackupDirectory);        }        List<string> files = Directory.GetFiles(dirPath, "*.*", SearchOption.AllDirectories)            .Where(p => TextExtensions.Any(ext => ext.EndsWith(Path.GetExtension(p))) ||                        BinaryExtensions.Any(ext => ext.EndsWith(Path.GetExtension(p))))            .Where(p => !IgnoredDirectories.Any(s => p.ToLowerInvariant().Contains(s)))            .ToList();        string fileBak = string.Empty;        string? dirBak = string.Empty;        for (int i = 0; i < files.Count; i++)        {            string file = files[i];            string extends = Path.GetExtension(file);            dirBak = Path.GetDirectoryName(file)?.Replace(dirPath, newDirPath);            if (dirBak != null && !string.IsNullOrEmpty(dirBak))            {                fileBak = Path.Combine(dirBak, $"{Path.GetFileName(file)}{Extension}1");                if (!Directory.Exists(dirBak))                {                    if (!string.IsNullOrEmpty(dirBak))                    {                        _ = Directory.CreateDirectory(dirBak);                    }                }                else                {                    string[] files2 = Directory.GetFiles(dirBak, $"{Path.GetFileName(file)}{Extension}*", SearchOption.AllDirectories);                    if (files2.Length != 0)                    {                        fileBak = files2[0];                    }                }                var ret = CheckFilesEquality(file, fileBak);                if (!ret.Item1) // 内容不相同                {                    if (ret.Item2) // 内容为二进制                    {                        byte[]? content = ret.Item5 as byte[];                        byte[]? contentBak = ret.Item6 as byte[];                        if (ret.Item4)                        {                            File.Delete(fileBak);                        }                        bakCount++;                        if (content != null)                        {                            File.WriteAllBytes(fileBak, content);                        }                    }                    else                    {                        string? content = ret.Item5 as string;                        string? contentBak = ret.Item6 as string;                        if (!string.IsNullOrEmpty(content) && content.StartsWith("%TSD-Header-"))                        {                            // 原始加密的文件仅新建                            if (!ret.Item4)                            {                                newList.Add(file);                                logger.Info("新建文件 " + fileBak);                                File.Create(fileBak);                            }                        }                        else                        {                            bakCount++;                            logger.Info("备份文件 " + fileBak);                            File.WriteAllText(fileBak, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));                        }                    }                }            }        }    }    public static (int, int, int) Format(        string dirPath,        string dirBak,        ILogger logger,        Action<int, int>? showProgress = null)    {        int formaterCount = 0;        int newCount = 0;        string[] files = Directory.GetFiles(dirBak, "*.jj*", SearchOption.AllDirectories);        if (files.Length != 0)        {            string fileBak = string.Empty;            string fileName = string.Empty;            string? dir = string.Empty;            string file = string.Empty;            string contentBak = string.Empty;            string ext = string.Empty;            for (int i = 0; i < files.Length; i++)            {                Debug.WriteLine($"[{i + 1}]{files[i]}");                fileBak = files[i];                fileName = Path.GetFileNameWithoutExtension(fileBak);                dir = Path.GetDirectoryName(fileBak)?.Replace(dirBak, dirPath);                if (!string.IsNullOrEmpty(dir))                {                    if (!Directory.Exists(dir))                    {                        Directory.CreateDirectory(dir);                    }                    file = Path.Combine(dir, fileName);                    ext = Path.GetExtension(file);                    var ret = CheckFilesEquality(file, fileBak);                    if (!ret.Item1) // 是否一致                    {                        if (ret.Item2) // 是否为二进制                        {                            byte[]? content = (byte[]?)ret.Item6;                            if (content != null)                            {                                if (ret.Item3) // 要进行格式化的文件是否存在                                {                                    File.Delete(file);                                    formaterCount++;                                    logger.Info("找到" + file + ",重写完成");                                    File.WriteAllBytes(file, content);                                }                                else                                {                                    newCount++;                                    logger.Info("新建" + file + ",重写完成");                                    File.WriteAllBytes(file, content);                                }                            }                        }                        else                        {                            contentBak = ret.Item6?.ToString() ?? string.Empty;                            if (ret.Item3) // 要进行格式化的文件是否存在                            {                                string content = ret.Item5?.ToString() ?? string.Empty;                                bool needReWrite = true;                                if (!content.StartsWith("%TSD-Header-") && content.Equals(contentBak))                                {                                    needReWrite = false;                                }                                if (needReWrite && string.IsNullOrEmpty(contentBak) && !string.IsNullOrEmpty(content))                                {                                    needReWrite = false;                                }                                if (needReWrite)                                {                                    formaterCount++;                                    File.WriteAllText(file, contentBak, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));                                    logger.Info("找到" + file + ",重写完成");                                }                            }                            else                            {                                newCount++;                                File.WriteAllText(file, contentBak, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));                                logger.Info("新建" + file + ",重写完成");                            }                        }                    }                }                showProgress?.Invoke(i + 1, files.Length);            }        }        return (files.Length, formaterCount, newCount);    }}