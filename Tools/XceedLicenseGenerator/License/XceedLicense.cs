using System.Diagnostics;namespace XceedLicenseGenerator;internal abstract class XceedLicense{    private string m_licenseKey;    private bool m_trial;    private LicenseProduct m_product;    private byte m_versionMajor;    private byte m_versionMinor;    private byte m_nbLicenses;    private bool m_siteLicense;    private int m_daysLeft;    private bool m_isFromRegistry;    private List<LicenseInformationType> m_performedFeratureAnalysis = new List<LicenseInformationType>();    internal const string LicensesRegistryLocation = "Licenses\\4507C5F2-9077-40DE-A621-64EC59BF6829\\";    internal const string UserLicensesRegistryLocation = "Software\\Xceed Software\\Licenses\\";    public XceedLicense()    {    }    public void Analyse(ref string licenseKey)    {        this.Analyse(ref licenseKey, true);    }    public void Analyse(ref string licenseKey, bool allowThrow)    {        XceedLicenseManager xceedLicenseManager = new XceedLicenseManager();        this.ValidateLicenseKey(ref xceedLicenseManager, ref licenseKey, true, allowThrow);        this.m_licenseKey = licenseKey;        this.m_nbLicenses = xceedLicenseManager.NbLicenses;        this.m_siteLicense = xceedLicenseManager.IsSiteLicense;        this.m_trial = xceedLicenseManager.Originator >= LicenseOrigin.TrialVersion && xceedLicenseManager.Originator <= LicenseOrigin.TrialRenew9;        if (this.m_trial)        {            this.m_daysLeft = new TimeSpan(xceedLicenseManager.Date.Ticks - DateTime.Today.Ticks).Days;        }        this.m_product = xceedLicenseManager.Product;        this.m_versionMajor = xceedLicenseManager.VerMajor;        this.m_versionMinor = xceedLicenseManager.VerMinor;    }    public void Initialize(string licenseKey, Type licenserType)    {        this.Initialize(licenseKey, licenserType, true);    }    public void Initialize(string licenseKey, Type licenserType, bool allowThrow)    {        if (string.IsNullOrEmpty(licenseKey))        {            licenseKey = this.GetLicenseKeyFromRegistry();            if (string.IsNullOrEmpty(licenseKey))            {                if (!allowThrow)                {                    return;                }                this.ThrowNoKeyInCodeAndRegistry();            }        }        this.Analyse(ref licenseKey, allowThrow);        if (!string.IsNullOrEmpty(this.m_licenseKey) && !this.m_trial && this.m_isFromRegistry)        {            this.ThrowNoKeyInCodeAndRegistry();        }    }    public bool IsFromRegistry    {        get { return this.m_isFromRegistry; }        set { this.m_isFromRegistry = value; }    }    public int DaysLeft    {        get { return this.m_daysLeft; }    }    public string LicenseKey    {        get { return this.m_licenseKey; }    }    public bool IsTrial    {        get { return this.m_trial; }    }    public LicenseProduct Product    {        get { return this.m_product; }    }    public byte VersionMajor    {        get { return this.m_versionMajor; }    }    public byte VersionMinor    {        get { return this.m_versionMinor; }    }    public byte NbLicenses    {        get { return this.m_nbLicenses; }    }    public bool IsSiteLicense    {        get { return this.m_siteLicense; }    }    protected virtual void ThrowNoKeyInCodeAndRegistry()    {        ThrowException.ThrowLicenseException(this.LicenseeType, null, this.LicenseeType.FullName + ".LicenseKey must be set to a valid trial or registered license key in the code of your application before using this product. Please refer to the Licensing topic in the documentation for specific instructions on how to avoid this exception.");    }    protected virtual void ThrowKeyInvalid()    {        ThrowException.ThrowLicenseException(this.LicenseeType, null, "The license key used to license this Xceed product is invalid. " + this.LicenseeType.FullName + ".LicenseKey must be set to a valid trial or registered license key before using this product. Please refer to the Licensing topic in the documentation for specific instructions on how to avoid this exception.");    }    protected virtual void ThrowKeyInvalidProduct()    {        ThrowException.ThrowLicenseException(this.LicenseeType, null, "The license key used to license this Xceed product does not match the current product. Please make sure that you are correctly licensing the product as described in the documentation and then recompile in order to avoid this exception.");    }    protected virtual void ThrowKeyInvalidProductVersion()    {        ThrowException.ThrowLicenseException(this.LicenseeType, null, "The license key used to license this Xceed product is not in a valid version range. To unlock this assembly, please make sure that you are using a valid or up-to-date license key.");    }    protected virtual void ThrowTrialKeyExpired()    {        ThrowException.ThrowLicenseException(this.LicenseeType, null, "The trial license key used to license this Xceed product has expired. Please contact Xceed if you need additional time to evaluate the library, or if you wish to purchase a registered license.");    }    protected virtual void OnRegisteredKeyExpired(XceedLicenseManager licenseManager)    {        string text = licenseManager.ProductFullName;        if (string.IsNullOrEmpty(text))        {            text = "Xceed " + licenseManager.ProductCodeName;        }        Trace.WriteLine(            string.Format(                "***************************************************************************************************************************************\r\nWarning: \"{0}{1}{2}-\" license key is expired.\r\nThe component \"{3}\" used in this application is governed by the rules defined in the Xceed License Agreement.\r\nAn active subscription is required to use this component. Please contact Xceed Sales mailto:sales@xceed.com to renew your subscription.\r\n***************************************************************************************************************************************",                licenseManager.ProductCodeName,                licenseManager.VerMajor,                licenseManager.VerMinor,                text));    }    protected abstract ProductVersion[] AllowedVersions { get; }    protected virtual ProductVersion GetProductVersion(LicenseProduct product)    {        if (product == LicenseProduct.InvalidProduct)        {            return this.AllowedVersions[0];        }        foreach (ProductVersion productVersion in this.AllowedVersions)        {            if (productVersion.Product == product)            {                return productVersion;            }        }        return this.AllowedVersions[0];    }    protected abstract Type LicenseeType { get; }    private string GetLicenseKeyFromRegistry()    {        return string.Empty;    }    private void ValidateLicenseKey(ref XceedLicenseManager lm, ref string licenseKey, bool performNagIfNecessary)    {        this.ValidateLicenseKey(ref lm, ref licenseKey, performNagIfNecessary, false);    }    private void ValidateLicenseKey(ref XceedLicenseManager lm, ref string licenseKey, bool performNagIfNecessary, bool allowThrow)    {        try        {            lm.AnalyzeLicense(licenseKey, allowThrow);        }        catch (XceedLicenseManagerException)        {            if (!allowThrow)            {                return;            }            this.ThrowKeyInvalid();        }        var allowedVersions = this.AllowedVersions;        if (allowedVersions == null)        {            return;        }        bool flag = false;        bool flag2 = false;        var v = new VersionNumber(lm.VerMajor, lm.VerMinor);        foreach (ProductVersion productVersion in allowedVersions)        {            if (productVersion.Product == lm.Product)            {                flag2 = true;                if (v >= productVersion.MinimumVersion && v <= productVersion.MaximumVersion)                {                    flag = true;                    break;                }            }        }        if (allowThrow && !flag2)        {            this.ThrowKeyInvalidProduct();        }        else if (allowThrow && !flag)        {            this.ThrowKeyInvalidProductVersion();        }        if (new TimeSpan(lm.Date.Ticks - DateTime.Today.Ticks).Days <= 0)        {            if (XceedLicenseManager.IsTrial(lm.Originator))            {                if (allowThrow)                {                    this.ThrowTrialKeyExpired();                    return;                }            }            else            {                this.OnRegisteredKeyExpired(lm);            }        }    }    internal struct VersionNumber    {        public VersionNumber(byte[] version)        {            this.Major = version[0];            this.Minor = version[1];        }        public VersionNumber(byte major, byte minor)        {            this.Major = major;            this.Minor = minor;        }        public VersionNumber(string version)        {            if (string.IsNullOrEmpty(version))            {                throw new ArgumentException("Version cannot be null or empty.");            }            string[] array = version.Split('.', StringSplitOptions.None);            if (array.Length != 2)            {                throw new ArgumentException("Version format is invalid.");            }            this.Major = Convert.ToByte(array[0]);            this.Minor = Convert.ToByte(array[1]);        }        public static bool operator ==(XceedLicense.VersionNumber v1, XceedLicense.VersionNumber v2)        {            return v1.Minor == v2.Minor && v1.Major == v2.Major;        }        public static bool operator !=(XceedLicense.VersionNumber v1, XceedLicense.VersionNumber v2)        {            return v1.Minor != v2.Minor || v1.Major != v2.Major;        }        public static bool operator >(XceedLicense.VersionNumber v1, XceedLicense.VersionNumber v2)        {            return v1.Major > v2.Major || (v1.Major == v2.Major && v1.Minor > v2.Minor);        }        public static bool operator >=(XceedLicense.VersionNumber v1, XceedLicense.VersionNumber v2)        {            return v1 > v2 || v1 == v2;        }        public static bool operator <=(XceedLicense.VersionNumber v1, XceedLicense.VersionNumber v2)        {            return v1 < v2 || v1 == v2;        }        public static bool operator <(XceedLicense.VersionNumber v1, XceedLicense.VersionNumber v2)        {            return v1.Major < v2.Major || (v1.Major == v2.Major && v1.Minor < v2.Minor);        }        public override bool Equals(object obj)        {            return obj is XceedLicense.VersionNumber && this == (XceedLicense.VersionNumber)obj;        }        public override int GetHashCode()        {            return Convert.ToInt32((int)(this.Major * 10 + this.Minor));        }        public override string ToString()        {            return this.Major.ToString() + "." + this.Minor.ToString();        }        private byte Major;        private byte Minor;    }    internal struct ProductVersion    {        public ProductVersion(LicenseProduct product, VersionNumber latestVersion, VersionNumber minimumVersion)        {            this = new ProductVersion(product, latestVersion, minimumVersion, new VersionNumber(9, 9), true);        }        public ProductVersion(LicenseProduct product, VersionNumber latestVersion, VersionNumber minimumVersion, bool searchInRegistry)        {            this = new ProductVersion(product, latestVersion, minimumVersion, new VersionNumber(9, 9), searchInRegistry);        }        public ProductVersion(LicenseProduct product, VersionNumber latestVersion, VersionNumber minimumVersion, VersionNumber maximumVersion, bool searchInRegistry)        {            this.MinimumVersion = minimumVersion;            this.MaximumVersion = maximumVersion;            this.LatestVersion = latestVersion;            this.Product = product;            this.SearchInRegistry = searchInRegistry;        }        public LicenseProduct Product { get; }        public VersionNumber MinimumVersion { get; }        public VersionNumber MaximumVersion { get; }        public VersionNumber LatestVersion { get; }        public bool SearchInRegistry { get; }    }}