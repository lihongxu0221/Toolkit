using System.ComponentModel;using System.Globalization;using System.Text;namespace XceedLicenseGenerator;internal class XceedLicenseManager{    private static readonly string[] ProductIds;    private static byte[] NbDaysBitsA;    private static byte[] UniqueSeedBitsA;    private static byte[] ProductCodeBitsA;    private static byte[] ProductVersionBitsA;    private static byte[] NbLicensesBitsA;    private static byte[] OriginCodeBitsA;    private static byte[] ChecksumBitsA;    private const int RawKeyStringLenA = 19;    private const string LicKeyVersionA = "A";    private const int ReadablePartLengthA = 5;    private const byte SiteLicense = 255;    private const uint BitCountA = 65U;    private const uint VersionMultiplierA = 10U;    private const int BaseDateYear = 2001;    private const int BaseDateMonth = 1;    private const int BaseDateDay = 1;    private const int NbLookupChar = 32;    private const uint AdlerNMax = 5552U;    private const uint AdlerBase = 65521U;    private const string AlphaNumLookup = "ABJCKTDL4UEMW71FNX52YGP98Z63HRS0";    static XceedLicenseManager()    {        string[] array = new string[65];        array[0] = string.Empty;        array[1] = "ZIP";        array[2] = "SFX";        array[3] = "BKP";        array[4] = "WSL";        array[5] = "FTP";        array[6] = "SCO";        array[7] = "BEN";        array[8] = "CRY";        array[9] = "FTB";        array[10] = "ZIN";        array[11] = "ABZ";        array[12] = "GRD";        array[13] = "SCN";        array[14] = "ZIC";        array[15] = "SCC";        array[16] = "SUI";        array[17] = "SUN";        array[18] = "FTN";        array[19] = "FTC";        array[20] = "CHT";        array[21] = "DWN";        array[22] = "CHW";        array[23] = "IVN";        array[24] = "RDY";        array[25] = "EDN";        array[26] = "ZIL";        array[27] = "TAN";        array[28] = "DGF";        array[29] = "DGP";        array[30] = "WAN";        array[31] = "SYN";        array[32] = "ZIX";        array[33] = "ZII";        array[34] = "SFN";        array[35] = "ZRT";        array[36] = "ZRC";        array[37] = "UPS";        array[38] = "TDV";        array[39] = "ZRS";        array[40] = "XPT";        array[41] = "OFT";        array[42] = "GLT";        array[43] = "MET";        array[44] = "LET";        array[45] = "WST";        array[46] = "DGS";        array[47] = "LBS";        array[48] = "FAN";        array[49] = "UPP";        array[50] = "LBW";        array[51] = "BLD";        array[52] = "SFT";        array[53] = "WTK";        array[54] = "ZRX";        array[55] = "ZXA";        array[56] = "FXA";        array[57] = "SXA";        array[58] = "WDN";        array[59] = "PDF";        array[60] = "DGJ";        array[61] = "WBN";        array[62] = "MDN";        array[63] = "TKM";        ProductIds = array;        NbDaysBitsA = new byte[]        {                2,                7,                12,                17,                22,                26,                31,                37,                42,                47,                51,                55,                59,                62,                byte.MaxValue,        };        UniqueSeedBitsA = new byte[]        {                64,                60,                56,                52,                48,                44,                39,                35,                32,                28,                23,                19,                14,                10,                5,                1,                byte.MaxValue,        };        ProductCodeBitsA = new byte[]        {                3,                16,                29,                41,                53,                61,                byte.MaxValue,        };        ProductVersionBitsA = new byte[]        {                4,                15,                25,                34,                43,                50,                58,                byte.MaxValue,        };        NbLicensesBitsA = new byte[]        {                6,                13,                20,                30,                38,                40,                46,                57,                byte.MaxValue,        };        OriginCodeBitsA = new byte[]        {                8,                11,                21,                24,                33,                49,                byte.MaxValue,        };        ChecksumBitsA = new byte[]        {                0,                9,                18,                27,                36,                45,                54,                63,                byte.MaxValue,        };    }    private LicenseProduct m_Product;    private byte m_VerMajor;    private byte m_VerMinor;    private LicenseOrigin m_Originator;    private ushort m_UniqueSeed;    private byte m_NbLicenses;    private DateTime m_Date;    private int m_KeyVersion;    public XceedLicenseManager()    {        this.m_Product = LicenseProduct.InvalidProduct;        this.m_Originator = LicenseOrigin.InvalidOrigin;        this.Reset();    }    public LicenseProduct Product => this.m_Product;    public string ProductCodeName => GetProductCodeName(this.m_Product);    public string ProductName => GetProductName(this.m_Product);    public string ProductFullName => GetProductFullName(this.m_Product);    public byte VerMajor => this.m_VerMajor;    public byte VerMinor => this.m_VerMinor;    public LicenseOrigin Originator => this.m_Originator;    public ushort UniqueSeed => this.m_UniqueSeed;    public byte NbLicenses => this.m_NbLicenses;    public bool IsSiteLicense => this.m_NbLicenses == byte.MaxValue;    public DateTime Date => this.m_Date;    public int KeyVersion => this.m_KeyVersion;    public void AnalyzeLicense(string key)    {        this.AnalyzeLicense(key, true);    }    public void AnalyzeLicense(string key, bool allowThrow)    {        this.Reset();        key = this.CopyKeyNoDashes(key);        if (key.EndsWith("A", StringComparison.Ordinal))        {            int num = this.m_KeyVersion = 0;            if (key.Length != 19)            {                if (allowThrow)                {                    throw new XceedLicenseManagerException(LicenseErrorCode.InvalidKeyLength);                }            }            else            {                if (num == 0)                {                    this.DecodeEncodedPartA(key);                    if (this.m_VerMajor > 9 || this.m_VerMinor > 9)                    {                        if (allowThrow)                        {                            throw new XceedLicenseManagerException(LicenseErrorCode.InvalidVersion);                        }                    }                }                if (this.m_Product < LicenseProduct.XceedZip || this.m_Product > LicenseProduct.XceedToolkitMAUI)                {                    if (allowThrow)                    {                        throw new XceedLicenseManagerException(LicenseErrorCode.InvalidProductCode);                    }                }                else                {                    if (this.m_Originator >= LicenseOrigin.TrialVersion && this.m_Originator <= LicenseOrigin.CRM)                    {                        if (num == 0)                        {                            this.DecodeReadablePartA(key);                        }                        return;                    }                    if (allowThrow)                    {                        throw new XceedLicenseManagerException(LicenseErrorCode.InvalidOriginCode);                    }                }            }        }        else        {            if (allowThrow)            {                throw new XceedLicenseManagerException(LicenseErrorCode.UnsupportedKey);            }        }    }    private string CopyKeyNoDashes(string key)    {        if (!string.IsNullOrEmpty(key))        {            StringBuilder stringBuilder = new StringBuilder(key.Length);            int i = 0;            int length = key.Length;            while (i < length)            {                if (key[i] != '-')                {                    stringBuilder.Append(key[i]);                }                i++;            }            return stringBuilder.ToString();        }        return key;    }    private void DecodeEncodedPartA(string key)    {        uint readablePartAdler = Adler32(0U, key.ToCharArray(), 5U);        this.DecodeEncodedPart(key, readablePartAdler, 65U, 5U, 10U, XceedLicenseManager.NbDaysBitsA, XceedLicenseManager.UniqueSeedBitsA, XceedLicenseManager.ProductCodeBitsA, XceedLicenseManager.ProductVersionBitsA, XceedLicenseManager.NbLicensesBitsA, XceedLicenseManager.OriginCodeBitsA, XceedLicenseManager.ChecksumBitsA);    }    private void DecodeEncodedPart(string key, uint readablePartAdler, uint bitCount, uint readablePartLength, uint versionMultiplier, byte[] nbDaysBits, byte[] uniqueSeedBits, byte[] productCodeBits, byte[] productVersionBits, byte[] nbLicensesBits, byte[] originCodeBits, byte[] checksumBits)    {        uint num = bitCount / 8U;        if (bitCount % 8U != 0U)        {            num += 1U;        }        byte[] bits = new byte[num];        this.DecodeAlphaNumString(key, bits, num, bitCount, readablePartLength);        byte b = (byte)MapBitsToNumber(bits, num, checksumBits);        MapNumberToBits(bits, num, 0U, checksumBits);        if (b != this.CalculateChecksum(readablePartAdler, bits, num))        {            throw new XceedLicenseManagerException(LicenseErrorCode.ChecksumFailed);        }        uint num2 = MapBitsToNumber(bits, num, nbDaysBits);        this.m_Date = new DateTime(2001, 1, 1).AddDays(num2);        num2 = MapBitsToNumber(bits, num, uniqueSeedBits);        this.m_UniqueSeed = (ushort)num2;        num2 = MapBitsToNumber(bits, num, productCodeBits);        this.m_Product = (LicenseProduct)num2;        num2 = MapBitsToNumber(bits, num, productVersionBits);        this.m_VerMajor = (byte)(num2 / versionMultiplier);        this.m_VerMinor = (byte)(num2 % versionMultiplier);        num2 = MapBitsToNumber(bits, num, nbLicensesBits);        this.m_NbLicenses = (byte)num2;        num2 = MapBitsToNumber(bits, num, originCodeBits);        this.m_Originator = (LicenseOrigin)num2;    }    private void DecodeReadablePartA(string key)    {        if (!key.StartsWith(ProductIds[(int)this.m_Product], StringComparison.Ordinal))        {            throw new XceedLicenseManagerException(LicenseErrorCode.ProductMismatch);        }        if (Convert.ToByte(key.Substring(3, 1), CultureInfo.InvariantCulture) != this.m_VerMajor || Convert.ToByte(key.Substring(4, 1), CultureInfo.InvariantCulture) != this.m_VerMinor)        {            throw new XceedLicenseManagerException(LicenseErrorCode.VersionMismatch);        }    }    private void DecodeAlphaNumString(string key, byte[] bits, uint bitsLen, uint bitCount, uint startIndex)    {        ushort num = 11;        uint num2 = 0U;        uint num3 = 0U;        uint num4 = startIndex;        while (num2 < bitsLen && num3 < bitCount)        {            ushort num5 = GetAlphaNumValue(key[(int)num4++]);            num5 = (ushort)(num5 << (int)num);            uint num6 = num2;            bits[(int)num6] = (byte)(bits[(int)num6] | (byte)((num5 & 65280) >> 8));            uint num7 = num2 + 1U;            bits[(int)num7] = (byte)(bits[(int)num7] | (byte)(num5 & 255));            if (num < 8)            {                num += 3;                num2 += 1U;            }            else            {                num -= 5;            }            num3 += 5U;        }    }    private void Reset()    {        this.m_Product = LicenseProduct.InvalidProduct;        this.m_VerMajor = 0;        this.m_VerMinor = 0;        this.m_Originator = LicenseOrigin.InvalidOrigin;        this.m_NbLicenses = 0;        this.m_UniqueSeed = 0;        this.m_Date = DateTime.Now;        this.m_KeyVersion = 0;    }    private byte CalculateChecksum(uint adler, byte[] bits, uint bitsLen)    {        adler = XceedLicenseManager.Adler32(adler, bits, bitsLen);        ushort num = (ushort)((adler & 4294901760U) >> 16 ^ (adler & 65535U));        return (byte)((num & 65280) >> 8 ^ (int)(num & 255));    }    internal static uint Adler32(uint adler, Array buffer, uint bufLen)    {        if (buffer == null)        {            return 1U;        }        uint num = adler & 65535U;        uint num2 = adler >> 16 & 65535U;        int num3 = 0;        while (bufLen > 0U)        {            uint num4 = (bufLen < 5552U) ? bufLen : 5552U;            bufLen -= num4;            while (num4 >= 16U)            {                int i = 0;                while (i < 16)                {                    num += Convert.ToUInt32(buffer.GetValue(num3), CultureInfo.InvariantCulture);                    num2 += num;                    i++;                    num3++;                }                num4 -= 16U;            }            if (num4 != 0U)            {                do                {                    num += Convert.ToUInt32(buffer.GetValue(num3), CultureInfo.InvariantCulture);                    num3++;                    num2 += num;                }                while ((num4 -= 1U) != 0U);            }            num %= 65521U;            num2 %= 65521U;        }        return num2 << 16 | num;    }    public static string GetProductCodeName(LicenseProduct product)    {        return ProductIds[(int)product];    }    public static string GetProductName(LicenseProduct product)    {        string result;        if (product == LicenseProduct.XceedZip)        {            string[] names = Enum.GetNames(typeof(LicenseProduct));            int num = Array.IndexOf<string>(names, "FirstProduct");            if (num >= 0)            {                if (num == 1)                {                    result = names[num + 1];                }                else                {                    result = names[num - 1];                }            }            else            {                result = null;            }        }        else if (product == LicenseProduct.XceedToolkitMAUI)        {            string[] names2 = Enum.GetNames(typeof(LicenseProduct));            int num2 = Array.IndexOf<string>(names2, "LastProduct");            if (num2 >= 0)            {                if (num2 == names2.Length - 1)                {                    result = names2[num2 - 1];                }                else                {                    result = names2[num2 + 1];                }            }            else            {                result = null;            }        }        else        {            result = Enum.GetName(typeof(LicenseProduct), product);        }        return result;    }    public static string GetProductFullName(LicenseProduct product)    {        string productName = GetProductName(product);        object[] customAttributes = typeof(LicenseProduct).GetField(productName).GetCustomAttributes(typeof(DescriptionAttribute), false);        string result;        if (customAttributes != null && customAttributes.Length != 0)        {            result = ((DescriptionAttribute)customAttributes[0]).Description;        }        else        {            result = string.Empty;        }        return result;    }    public static bool IsTrial(LicenseOrigin originator)    {        return originator >= LicenseOrigin.TrialVersion && originator <= LicenseOrigin.TrialRenew9;    }    private static uint MapBitsToNumber(byte[] bits, uint bitsLen, byte[] bitMapping)    {        if (bits == null || bitsLen == 0U)        {            throw new XceedLicenseManagerException();        }        if (bitMapping == null)        {            throw new XceedLicenseManagerException();        }        uint num = 0U;        uint num2 = 0U;        while (bitMapping[(int)num2] != 255)        {            byte b = bitMapping[(int)num2];            byte b2 = (byte)(1 << (int)(7 - (b % 8)));            if ((bits[(int)(b / 8)] & b2) != 0)            {                num |= 1U << (int)num2;            }            num2 += 1U;        }        return num;    }    private static void MapNumberToBits(byte[] bits, uint bitsLen, uint number, byte[] bitMapping)    {        if (bits == null || bitsLen == 0U)        {            throw new XceedLicenseManagerException();        }        if (bitMapping == null)        {            throw new XceedLicenseManagerException();        }        byte b = 0;        int num = 0;        while (bitMapping[num] != 255)        {            if (bitMapping[num] > b)            {                b = bitMapping[num];            }            num++;        }        if (number >= 1U << num)        {            throw new XceedLicenseManagerException();        }        if (bitsLen * 8U <= (uint)b)        {            throw new XceedLicenseManagerException();        }        for (int i = 0; i < num; i++)        {            bool flag = ((ulong)number & (ulong)(1L << (i & 31))) > 0UL;            byte b2 = bitMapping[i];            byte b3 = (byte)(1 << (int)(7 - b2 % 8));            if (flag)            {                byte b4 = (byte)(b2 / 8);                bits[(int)b4] = (byte)(bits[(int)b4] | b3);            }            else            {                byte b5 = (byte)(b2 / 8);                bits[(int)b5] = (byte)(bits[(int)b5] & ~b3);            }        }    }    private static ushort GetAlphaNumValue(char alphaNum)    {        for (int i = 0; i < 32; i++)        {            if (AlphaNumLookup[i] == alphaNum)            {                return (ushort)i;            }        }        return ushort.MaxValue;    }}