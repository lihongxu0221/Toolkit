using System.Globalization;using System.Text;namespace XceedLicenseGenerator;public class XceedKeyGenerator{    private const string AlphaNumLookup = "ABJCKTDL4UEMW71FNX52YGP98Z63HRS0";    private static readonly DateTime BaseDate = new DateTime(2001, 1, 1);    private static readonly byte[] NbDaysBitsA = { 2, 7, 12, 17, 22, 26, 31, 37, 42, 47, 51, 55, 59, 62, 255 };    private static readonly byte[] UniqueSeedBitsA = { 64, 60, 56, 52, 48, 44, 39, 35, 32, 28, 23, 19, 14, 10, 5, 1, 255 };    private static readonly byte[] ProductCodeBitsA = { 3, 16, 29, 41, 53, 61, 255 };    private static readonly byte[] ProductVersionBitsA = { 4, 15, 25, 34, 43, 50, 58, 255 };    private static readonly byte[] NbLicensesBitsA = { 6, 13, 20, 30, 38, 40, 46, 57, 255 };    private static readonly byte[] OriginCodeBitsA = { 8, 11, 21, 24, 33, 49, 255 };    private static readonly byte[] ChecksumBitsA = { 0, 9, 18, 27, 36, 45, 54, 63, 255 };    private static readonly string[] ProductIds =        {            string.Empty, "ZIP", "SFX", "BKP", "WSL", "FTP", "SCO", "BEN", "CRY", "FTB", "ZIN", "ABZ", "GRD", "SCN", "ZIC", "SCC",            "SUI", "SUN", "FTN", "FTC", "CHT", "DWN", "CHW", "IVN", "RDY", "EDN", "ZIL", "TAN", "DGF", "DGP", "WAN", "SYN",            "ZIX", "ZII", "SFN", "ZRT", "ZRC", "UPS", "TDV", "ZRS", "XPT", "OFT", "GLT", "MET", "LET", "WST", "DGS", "LBS",            "FAN", "UPP", "LBW", "BLD", "SFT", "WTK", "ZRX", "ZXA", "FXA", "SXA", "WDN", "PDF", "DGJ", "WBN", "MDN", "TKM",        };    public static string GenerateTest()    {        string xceedKey = XceedKeyGenerator.GenerateKey("WTK", 5, 1, new DateTime(2045, 12, 31), 255);        return xceedKey;    }    public static string GenerateKey(string productId, byte major, byte minor, DateTime expiryDate, byte numLicenses)    {        int productIndex = ProductIds.IndexOf(productId);        if (productIndex > 0)        {            return GenerateKey(productIndex, major, minor, expiryDate, numLicenses);        }        throw new XceedLicenseManagerException(LicenseErrorCode.InvalidProductCode);    }    public static string GenerateKey(int productIndex, int major, int minor, DateTime expiryDate, byte numLicenses)    {        byte[] bits = new byte[9];        // 修正天数限制：14位最大只能到 16383 天 (2045年)        uint days = (uint)(expiryDate.Date - BaseDate).TotalDays;        if (days > 16383)        {            days = 16383;        }        ushort seed = (ushort)new Random().Next(1, 0xFFFF);        MapNumberToBits(bits, days, NbDaysBitsA);        MapNumberToBits(bits, (uint)seed, UniqueSeedBitsA);        MapNumberToBits(bits, (uint)productIndex, ProductCodeBitsA);        MapNumberToBits(bits, (uint)((major * 10) + minor), ProductVersionBitsA);        MapNumberToBits(bits, numLicenses, NbLicensesBitsA);        MapNumberToBits(bits, 2, OriginCodeBitsA); // 2. 通常代表正式版/零售版        // 3. 计算前缀（用于 Adler32 初始向量）        string prefix = ProductIds[productIndex] + major.ToString() + minor.ToString();        // 4. 计算校验和        // 注意：原程序在计算校验和前会把 bits 中的校验和位清零，这里我们已经初始化为0        uint adler = Adler32(0, prefix.ToCharArray());        byte checksum = CalculateChecksum(adler, bits);        // 5. 将计算出的校验和填入位图        MapNumberToBits(bits, checksum, ChecksumBitsA);        // 使用精确的逆向编码逻辑        string encoded = EncodeAlphaNumString(bits);        return FormatKey(prefix + encoded + "A");    }    private static void MapNumberToBits(byte[] bits, uint number, byte[] mapping)    {        for (int i = 0; mapping[i] != 255; i++)        {            if ((number & (1U << i)) != 0)            {                int pos = mapping[i];                // 原程序的位存储逻辑：7 - b % 8 (大端序位存储)                bits[pos / 8] |= (byte)(1 << (7 - (pos % 8)));            }        }    }    private static string EncodeAlphaNumString(byte[] bits)    {        // 这里的逻辑是原程序 DecodeAlphaNumString 的精确逆过程        StringBuilder sb = new StringBuilder();        int shift = 11;        int bitsArrayIdx = 0;        for (int i = 0; i < 13; i++)        {            // 从 bits 数组中逆向提取出 5 位的值            ushort val16 = (ushort)((bits[bitsArrayIdx] << 8) | (bitsArrayIdx + 1 < bits.Length ? bits[bitsArrayIdx + 1] : 0));            int charVal = (val16 >> shift) & 0x1F;            sb.Append(AlphaNumLookup[charVal]);            if (shift < 8)            {                shift += 3;                bitsArrayIdx++;            }            else            {                shift -= 5;            }        }        return sb.ToString();    }    private static string EncodeBitsToAlphaNum(byte[] bits)    {        // 原程序中 DecodeAlphaNumString 是从 bits[0] 开始，        // 每次取 5 bit 作为一个字符。        StringBuilder sb = new StringBuilder();        int bitOffset = 0;        for (int i = 0; i < 13; i++) // 65 bits / 5 = 13 chars        {            int val = 0;            for (int j = 0; j < 5; j++)            {                int currentBit = bitOffset + j;                int byteIdx = currentBit / 8;                int bitIdx = 7 - (currentBit % 8);                if ((bits[byteIdx] & (1 << bitIdx)) != 0)                {                    val |= 1 << (4 - j);                }            }            sb.Append(AlphaNumLookup[val]);            bitOffset += 5;        }        return sb.ToString();    }    private static byte CalculateChecksum(uint adler, byte[] bits)    {        // 原程序计算 Checksum 时会对 bits 数组进行 Adler32        adler = Adler32(adler, bits);        ushort num = (ushort)((adler >> 16) ^ (adler & 0xFFFF));        return (byte)((num >> 8) ^ (num & 0xFF));    }    private static uint Adler32(uint adler, Array buffer)    {        uint s1 = adler & 0xFFFF;        uint s2 = (adler >> 16) & 0xFFFF;        foreach (var item in buffer)        {            uint val = Convert.ToUInt32(item, CultureInfo.InvariantCulture);            s1 = (s1 + val) % 65521;            s2 = (s2 + s1) % 65521;        }        return (s2 << 16) | s1;    }    private static string FormatKey(string key)    {        StringBuilder sb = new StringBuilder();        for (int i = 0; i < key.Length; i++)        {            sb.Append(key[i]);            if ((i + 1) % 5 == 0 && (i + 1) < key.Length)            {                sb.Append('-');            }        }        return sb.ToString();    }}