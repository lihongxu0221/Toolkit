using System.ComponentModel;using System.Runtime.CompilerServices;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.Completion;using RoslynPad.Roslyn;using RoslynPad.Roslyn.Completion;namespace RoslynPad.Editor;/// <summary>/// 表示 Roslyn 代码补全数据类./// </summary>internal sealed class RoslynCompletionData : ICompletionDataEx, INotifyPropertyChanged{    private readonly Document document;    private readonly CompletionItem item;    private readonly SnippetManager snippetManager;    private readonly Roslyn.Completion.Glyph glyph;    private readonly Lazy<Task> descriptionTask;    private Decorator? description;    /// <summary>    /// Initializes a new instance of the <see cref="RoslynCompletionData"/> class.    /// </summary>    /// <param name="document">文档对象.</param>    /// <param name="item">补全项.</param>    /// <param name="snippetManager">代码片段管理器.</param>    public RoslynCompletionData(Document document, CompletionItem item, SnippetManager snippetManager)    {        // 验证参数        ArgumentNullException.ThrowIfNull(document, nameof(document));        ArgumentNullException.ThrowIfNull(item, nameof(item));        ArgumentNullException.ThrowIfNull(snippetManager, nameof(snippetManager));        this.document = document;        this.item = item;        this.snippetManager = snippetManager;        this.Text = item.DisplayTextPrefix + item.DisplayText + item.DisplayTextSuffix;        this.Content = this.Text;        this.glyph = item.GetGlyph();        this.descriptionTask = new Lazy<Task>(this.RetrieveDescriptionAsync);    }    /// <summary>    /// Gets 图像图标.    /// </summary>    public CommonImage? Image => this.glyph.ToImageSource();    /// <summary>    /// Gets 显示文本.    /// </summary>    public string Text { get; }    /// <summary>    /// Gets 内容对象.    /// </summary>    public object Content { get; }    /// <summary>    /// Gets 描述信息视图模型.    /// </summary>    public object Description    {        get        {            // 如果描述装饰器为空，则进行初始化            if (this.description == null)            {                this.description = new Decorator();#if AVALONIA                this.description.Initialized += (o, e) => { var task = this.descriptionTask.Value; };#else                this.description.Loaded += (o, e) => { var task = this.descriptionTask.Value; };#endif            }            return this.description;        }    }    /// <summary>    /// Gets 优先级.    /// </summary>    public double Priority { get; private set; }    /// <summary>    /// Gets a value indicating whether 是否被选中.    /// </summary>    public bool IsSelected => this.item.Rules.MatchPriority == MatchPriority.Preselect;    /// <summary>    /// Gets 排序文本.    /// </summary>    public string SortText => this.item.SortText;    /// <summary>    /// 属性变更事件.    /// </summary>    public event PropertyChangedEventHandler? PropertyChanged;    /// <summary>    /// 完成补全操作.    /// </summary>    /// <param name="textArea">文本区域.</param>    /// <param name="completionSegment">补全文本段.</param>    /// <param name="e">事件参数.</param>    public async void Complete(TextArea textArea, ISegment completionSegment, EventArgs e)    {        // 如果是代码片段则执行代码片段补全        if (this.glyph == Roslyn.Completion.Glyph.Snippet && this.CompleteSnippet(textArea, completionSegment, e) ||            CompletionService.GetService(this.document) is not { } completionService)        {            return;        }        // 获取补全更改内容        var completionChanges = await completionService.GetChangeAsync(this.document, this.item, null).ConfigureAwait(true);        var primaryTextChange = completionChanges.TextChange;        var currentDocument = textArea.Document;        using (currentDocument.RunUpdate())        {            // 如果补全段的结束位置超过了更改范围，需要移除多余的字符            if (completionSegment.EndOffset > primaryTextChange.Span.End)            {                currentDocument.Replace(                    new TextSegment { StartOffset = primaryTextChange.Span.End, EndOffset = completionSegment.EndOffset },                    string.Empty);            }            currentDocument.Replace(                primaryTextChange.Span.Start,                primaryTextChange.Span.Length,                new StringTextSource(primaryTextChange.NewText));        }        // 如果存在新位置，则更新光标        if (completionChanges.NewPosition != null)        {            textArea.Caret.Offset = completionChanges.NewPosition.Value;        }    }    /// <summary>    /// 执行代码片段补全逻辑.    /// </summary>    /// <param name="textArea">文本区域.</param>    /// <param name="completionSegment">补全文本段.</param>    /// <param name="e">事件参数.</param>    /// <returns>是否成功执行代码片段补全.</returns>    private bool CompleteSnippet(TextArea textArea, ISegment completionSegment, EventArgs e)    {        char? inputChar = null;        var commonTextArgs = e as CommonTextEventArgs;        // 获取触发补全的字符        if (commonTextArgs != null && commonTextArgs.Text?.Length > 0)        {            inputChar = commonTextArgs.Text[0];        }        else if (e is KeyEventArgs keyEventArgs && keyEventArgs.Key == Key.Tab)        {            inputChar = '\t';        }        // 仅在按下 Tab 键时触发代码片段        if (inputChar == '\t')        {            var codeSnippet = this.snippetManager.FindSnippet(this.item.DisplayText);            if (codeSnippet != null)            {                var avalonEditSnippet = codeSnippet.CreateAvalonEditSnippet();                using (textArea.Document.RunUpdate())                {                    textArea.Document.Remove(completionSegment.Offset, completionSegment.Length);                    avalonEditSnippet.Insert(textArea);                }                if (commonTextArgs != null)                {                    commonTextArgs.Handled = true;                }                return true;            }        }        return false;    }    /// <summary>    /// 获取详细描述信息.    /// </summary>    /// <returns>异步任务.</returns>    private async Task RetrieveDescriptionAsync()    {        if (this.description == null ||            CompletionService.GetService(this.document) is not { } completionService)        {            return;        }        // 在后台线程获取描述文本        var descriptionContent = await Task.Run(() => completionService.GetDescriptionAsync(this.document, this.item)).ConfigureAwait(true);        this.description.Child = descriptionContent?.TaggedParts.ToTextBlock();    }    /// <summary>    /// 触发属性变更通知.    /// </summary>    /// <param name="propertyName">属性名称.</param>    private void OnPropertyChanged([CallerMemberName] string? propertyName = null)    {        this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));    }}