using System.Reflection;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.CSharp.Scripting;using Microsoft.CodeAnalysis.Scripting;namespace BgCommon.Script;/// <summary>/// 脚本上下文类，集成 Roslyn 脚本引擎实现代码的加载、编译与执行./// </summary>public sealed class ScripteContext : IDisposable{    private string code = string.Empty;    private bool isDirty;    private bool isRunning;    private Script<object>? compiledScript;    private ScriptState<object>? scriptState;    /// <summary>    /// Initializes a new instance of the <see cref="ScripteContext"/> class.    /// </summary>    /// <param name="scripteName">脚本名称.</param>    /// <param name="scriptPath">脚本存储路径.</param>    /// <param name="referLibsPath">引用库路径.</param>    private ScripteContext(string scripteName, string scriptPath, string referLibsPath)    {        // 初始化基本属性        this.ScriptPath = scriptPath;        this.ReferLibsPath = referLibsPath;        this.ScriptName = scripteName;        this.Template = null;    }    /// <summary>    /// Initializes a new instance of the <see cref="ScripteContext"/> class.    /// </summary>    /// <param name="name">脚本名称或模板名称.</param>    /// <param name="config">脚本配置信息.</param>    /// <param name="isTemplate">指示是否为脚本模板模式.</param>    public ScripteContext(string name, ScriptConfig config, bool isTemplate)    {        // 验证配置对象是否为空.        ArgumentNullException.ThrowIfNull(config, nameof(config));        // 修复问题 1：统一从配置获取脚本存储根路径，确保模板模式下也能正确找到保存目录.        this.ScriptPath = config.ScriptPath;        this.Namespaces = new List<string>(config.Namespaces);        this.ReferLibsPath = config.ReferLibsPath;        // 默认加载全局引用库.        this.ReferLibs = new List<string>(config.ReferLibs);        this.isDirty = false;        this.isRunning = false;        if (isTemplate)        {            // 模板模式：脚本名称初始为空.            this.ScriptName = string.Empty;            this.Template = config.Templates.FirstOrDefault(t => t.TemplateName.Equals(name, StringComparison.OrdinalIgnoreCase));            // 如果匹配到模板，则根据模板配置覆盖或合并引用信息.            if (this.Template != null)            {                this.ReferLibsPath = this.Template.ReferLibsPath;                if (this.Template.ReferLibs.Count > 0)                {                    // 若模板指定了引用库，则替换全局引用库.                    this.ReferLibs.Clear();                    foreach (string library in this.Template.ReferLibs)                    {                        this.ReferLibs.Add(library);                    }                }            }        }        else        {            // 脚本文件模式：指定脚本名称.            this.ScriptName = name;            this.Template = null;        }    }    /// <summary>    /// Gets 脚本名称.    /// </summary>    public string ScriptName { get; private set; } = string.Empty;    /// <summary>    /// Gets 脚本文件的物理存储路径.    /// </summary>    public string FilePath => string.IsNullOrEmpty(this.ScriptName) ? string.Empty : Path.Combine(this.ScriptPath, $"{this.ScriptName}.cs");    /// <summary>    /// Gets 引用程序集所在路径.    /// </summary>    public string ReferLibsPath { get; } = string.Empty;    /// <summary>    /// Gets 脚本文件存储路径.    /// </summary>    public string ScriptPath { get; } = string.Empty;    /// <summary>    /// Gets 脚本模板配置信息.    /// </summary>    public ScriptTemplate? Template { get; private set; }    /// <summary>    /// Gets 脚本预定义的命名空间列表.    /// </summary>    public List<string> Namespaces { get; } = new List<string>();    /// <summary>    /// Gets 脚本需要引用的外部程序集列表.    /// </summary>    public List<string> ReferLibs { get; } = new List<string>();    /// <summary>    /// Gets 脚本的代码内容.    /// </summary>    public string Code    {        get => this.code;        private set        {            if (this.code != value)            {                this.code = value;                this.IsDirty = true;            }        }    }    /// <summary>    /// Gets or sets a value indicating whether 脚本内容是否已更改且未保存.    /// </summary>    public bool IsDirty    {        get => this.isDirty;        set => this.isDirty = value;    }    /// <summary>    /// Gets a value indicating whether 脚本是否正在运行.    /// </summary>    public bool IsRunning    {        get => this.isRunning;        private set => this.isRunning = value;    }    /// <summary>    /// 当对象释放时触发的事件.    /// </summary>    public event EventHandler? OnDispose;    /// <summary>    /// 当脚本环境初始化完成时触发的事件.    /// </summary>    public event EventHandler? OnInitialized;    /// <summary>    /// 当脚本保存完成时触发的事件.    /// </summary>    public event EventHandler? OnSaved;    /// <summary>    /// 当脚本运行或编译发生错误时触发的事件.    /// </summary>    public event EventHandler? OnError;    /// <summary>    /// 当脚本开始编译时触发的事件.    /// </summary>    public event EventHandler? OnCompiling;    /// <summary>    /// 当脚本编译完成时触发的事件.    /// </summary>    public event EventHandler? OnCompiled;    /// <summary>    /// 当脚本开始运行时触发的事件.    /// </summary>    public event EventHandler? OnRunning;    /// <summary>    /// 当脚本运行结束时触发的事件.    /// </summary>    public event EventHandler? OnRuned;    /// <summary>    /// 异步加载脚本内容. 模板模式从模板加载，普通模式从物理文件加载.    /// </summary>    /// <returns>表示异步操作的任务.</returns>    public async Task LoadAsync()    {        // 1. 如果是模板模式，从模板路径加载初始代码.        if (this.Template != null)        {            if (File.Exists(this.Template.TemplatePath))            {                this.code = await File.ReadAllTextAsync(this.Template.TemplatePath);                // 模板加载视为新创作，标记为已修改.                this.IsDirty = true;                this.OnInitialized?.Invoke(this, EventArgs.Empty);            }            return;        }        // 2. 如果是普通脚本模式，从已知的物理文件路径加载内容.        if (!string.IsNullOrEmpty(this.FilePath) && File.Exists(this.FilePath))        {            this.code = await File.ReadAllTextAsync(this.FilePath);            // 物理文件加载，初始状态设为未修改.            this.IsDirty = false;            this.OnInitialized?.Invoke(this, EventArgs.Empty);        }    }    /// <summary>    /// 异步编译当前脚本代码.    /// </summary>    /// <returns>编译是否成功.</returns>    public async Task<bool> CompileAsync()    {        this.OnCompiling?.Invoke(this, EventArgs.Empty);        try        {            ScriptOptions options = ScriptOptions.Default                .WithReferences(this.GetMetadataReferences())                .WithImports(this.Namespaces);            this.compiledScript = CSharpScript.Create<object>(this.Code, options);            IEnumerable<Diagnostic> diagnostics = this.compiledScript.Compile();            if (diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error))            {                this.OnError?.Invoke(this, EventArgs.Empty);                return false;            }            this.OnCompiled?.Invoke(this, EventArgs.Empty);            return true;        }        catch (Exception)        {            this.OnError?.Invoke(this, EventArgs.Empty);            return false;        }    }    /// <summary>    /// 异步执行已编译的脚本对象.    /// </summary>    /// <param name="globals">执行宿主对象.</param>    /// <returns>脚本返回值.</returns>    public async Task<object?> RunAsync(object? globals = null)    {        if (this.compiledScript == null)        {            bool isCompiled = await this.CompileAsync();            if (!isCompiled)            {                return null;            }        }        this.IsRunning = true;        this.OnRunning?.Invoke(this, EventArgs.Empty);        try        {            this.scriptState = await this.compiledScript!.RunAsync(globals);            return this.scriptState.ReturnValue;        }        catch (Exception)        {            this.OnError?.Invoke(this, EventArgs.Empty);            return null;        }        finally        {            this.IsRunning = false;            this.OnRuned?.Invoke(this, EventArgs.Empty);        }    }    /// <summary>    /// 异步保存脚本. 如果当前是模板模式，则必须传入脚本名称以创建实体文件.    /// </summary>    /// <param name="newScriptName">模板保存为脚本时使用的名称.</param>    /// <returns>表示异步操作的任务.</returns>    public async Task SaveAsync(string? newScriptName = null)    {        // 处理模板模式或未命名脚本的保存：必须指定名称.        if (this.Template != null && string.IsNullOrEmpty(this.ScriptName))        {            if (string.IsNullOrWhiteSpace(newScriptName))            {                throw new ArgumentException("保存新脚本时必须提供脚本名称.", nameof(newScriptName));            }            this.ScriptName = newScriptName;        }        if (string.IsNullOrEmpty(this.FilePath))        {            throw new InvalidOperationException("保存路径无效，文件名不能为空.");        }        // 异步写入文件内容.        await File.WriteAllTextAsync(this.FilePath, this.Code);        this.IsDirty = false;        this.OnSaved?.Invoke(this, EventArgs.Empty);        if (this.Template != null)        {            this.Template = null;        }    }    /// <summary>    /// 异步重命名当前脚本，并物理删除旧文件. 模板模式下不支持此操作.    /// </summary>    /// <param name="newName">新脚本名称.</param>    /// <returns>表示异步操作的任务.</returns>    public async Task RenameAsync(string newName)    {        ArgumentNullException.ThrowIfNull(newName, nameof(newName));        if (this.Template != null)        {            throw new InvalidOperationException("从模板创建的上下文不支持重命名操作.");        }        // 检查新旧名称是否一致.        if (this.ScriptName.Equals(newName, StringComparison.Ordinal))        {            await this.SaveAsync();            return;        }        // 记录旧文件路径.        string oldFilePath = this.FilePath;        // 更新名称，进而更新 FilePath.        this.ScriptName = newName;        // 修复问题 2：先尝试保存新文件，成功后再删除旧文件，确保操作的原子性和数据安全.        await this.SaveAsync();        if (!string.IsNullOrEmpty(oldFilePath) && File.Exists(oldFilePath))        {            await Task.Run(() => File.Delete(oldFilePath));        }    }    /// <summary>    /// 异步将当前代码内容另存为新脚本. 原有上下文标记为已同步.    /// </summary>    /// <param name="newName">另存为的脚本名称.</param>    /// <returns>返回代表新脚本文件的 <see cref="ScripteContext"/> 实例.</returns>    public async Task<ScripteContext> SaveAsAsync(string newName)    {        ArgumentNullException.ThrowIfNull(newName, nameof(newName));        if (this.Template != null)        {            throw new InvalidOperationException("从模板创建的上下文不支持另存为操作.");        }        // 1. 在物理磁盘创建新副本.        string targetPath = Path.Combine(this.ScriptPath, $"{newName}.cs");        await File.WriteAllTextAsync(targetPath, this.Code);        // 修复问题 3：另存为成功后，当前内存中的代码已视为已同步到磁盘副本.        this.IsDirty = false;        // 2. 初始化并返回一个全新的上下文对象.        ScripteContext newContext = new ScripteContext(newName, this.ScriptPath, this.ReferLibsPath);        newContext.Namespaces.AddRange(this.Namespaces);        newContext.ReferLibs.AddRange(this.ReferLibs);        // 直接赋值字段以规避 IsDirty 的自动触发.        newContext.code = this.Code;        newContext.IsDirty = false;        return newContext;    }    /// <summary>    /// 释放脚本上下文占用的资源.    /// </summary>    public void Dispose()    {        this.OnDispose?.Invoke(this, EventArgs.Empty);        this.compiledScript = null;        this.scriptState = null;        GC.SuppressFinalize(this);    }    /// <summary>    /// 解析并获取所有元数据引用.    /// </summary>    /// <returns>程序集引用集合.</returns>    private IEnumerable<Assembly> GetMetadataReferences()    {        List<Assembly> metadataReferences = new List<Assembly>();        // 核心程序集.        metadataReferences.Add(typeof(object).Assembly);        metadataReferences.Add(typeof(Enumerable).Assembly);        foreach (string libName in this.ReferLibs)        {            try            {                string fullPath = Path.Combine(this.ReferLibsPath, libName);                if (File.Exists(fullPath))                {                    metadataReferences.Add(Assembly.LoadFrom(fullPath));                }                else                {                    metadataReferences.Add(Assembly.Load(libName));                }            }            catch            {                // 忽略加载异常，实际应用中建议记录日志.            }        }        return metadataReferences.Distinct();    }}