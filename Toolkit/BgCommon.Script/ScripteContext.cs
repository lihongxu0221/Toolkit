using System.Reflection;using BgLogger;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.CSharp.Scripting;using Microsoft.CodeAnalysis.Scripting;namespace BgCommon.Script;/// <summary>/// 脚本上下文类，集成 Roslyn 脚本引擎实现代码的加载、编译与执行./// </summary>public sealed class ScripteContext : IDisposable{    // 定义一套所有脚本通用的基础核心程序集    private static readonly IReadOnlyList<Assembly> DefaultBaseAssemblies = new List<Assembly>    {        typeof(object).Assembly,                          // System.Private.CoreLib        typeof(Console).Assembly,                         // System.Console        typeof(Enumerable).Assembly,                      // System.Linq        typeof(System.ComponentModel.Component).Assembly, // System.ComponentModel        typeof(System.Text.Json.JsonSerializer).Assembly, // 现代应用常用的 JSON 序列化        Assembly.Load("System.Runtime"),                  // .NET Core 基础运行库        Assembly.Load("netstandard"),                     // 标准库适配        Assembly.Load("RoslynPad.Runtime"),               // RoslynPad 运行时支持        Assembly.GetExecutingAssembly(),                  // 允许脚本访问宿主定义的类型    };    private string scriptName = string.Empty;    private string code = string.Empty;    private bool isDirty;    private bool isRunning;    private Script<object>? compiledScript;    private ScriptState<object>? scriptState;    /// <summary>    /// Initializes a new instance of the <see cref="ScripteContext"/> class.    /// </summary>    /// <param name="scripteName">脚本名称.</param>    /// <param name="scriptPath">脚本存储路径.</param>    /// <param name="referLibsPath">引用库路径.</param>    private ScripteContext(string scripteName, string scriptPath, string referLibsPath)    {        // 初始化基本属性        this.ScriptPath = scriptPath;        this.ReferLibsPath = referLibsPath;        this.scriptName = scripteName;        this.Extension = "csx";        this.Template = null;    }    /// <summary>    /// Initializes a new instance of the <see cref="ScripteContext"/> class.    /// </summary>    /// <param name="name">脚本名称或模板名称.</param>    /// <param name="config">脚本配置信息.</param>    /// <param name="isTemplate">指示是否为脚本模板模式.</param>    public ScripteContext(string name, ScriptConfig config, bool isTemplate)    {        // 验证配置对象是否为空.        ArgumentNullException.ThrowIfNull(config, nameof(config));        string extension = "csx";        if (!string.IsNullOrEmpty(config.ScriptFileExtension))        {            extension = config.ScriptFileExtension;        }        // 统一从配置获取脚本存储根路径，确保模板模式下也能正确找到保存目录.        this.ScriptPath = config.ScriptPath;        this.Extension = extension;        this.Namespaces = new List<string>(config.Namespaces);        this.ReferLibsPath = config.ReferLibsPath;        this.ReferLibs = new List<string>(config.ReferLibs);        this.isDirty = false;        this.isRunning = false;        if (isTemplate)        {            // 模板模式：脚本名称初始为空.            this.scriptName = string.Empty;            this.Template = config.Templates.FirstOrDefault(t => t.TemplateName.Equals(name, StringComparison.OrdinalIgnoreCase));            // 如果匹配到模板，则根据模板配置覆盖或合并引用信息.            if (this.Template != null)            {                this.ReferLibsPath = this.Template.ReferLibsPath;                if (this.Template.ReferLibs.Count > 0)                {                    // 若模板指定了引用库，则替换全局引用库.                    this.ReferLibs.Clear();                    this.ReferLibs.AddRange(this.Template.ReferLibs);                }            }        }        else        {            // 脚本文件模式：指定脚本名称.            this.scriptName = name;            this.Template = null;        }    }    /// <summary>    /// Gets 脚本运行所需的基础程序集引用.    /// </summary>    /// <remarks>    /// 这些是系统级别的基础库，不随模板或配置改变而改变.    /// </remarks>    public IReadOnlyList<Assembly> BaseAssemblies => DefaultBaseAssemblies;    /// <summary>    /// Gets 脚本名称.    /// </summary>    public string ScriptName => this.scriptName;    /// <summary>    /// Gets or sets 脚本文件扩展名.    /// </summary>    public string Extension { get; set; } = "csx";    /// <summary>    /// Gets 脚本文件存储路径.    /// </summary>    public string ScriptPath { get; } = string.Empty;    /// <summary>    /// Gets 脚本文件的物理存储路径.    /// </summary>    public string ScriptFilePath => string.IsNullOrEmpty(this.ScriptName) ? string.Empty : Path.Combine(this.ScriptPath, $"{this.ScriptName}.{this.Extension}");    /// <summary>    /// Gets 引用程序集所在路径.    /// </summary>    public string ReferLibsPath { get; } = string.Empty;    /// <summary>    /// Gets 脚本模板配置信息.    /// </summary>    public ScriptTemplate? Template { get; private set; }    /// <summary>    /// Gets 脚本预定义的命名空间列表.    /// </summary>    public List<string> Namespaces { get; } = new List<string>();    /// <summary>    /// Gets 脚本需要引用的外部程序集列表.    /// </summary>    public List<string> ReferLibs { get; } = new List<string>();    /// <summary>    /// Gets 脚本的代码内容.    /// </summary>    public string Code    {        get => this.code;        private set        {            if (this.code != value)            {                this.code = value;                this.IsDirty = true;            }        }    }    /// <summary>    /// Gets 从脚本代码中解析出的摘要说明（自动从顶部注释提取）.    /// </summary>    public string Summary => ScriptMetadataParser.GetSummary(this.Code);    /// <summary>    /// Gets or sets a value indicating whether 脚本内容是否已更改且未保存.    /// </summary>    public bool IsDirty    {        get => this.isDirty;        set => this.isDirty = value;    }    /// <summary>    /// Gets a value indicating whether 脚本是否正在运行.    /// </summary>    public bool IsRunning    {        get => this.isRunning;        private set => this.isRunning = value;    }    /// <summary>    /// 当对象释放时触发.    /// </summary>    public event EventHandler? OnDispose;    /// <summary>    /// 当脚本环境加载/初始化完成时触发.    /// </summary>    public event EventHandler<ScriptFileEventArgs>? OnInitialized;    /// <summary>    /// 当脚本保存完成时触发.    /// </summary>    public event EventHandler<ScriptFileEventArgs>? OnSaved;    /// <summary>    /// 当脚本发生任何阶段的错误时触发.    /// </summary>    public event EventHandler<ScriptErrorEventArgs>? OnError;    /// <summary>    /// 当脚本开始编译时触发.    /// </summary>    public event EventHandler? OnCompiling;    /// <summary>    /// 当脚本编译结束（无论成功失败）时触发.    /// </summary>    public event EventHandler<ScriptCompilationEventArgs>? OnCompiled;    /// <summary>    /// 当脚本开始运行时触发.    /// </summary>    public event EventHandler? OnRunning;    /// <summary>    /// 当脚本运行结束时触发.    /// </summary>    public event EventHandler<ScriptExecutionEventArgs>? OnRuned;    /// <summary>    /// 异步加载脚本内容. 模板模式从模板加载，普通模式从物理文件加载.    /// </summary>    /// <returns>表示异步操作的任务.</returns>    public async Task LoadAsync()    {        try        {            // 1. 如果是模板模式，从模板路径加载初始代码.            if (this.Template != null)            {                string templateFilePath = this.Template.CodeTemplateFilePath;                if (File.Exists(templateFilePath))                {                    this.code = await File.ReadAllTextAsync(templateFilePath);                    // 模板加载视为新创作，标记为已修改.                    this.IsDirty = true;                    this.OnInitialized?.Invoke(this, new ScriptFileEventArgs(ScriptFileAction.Loaded, $"Template:{this.Template.TemplateName}", templateFilePath));                }                return;            }            // 2. 如果是普通脚本模式，从已知的物理文件路径加载内容.            if (!string.IsNullOrEmpty(this.ScriptFilePath) && File.Exists(this.ScriptFilePath))            {                this.code = await File.ReadAllTextAsync(this.ScriptFilePath);                // 物理文件加载，初始状态设为未修改.                this.IsDirty = false;                this.OnInitialized?.Invoke(this, new ScriptFileEventArgs(                    ScriptFileAction.Loaded,                    this.ScriptName,                    this.ScriptFilePath));            }        }        catch (Exception ex)        {            this.OnError?.Invoke(this, new ScriptErrorEventArgs(                ScriptErrorSource.Loading,                ex,                "加载脚本失败"));        }    }    /// <summary>    /// 内部使用的更名方法，仅由 Manager 在文件系统同步时调用.    /// </summary>    /// <param name="newName">新的脚本名称.</param>    internal void UpdateNameInternal(string newName)    {        this.scriptName = newName;    }    /// <summary>    /// 更新脚本代码内容（通常由编辑器调用）.    /// </summary>    /// <param name="newCode">新的代码字符串.</param>    public void UpdateCode(string newCode)    {        if (this.code != newCode)        {            this.code = newCode;            this.IsDirty = true;            this.compiledScript = null; // 代码改变，清除已编译的缓存        }    }    /// <summary>    /// 异步编译当前脚本代码.    /// </summary>    /// <returns>编译是否成功.</returns>    public async Task<bool> CompileAsync()    {        this.OnCompiling?.Invoke(this, EventArgs.Empty);        var stopwatch = Stopwatch.StartNew();        try        {            ScriptOptions options = ScriptOptions.Default                .WithReferences(this.GetMetadataReferences())                .WithImports(this.Namespaces);            this.compiledScript = CSharpScript.Create<object>(this.Code, options, typeof(ScriptGlobals));            var diagnostics = this.compiledScript.Compile();            stopwatch.Stop();            bool isSuccess = !diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error);            var args = new ScriptCompilationEventArgs(isSuccess, diagnostics.ToList(), stopwatch.Elapsed);            this.OnCompiled?.Invoke(this, args);            if (!isSuccess)            {                var compileEx = new ScriptCompilationException(diagnostics);                this.OnCompiled?.Invoke(this, new ScriptCompilationEventArgs(false, diagnostics.ToList(), stopwatch.Elapsed));                this.OnError?.Invoke(this, new ScriptErrorEventArgs(                    ScriptErrorSource.Compilation,                    compileEx,                    compileEx.Message));                return false;            }            this.OnCompiled?.Invoke(this, new ScriptCompilationEventArgs(true, diagnostics.ToList(), stopwatch.Elapsed));            return true;        }        catch (Exception ex)        {            stopwatch.Stop();            this.OnError?.Invoke(this, new ScriptErrorEventArgs(ScriptErrorSource.Compilation, ex, ex.Message));            return false;        }    }    /// <summary>    /// 异步执行已编译的脚本对象.    /// </summary>    /// <param name="globals">执行宿主对象.</param>    /// <param name="ct">取消令牌.</param>    /// <returns>脚本返回值.</returns>    public async Task<object?> RunAsync(ScriptGlobals? globals = null, CancellationToken ct = default)    {        if (this.compiledScript == null)        {            if (!await this.CompileAsync())            {                return null;            }        }        this.IsRunning = true;        this.OnRunning?.Invoke(this, EventArgs.Empty);        var stopwatch = Stopwatch.StartNew();        try        {            if (globals != null)            {                globals.CancellationToken = ct;            }            // Roslyn 脚本引擎会解析 globals 对象的属性，使脚本内可直接使用 Log() 或 Data            this.scriptState = await this.compiledScript!.RunAsync(globals, ct);            stopwatch.Stop();            var args = new ScriptExecutionEventArgs(this.scriptState.ReturnValue, stopwatch.Elapsed);            this.OnRuned?.Invoke(this, args);            return this.scriptState.ReturnValue;        }        catch (OperationCanceledException)        {            stopwatch.Stop();            LogRun.Info($"脚本 {this.ScriptName} 执行被取消.");            this.OnRuned?.Invoke(this, new ScriptExecutionEventArgs(null, stopwatch.Elapsed, new OperationCanceledException(ct)));            return null;        }        catch (Exception ex)        {            stopwatch.Stop();            this.OnError?.Invoke(this, new ScriptErrorEventArgs(ScriptErrorSource.Execution, ex, "脚本运行崩溃"));            this.OnRuned?.Invoke(this, new ScriptExecutionEventArgs(null, stopwatch.Elapsed, ex));            return null;        }        finally        {            this.IsRunning = false;        }    }    /// <summary>    /// 异步保存脚本. 如果当前是模板模式，则必须传入脚本名称以创建实体文件.    /// </summary>    /// <param name="newScriptName">模板保存为脚本时使用的名称.</param>    /// <returns>表示异步操作的任务.</returns>    public async Task SaveAsync(string? newScriptName = null)    {        try        {            ScriptFileAction action = ScriptFileAction.Saved;            // 处理模板模式或未命名脚本的保存：必须指定名称.            if (this.Template != null && string.IsNullOrEmpty(this.ScriptName))            {                if (string.IsNullOrWhiteSpace(newScriptName))                {                    throw new ArgumentException("保存新脚本时必须提供脚本名称.", nameof(newScriptName));                }                this.scriptName = newScriptName;                action = ScriptFileAction.CreatedFromTemplate; // 标记为从模板创建            }            if (string.IsNullOrEmpty(this.ScriptFilePath))            {                throw new InvalidOperationException("保存路径无效，文件名不能为空.");            }            // 异步写入文件内容.            await File.WriteAllTextAsync(this.ScriptFilePath, this.Code);            this.IsDirty = false;            this.OnSaved?.Invoke(this, new ScriptFileEventArgs(action, this.ScriptName, this.ScriptFilePath));            if (this.Template != null)            {                this.Template = null;            }        }        catch (Exception ex)        {            this.OnError?.Invoke(this, new ScriptErrorEventArgs(ScriptErrorSource.Saving, ex, "保存文件出错"));            throw;        }    }    /// <summary>    /// 异步重命名当前脚本，并物理删除旧文件. 模板模式下不支持此操作.    /// </summary>    /// <param name="newName">新脚本名称.</param>    /// <returns>表示异步操作的任务.</returns>    public async Task RenameAsync(string newName)    {        ArgumentNullException.ThrowIfNull(newName, nameof(newName));        if (this.Template != null)        {            throw new InvalidOperationException("从模板创建的上下文不支持重命名操作.");        }        // 记录旧文件路径.        string oldFilePath = this.ScriptFilePath;        string oldScriptName = this.ScriptName;        // 检查新旧名称是否一致.        if (oldScriptName.Equals(newName, StringComparison.Ordinal))        {            // 是否有必要保存当前文件？            // await this.SaveAsync();            return;        }        this.scriptName = newName;        string newFilePath = this.ScriptFilePath;        try        {            // 物理写入新文件            await File.WriteAllTextAsync(newFilePath, this.Code);            if (!string.IsNullOrEmpty(oldFilePath) && File.Exists(oldFilePath))            {                await Task.Run(() => File.Delete(oldFilePath));            }            // 触发 Renamed 事件，并带上旧路径以便 UI 更新映射            this.OnSaved?.Invoke(this, new ScriptFileEventArgs(                ScriptFileAction.Renamed,                this.ScriptName,                newFilePath,                oldFilePath));        }        catch (Exception ex)        {            this.scriptName = oldScriptName; // 回滚名称            this.OnError?.Invoke(this, new ScriptErrorEventArgs(                ScriptErrorSource.FileOperation,                ex,                "重命名失败"));        }    }    /// <summary>    /// 异步将当前代码内容另存为新脚本. 原有上下文标记为已同步.    /// </summary>    /// <param name="newName">另存为的脚本名称.</param>    /// <returns>返回代表新脚本文件的 <see cref="ScripteContext"/> 实例.</returns>    public async Task<ScripteContext> SaveAsAsync(string newName)    {        ArgumentNullException.ThrowIfNull(newName, nameof(newName));        if (this.Template != null)        {            throw new InvalidOperationException("从模板创建的上下文不支持另存为操作.");        }        string oldPath = this.ScriptFilePath;        // 在物理磁盘创建新副本.        string targetPath = Path.Combine(this.ScriptPath, $"{newName}.cs");        await File.WriteAllTextAsync(targetPath, this.Code);        // 另存为成功后，当前内存中的代码已视为已同步到磁盘副本.        this.IsDirty = false;        // 2. 初始化并返回一个全新的上下文对象.        var newContext = new ScripteContext(newName, this.ScriptPath, this.ReferLibsPath);        newContext.Namespaces.AddRange(this.Namespaces);        newContext.ReferLibs.AddRange(this.ReferLibs);        newContext.Extension = this.Extension;        newContext.Code = this.Code;        newContext.IsDirty = false;        // 触发另存为事件        this.OnSaved?.Invoke(this, new ScriptFileEventArgs(ScriptFileAction.SavedAs, newName, targetPath, oldPath));        return newContext;    }    /// <summary>    /// 释放脚本上下文占用的资源.    /// </summary>    public void Dispose()    {        this.OnDispose?.Invoke(this, EventArgs.Empty);        this.compiledScript = null;        this.scriptState = null;        GC.SuppressFinalize(this);    }    /// <summary>    /// 获取当前脚本环境下所有引用的元数据引用 (MetadataReference).    /// 常用于初始化 RoslynPad 编辑器.    /// </summary>    /// <returns>程序集引用集合.</returns>    public IEnumerable<MetadataReference> GetMetadataReferencesForEditor()    {        foreach (var assembly in GetMetadataReferences())        {            if (!string.IsNullOrEmpty(assembly.Location))            {                yield return MetadataReference.CreateFromFile(assembly.Location);            }        }    }    /// <summary>    /// 解析并获取所有元数据引用.    /// </summary>    /// <returns>程序集引用集合.</returns>    private IEnumerable<Assembly> GetMetadataReferences()    {        // 1. 首先放入基础核心程序集        List<Assembly> metadataReferences = new List<Assembly>(this.BaseAssemblies);        // 2. 放入宿主程序集（可选：允许脚本访问管理器所在的程序集）        metadataReferences.Add(Assembly.GetExecutingAssembly());        // 3. 加载用户/模板配置的引用库        foreach (string libName in this.ReferLibs)        {            try            {                string fullPath = Path.Combine(this.ReferLibsPath, libName);                if (File.Exists(fullPath))                {                    metadataReferences.Add(Assembly.LoadFrom(fullPath));                }                else                {                    metadataReferences.Add(Assembly.Load(libName));                }            }            catch (Exception ex)            {                LogRun.Error($"无法加载程序集引用: {libName}, {ex.Message}");            }        }        // 4. 去重并返回        return metadataReferences.Distinct();    }}