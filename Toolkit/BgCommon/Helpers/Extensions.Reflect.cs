using System.Security.AccessControl;namespace BgCommon;/// <summary>/// 反射相关扩展方法./// </summary>public static partial class Extensions{    private static readonly HashSet<Type> ExtraSimpleTypes = new HashSet<Type>()    {        typeof(string),        typeof(decimal),        typeof(DateTime),        typeof(DateTimeOffset),        typeof(TimeSpan),        typeof(Guid),        typeof(Uri), // 通常 Uri 也被视为简单类型，可视情况移除        typeof(DateOnly), // .NET 6+ 新增类型        typeof(TimeOnly), // .NET 6+ 新增类型    };    /// <summary>    /// 判断一个类型是否为“简单”类型（值类型、枚举、字符串等），    /// 对于这些类型，我们不再需要向下递归.    /// </summary>    /// <param name="type">类型.</param>    /// <returns>返回类型是否为简单类型.</returns>    public static bool IsSimpleType(this Type? type)    {        ArgumentNullException.ThrowIfNull(type);        // 1. 处理 Nullable<T>，递归判断底层类型        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))        {            // Nullable.GetUnderlyingType 不会返回 null，因为已经确定是 Nullable<>            return IsSimpleType(Nullable.GetUnderlyingType(type));        }        // 2. 核心判断逻辑        // IsPrimitive 包含: Boolean, Byte, SByte, Int16, UInt16, Int32, UInt32, Int64, UInt64, IntPtr, UIntPtr, Char, Double, Single        if (type.IsPrimitive || type.IsEnum)        {            return true;        }        // 3. 查表判断其他常用类型 (String, Decimal, DateTime...)        return ExtraSimpleTypes.Contains(type);    }    /// <summary>    /// 判断当前 Type 是否为 .NET 内置数字类型（包含整数、浮点数、十进制数）.    /// </summary>    /// <param name="type">要判断的 Type 实例（支持可空类型，如 int?、double?）.</param>    /// <returns>是内置数字类型则返回 true，否则返回 false.</returns>    /// <exception cref="ArgumentNullException">当 type 为 null 时抛出.</exception>    public static bool IsNumberType(this Type type)    {        // .NET 8 新增空值校验方法，语法更简洁        ArgumentNullException.ThrowIfNull(type);        // 处理可空值类型（如 int? → 提取底层类型 int）        Type underlyingType = Nullable.GetUnderlyingType(type) ?? type;        if (underlyingType.IsEnum)        {            return false;        }        // 使用 Type.GetTypeCode 获取类型代码，利用 switch 表达式（编译为跳转表）实现 O(1) 查找        // 这种方式比 HashSet 快，且不需要额外的静态内存分配        return Type.GetTypeCode(underlyingType) switch        {            TypeCode.Byte or            TypeCode.SByte or            TypeCode.Int16 or            TypeCode.UInt16 or            TypeCode.Int32 or            TypeCode.UInt32 or            TypeCode.Int64 or            TypeCode.UInt64 or            TypeCode.Single or            TypeCode.Double or            TypeCode.Decimal => true,            _ => false        };    }    /// <summary>    /// 判断当前 Type 是否为 .NET 内置浮点数类型.    /// </summary>    /// <param name="type">要判断的 Type 实例（不可为 null）.</param>    /// <param name="isBinaryFloat">是否为是否为「二进制浮点数」类型（排除 decimal 十进制浮点）.</param>    /// <returns>是内置浮点数类型则返回 true，否则返回 false.</returns>    /// <exception cref="ArgumentNullException">当 type 为 null 时抛出.</exception>    public static bool IsFloatType(this Type type, bool isBinaryFloat)    {        // 空值校验（符合 .NET 扩展方法最佳实践）        ArgumentNullException.ThrowIfNull(type);        // 内置浮点类型集合：float(double)、double、decimal（注意：decimal 是十进制浮点，也算浮点类型）        // 提取可空类型的底层类型（如 float? → float，非可空则返回原类型）        Type underlyingType = Nullable.GetUnderlyingType(type) ?? type;        return Type.GetTypeCode(underlyingType) switch        {            TypeCode.Single or            TypeCode.Double => true,            TypeCode.Decimal => !isBinaryFloat,            _ => false        };    }    /// <summary>    /// 判断类型是否为集合类型（包括 Array, IList, IList&lt;T&gt;）.    /// 同时支持判断实现这些接口的 Nullable&lt;struct&gt; 类型.    /// </summary>    /// <param name="type">要判断的类型.</param>    /// <returns>如果是数组或列表返回 true.</returns>    public static bool IsArray(this Type type)    {        ArgumentNullException.ThrowIfNull(type);        // 1. 尝试获取 Nullable<T> 的底层类型        // 虽然数组和 List<T> 都是引用类型（本身无法被 Nullable 包裹），        // 但为了兼容“实现了 IList 的 Struct”被 Nullable 包裹的极端情况，这里做一个解包处理.        Type checkType = Nullable.GetUnderlyingType(type) ?? type;        // 2. 判断是否为数组 (int[], string[] 等)        if (checkType.IsArray)        {            return true;        }        // 3. 判断是否实现了非泛型 IList 接口 (ArrayList, List<T>, Array 等都实现了这个)        // 注意：C# 的数组其实也隐式实现了 IList，但 IsArray 检查更快，所以上面先判了.        if (typeof(IList).IsAssignableFrom(checkType))        {            return true;        }        // 4. 判断是否为泛型 IList<> 接口本身 (例如传入的是 typeof(IList<int>))        if (checkType.IsGenericType && checkType.GetGenericTypeDefinition() == typeof(IList<>))        {            return true;        }        // 5. 判断是否实现了泛型 IList<> 接口 (例如自定义的 MyCollection : IList<int>)        // 有些轻量级集合可能只实现了 IList<T> 而没有实现 IList        foreach (var iface in checkType.GetInterfaces())        {            if (iface.IsGenericType && iface.GetGenericTypeDefinition() == typeof(IList<>))            {                return true;            }        }        return false;    }    /// <summary>    /// 从属性描述符中获取指定类型的特性（若存在则返回第一个匹配特性，否则返回 null）.    /// </summary>    /// <typeparam name="T">要获取的特性类型（必须继承自 <see cref="Attribute"/>），如 <see cref="DescriptionAttribute"/>、自定义特性等.</typeparam>    /// <param name="property">属性描述符实例（可为 null，null 时直接返回 null），通常通过 <see cref="TypeDescriptor"/> 获取.</param>    /// <returns>    /// 匹配类型的第一个特性实例（<typeparamref name="T"/> 类型）；    /// 若属性描述符为 null、无匹配类型特性，则返回 null.    /// </returns>    /// <remarks>    /// 1. 支持所有继承自 <see cref="Attribute"/> 的特性类型，包括框架内置特性和自定义特性；    /// 2. 若属性存在多个同类型特性（需特性类设置 <see cref="AttributeUsageAttribute.AllowMultiple"/> = true），仅返回第一个匹配特性；    /// 3. 空安全设计：当输入参数 <paramref name="property"/> 为 null 时，不会抛出空引用异常，直接返回 null.    /// </remarks>    public static T? GetAttribute<T>(this PropertyDescriptor property)        where T : Attribute    {        return property.Attributes.OfType<T>().FirstOrDefault();    }    /// <summary>    /// 获取对象的属性描述符集合.    /// </summary>    /// <param name="instance">要获取属性的对象实例.</param>    /// <param name="hideInheritedProperties">是否隐藏继承的属性 (即只显示当前类声明的属性).</param>    /// <returns>属性描述符列表 <see cref="List{PropertyDescriptor}"/>.</returns>    public static List<PropertyDescriptor> GetPropertyDescriptors(this object instance, bool hideInheritedProperties)    {        PropertyDescriptorCollection? descriptors = null;        // 1. 尝试获取实例的类型转换器 (TypeConverter)        TypeConverter tc = TypeDescriptor.GetConverter(instance);        // 如果没有转换器，或者转换器不支持获取属性 (例如 int, string 等简单类型通常不支持)        if (tc == null || !tc.GetPropertiesSupported())        {            // 2.1 检查是否实现了 ICustomTypeDescriptor 接口 (例如 DataRowView)            if (instance is ICustomTypeDescriptor customTypeDescriptor)            {                descriptors = customTypeDescriptor.GetProperties();            }            // 2.2 检查是否实现了 ICustomTypeProvider 接口 (通常用于 WCF RIA Services 或动态代理)            // 这里使用反射通过字符串名称查找接口，是为了避免对特定程序集的硬依赖            else if (instance.GetType().GetInterface("ICustomTypeProvider", true) != null)            {                var methodInfo = instance.GetType().GetMethod("GetCustomType");                // 调用 GetCustomType 方法获取真实的类型定义                var result = methodInfo?.Invoke(instance, null) as Type;                if (result != null)                {                    descriptors = TypeDescriptor.GetProperties(result);                }            }            else            {                // 2.3 默认情况：使用 TypeDescriptor 获取当前类型定义的标准属性                descriptors = TypeDescriptor.GetProperties(instance.GetType());            }        }        else        {            // 3. 如果 TypeConverter 支持获取属性，则使用它来获取            // (常用于 ExpandableObjectConverter 等场景)            try            {                descriptors = tc.GetProperties(instance);            }            catch (Exception)            {                // 忽略转换器内部可能抛出的异常，防止程序崩溃            }        }        // 4. 处理结果并进行过滤        if (descriptors != null)        {            var descriptorsProperties = descriptors.Cast<PropertyDescriptor>();            // 如果需要隐藏继承的属性            if (hideInheritedProperties)            {                // ComponentType 表示声明该属性的类型.                // 如果 ComponentType 等于 instance.GetType()，说明属性是在当前类中声明的，而不是基类.                var properties = from p in descriptorsProperties                                 where p.ComponentType == instance.GetType()                                 select p;                return properties.ToList();            }            return descriptorsProperties.ToList();        }        return new List<PropertyDescriptor>();    }    /// <summary>    /// 判定源类型是否可以分配给指定的目标类型（支持泛型定义及可空类型判定）.    /// </summary>    /// <param name="sourceType">需要判定的源类型.</param>    /// <param name="targetType">目标对比类型.</param>    /// <returns>如果源类型可以分配给目标类型，则返回 true；否则返回 false.</returns>    public static bool Is(this Type sourceType, Type targetType)    {        // 验证参数是否为空.        ArgumentNullException.ThrowIfNull(sourceType, nameof(sourceType));        ArgumentNullException.ThrowIfNull(targetType, nameof(targetType));        // 1. 检查源类型是否为泛型，且其泛型定义是否与目标类型一致.        if (sourceType.IsGenericType && targetType == sourceType.GetGenericTypeDefinition())        {            return true;        }        // 2. 遍历并检查源类型实现的所有接口.        foreach (Type implementedInterface in sourceType.GetInterfaces())        {            // 如果接口是泛型，检查其泛型定义是否匹配目标类型.            if (implementedInterface.IsGenericType)            {                if (targetType == implementedInterface.GetGenericTypeDefinition())                {                    return true;                }            }            // 检查接口类型是否直接等于目标类型.            if (targetType == implementedInterface)            {                return true;            }        }        // 3. 处理可空类型（Nullable）的判定逻辑.        Type? nullableUnderlyingType = Nullable.GetUnderlyingType(sourceType);        if (nullableUnderlyingType != null)        {            // 检查可空类型的内部基础类型是否可以分配给目标类型.            if (targetType.IsAssignableFrom(nullableUnderlyingType))            {                return true;            }        }        // 4. 使用标准的分配判定逻辑（涵盖了类继承及闭合泛型）.        if (targetType.IsAssignableFrom(sourceType))        {            return true;        }        return false;    }    /// <summary>    /// 判定源类型是否可以分配给指定的目标类型（支持泛型定义及可空类型判定）.    /// </summary>    /// <param name="sourceType">源类型.</param>    /// <param name="targetType">目标类型.</param>    /// <returns>如果源类型可以分配给目标类型，则返回 true；否则返回 false.</returns>    public static bool IsAssignableTo(this Type sourceType, Type targetType)    {        // 验证参数是否为空.        ArgumentNullException.ThrowIfNull(sourceType, nameof(sourceType));        ArgumentNullException.ThrowIfNull(targetType, nameof(targetType));        // 处理可空类型        Type effectiveSource = sourceType.GetUnderlyingTypeOrSelf();        Type effectiveTarget = targetType.GetUnderlyingTypeOrSelf();        if (effectiveTarget != targetType)        {            if (effectiveSource != sourceType)            {                return effectiveSource.IsAssignableTo(targetType);            }            else            {                return sourceType.IsAssignableTo(effectiveTarget);            }        }        else if (effectiveSource != sourceType)        {            return false;        }        // 如果目标类型是泛型类型定义，检查源类型是否满足泛型约束        if (targetType.IsGenericTypeDefinition && sourceType.IsGenericTypeDefinition)        {            // 只有当两者都是泛型定义时，才调用专门的定义比对逻辑.            return IsAssignableToGenericTypeDefinition(sourceType, targetType);        }        else if (sourceType.IsGenericTypeDefinition || targetType.IsGenericTypeDefinition)        {            // 如果源类型是泛型定义而目标不是，或者反之，通常在运行时认为不可直接分配.            return false;        }        else        {            // 对于非泛型类型定义的情况，使用标准的类型分配检查            return targetType.IsAssignableFrom(sourceType);        }    }    /// <summary>    /// 获取指定类型的基础类型；如果该类型不是 Nullable 结构体，则返回其自身.    /// </summary>    /// <param name="type">待检查的类型.</param>    /// <returns>如果是 Nullable 则返回其基础类型，否则返回自身.</returns>    public static Type GetUnderlyingTypeOrSelf(this Type type)    {        // Nullable<T> 类型        Type? underlyingType = null;        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))        {            underlyingType = Nullable.GetUnderlyingType(type);        }        // 如果获取成功则返回基础类型，否则返回传入的原始类型.        return underlyingType ?? type;    }    /// <summary>    /// 检查源类型是否可以分配给泛型类型定义.    /// </summary>    private static bool IsAssignableToGenericTypeDefinition(Type sourceType, Type genericTypeDefinition)    {        // 检查源类型是否直接是该泛型类型定义的实例        if (sourceType.IsGenericType && sourceType.GetGenericTypeDefinition() == genericTypeDefinition)        {            return true;        }        // 检查源类型的基类是否是该泛型类型定义的实例        var baseType = sourceType.BaseType;        while (baseType != null && baseType != typeof(object))        {            if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == genericTypeDefinition)            {                return true;            }            baseType = baseType.BaseType;        }        // 检查源类型实现的接口是否是该泛型类型定义的实例        foreach (var interfaceType in sourceType.GetInterfaces())        {            if (interfaceType.IsGenericType &&                interfaceType.GetGenericTypeDefinition() == genericTypeDefinition)            {                return true;            }        }        // 如果源类型本身是泛型类型定义，检查其是否可以被构造为目标泛型类型定义        if (sourceType.IsGenericTypeDefinition)        {            return CanConstructGenericType(sourceType, genericTypeDefinition);        }        return false;    }    /// <summary>    /// 检查泛型参数是否兼容（支持协变/逆变）.    /// </summary>    private static bool AreGenericArgumentsCompatible(Type sourceType, Type targetType)    {        Type sourceGenericDef = sourceType.GetGenericTypeDefinition();        Type targetGenericDef = targetType.GetGenericTypeDefinition();        if (sourceGenericDef != targetGenericDef)        {            return false;        }        Type[] sourceArgs = sourceType.GetGenericArguments();        Type[] targetArgs = targetType.GetGenericArguments();        if (sourceArgs.Length != targetArgs.Length)        {            return false;        }        var genericParameters = sourceGenericDef.GetGenericArguments();        for (int i = 0; i < sourceArgs.Length; i++)        {            if (!IsTypeArgumentCompatible(                sourceArgs[i],                targetArgs[i],                genericParameters[i].GenericParameterAttributes))            {                return false;            }        }        return true;    }    /// <summary>    /// 检查单个泛型参数是否兼容，考虑变体.    /// </summary>    private static bool IsTypeArgumentCompatible(        Type sourceArg,        Type targetArg,        GenericParameterAttributes attributes)    {        // 处理变体        GenericParameterAttributes variance =            attributes & GenericParameterAttributes.VarianceMask;        return variance switch        {            GenericParameterAttributes.Covariant =>                sourceArg.IsAssignableTo(targetArg),  // 协变：sourceArg <= targetArg            GenericParameterAttributes.Contravariant =>                targetArg.IsAssignableTo(sourceArg),  // 逆变：targetArg <= sourceArg            _ => sourceArg == targetArg // 不变：必须相等        };    }    /// <summary>    /// 检查一个泛型类型定义是否可以构造为另一个泛型类型定义.    /// </summary>    private static bool CanConstructGenericType(Type sourceGenericDefinition, Type targetGenericDefinition)    {        // 获取泛型参数数量        var sourceArgs = sourceGenericDefinition.GetGenericArguments();        var targetArgs = targetGenericDefinition.GetGenericArguments();        if (sourceArgs.Length != targetArgs.Length)        {            return false;        }        // 检查泛型参数约束是否兼容（简化版本）        // 实际实现可能需要更复杂的约束检查        for (int i = 0; i < sourceArgs.Length; i++)        {            var sourceParam = sourceArgs[i];            var targetParam = targetArgs[i];            // 检查泛型参数约束            if (!CheckGenericParameterConstraints(sourceParam, targetParam))            {                return false;            }        }        return true;    }    /// <summary>    /// 检查泛型参数约束是否兼容（简化实现）.    /// </summary>    private static bool CheckGenericParameterConstraints(Type sourceParam, Type targetParam)    {        // 这里简化处理，实际实现需要检查：        // 1. 类型约束（class, struct, new(), 具体类型）        // 2. 协变/逆变（in/out）        // 3. 多个约束的组合        // 暂时返回 true，需要根据实际需求完善        return true;    }}