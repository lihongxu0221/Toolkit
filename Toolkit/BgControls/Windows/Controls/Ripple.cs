using BgControls.Windows.Attach;namespace BgControls.Windows.Controls;/// <summary>/// 水波纹效果控件，用于在点击时产生向外扩散的动画视觉反馈./// </summary>[TemplateVisualState(GroupName = "CommonStates", Name = TemplateStateNormal)][TemplateVisualState(GroupName = "CommonStates", Name = TemplateStateMousePressed)][TemplateVisualState(GroupName = "CommonStates", Name = TemplateStateMouseOut)]public class Ripple : ContentControl{    private const string TemplateStateNormal = "Normal";    private const string TemplateStateMousePressed = "MousePressed";    private const string TemplateStateMouseOut = "MouseOut";    // 存储当前处于按下状态的波纹实例集合，不以下划线开头.    private static readonly HashSet<Ripple> PressedInstances = new HashSet<Ripple>();    /// <summary>    /// 标识 RippleSize 依赖属性.    /// </summary>    private static readonly DependencyPropertyKey RippleSizePropertyKey =        DependencyProperty.RegisterReadOnly("RippleSize", typeof(double), typeof(Ripple), new PropertyMetadata(0.0));    /// <summary>    /// 标识 RippleX 依赖属性.    /// </summary>    private static readonly DependencyPropertyKey RippleXPropertyKey =        DependencyProperty.RegisterReadOnly("RippleX", typeof(double), typeof(Ripple), new PropertyMetadata(0.0));    /// <summary>    /// 标识 RippleY 依赖属性.    /// </summary>    private static readonly DependencyPropertyKey RippleYPropertyKey =        DependencyProperty.RegisterReadOnly("RippleY", typeof(double), typeof(Ripple), new PropertyMetadata(0.0));    /// <summary>    /// 标识 Feedback 依赖属性.    /// </summary>    public static readonly DependencyProperty FeedbackProperty =        DependencyProperty.Register("Feedback", typeof(Brush), typeof(Ripple), new PropertyMetadata(null));    /// <summary>    /// 标识 RippleSize 依赖属性.    /// </summary>    public static readonly DependencyProperty RippleSizeProperty = RippleSizePropertyKey.DependencyProperty;    /// <summary>    /// 标识 RippleX 依赖属性.    /// </summary>    public static readonly DependencyProperty RippleXProperty = RippleXPropertyKey.DependencyProperty;    /// <summary>    /// 标识 RippleY 依赖属性.    /// </summary>    public static readonly DependencyProperty RippleYProperty = RippleYPropertyKey.DependencyProperty;    /// <summary>    /// 标识 RecognizesAccessKey 依赖属性.    /// </summary>    public static readonly DependencyProperty RecognizesAccessKeyProperty =        DependencyProperty.Register("RecognizesAccessKey", typeof(bool), typeof(Ripple), new PropertyMetadata(false));    /// <summary>    /// Initializes static members of the <see cref="Ripple"/> class.    /// </summary>    static Ripple()    {        // 覆盖默认样式元数据.        DefaultStyleKeyProperty.OverrideMetadata(typeof(Ripple), new FrameworkPropertyMetadata(typeof(Ripple)));        // 注册全局类处理器以监听鼠标弹起和移动事件.        EventManager.RegisterClassHandler(typeof(ContentControl), Mouse.PreviewMouseUpEvent, new MouseButtonEventHandler(MouseButtonEventHandler), handledEventsToo: true);        EventManager.RegisterClassHandler(typeof(ContentControl), Mouse.MouseMoveEvent, new MouseEventHandler(MouseMoveEventHandler), handledEventsToo: true);        EventManager.RegisterClassHandler(typeof(Popup), Mouse.PreviewMouseUpEvent, new MouseButtonEventHandler(MouseButtonEventHandler), handledEventsToo: true);        EventManager.RegisterClassHandler(typeof(Popup), Mouse.MouseMoveEvent, new MouseEventHandler(MouseMoveEventHandler), handledEventsToo: true);    }    /// <summary>    /// Initializes a new instance of the <see cref="Ripple"/> class.    /// </summary>    public Ripple()    {        // 订阅大小改变事件.        WeakEventManager<Ripple, SizeChangedEventArgs>.AddHandler(this, nameof(this.SizeChanged), this.OnSizeChanged);    }    /// <summary>    /// Gets or sets 波纹反馈颜色的画刷.    /// </summary>    public Brush? Feedback    {        get { return (Brush)this.GetValue(FeedbackProperty); }        set { this.SetValue(FeedbackProperty, value); }    }    /// <summary>    /// Gets 波纹的大小.    /// </summary>    public double RippleSize    {        get { return (double)this.GetValue(RippleSizeProperty); }        private set { this.SetValue(RippleSizePropertyKey, value); }    }    /// <summary>    /// Gets 波纹在水平方向上的偏移量.    /// </summary>    public double RippleX    {        get { return (double)this.GetValue(RippleXProperty); }        private set { this.SetValue(RippleXPropertyKey, value); }    }    /// <summary>    /// Gets 波纹在垂直方向上的偏移量.    /// </summary>    public double RippleY    {        get { return (double)this.GetValue(RippleYProperty); }        private set { this.SetValue(RippleYPropertyKey, value); }    }    /// <summary>    /// Gets or sets a value indicating whether 控件是否识别访问键.    /// </summary>    public bool RecognizesAccessKey    {        get { return (bool)this.GetValue(RecognizesAccessKeyProperty); }        set { this.SetValue(RecognizesAccessKeyProperty, value); }    }    /// <summary>    /// 应用模板逻辑，初始化默认视觉状态.    /// </summary>    public override void OnApplyTemplate()    {        base.OnApplyTemplate();        // 初始设置为正常状态.        VisualStateManager.GoToState(this, TemplateStateNormal, useTransitions: false);    }    /// <summary>    /// 处理鼠标左键按下预览事件，初始化波纹位置.    /// </summary>    /// <param name="e">鼠标按钮事件参数.</param>    protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e)    {        // 规则 8: 校验事件参数.        ArgumentNullException.ThrowIfNull(e, nameof(e));        // 判断是否开启了居中波纹效果.        if (RippleAssist.GetIsCentered(this))        {            if (this.Content is FrameworkElement contentElement)            {                // 计算内容元素相对于当前控件的坐标转换.                Point contentPos = contentElement.TransformToAncestor(this).Transform(new Point(0.0, 0.0));                if (this.FlowDirection == FlowDirection.RightToLeft)                {                    this.RippleX = contentPos.X - (contentElement.ActualWidth / 2.0) - (this.RippleSize / 2.0);                }                else                {                    this.RippleX = contentPos.X + (contentElement.ActualWidth / 2.0) - (this.RippleSize / 2.0);                }                this.RippleY = contentPos.Y + (contentElement.ActualHeight / 2.0) - (this.RippleSize / 2.0);            }            else            {                // 无内容元素时默认居中于控件本身.                this.RippleX = (this.ActualWidth / 2.0) - (this.RippleSize / 2.0);                this.RippleY = (this.ActualHeight / 2.0) - (this.RippleSize / 2.0);            }        }        else        {            // 非居中模式下，波纹始于鼠标点击点.            Point clickPoint = e.GetPosition(this);            this.RippleX = clickPoint.X - (this.RippleSize / 2.0);            this.RippleY = clickPoint.Y - (this.RippleSize / 2.0);        }        // 如果未禁用波纹，则执行按下动画并将实例记录到集合.        if (!RippleAssist.GetIsDisabled(this))        {            VisualStateManager.GoToState(this, TemplateStateNormal, useTransitions: false);            VisualStateManager.GoToState(this, TemplateStateMousePressed, useTransitions: true);            PressedInstances.Add(this);        }        base.OnPreviewMouseLeftButtonDown(e);    }    /// <summary>    /// 控件大小改变时的回调，用于重新计算波纹尺寸.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">大小改变事件参数.</param>    private void OnSizeChanged(object? sender, SizeChangedEventArgs e)    {        // 规则 8: 校验事件参数.        ArgumentNullException.ThrowIfNull(e, nameof(e));        FrameworkElement? contentElement = this.Content as FrameworkElement;        double targetWidth;        double targetHeight;        // 根据模式决定计算波纹半径的参考宽度和高度.        if (RippleAssist.GetIsCentered(this) && contentElement != null)        {            targetWidth = contentElement.ActualWidth;            targetHeight = contentElement.ActualHeight;        }        else        {            targetWidth = e.NewSize.Width;            targetHeight = e.NewSize.Height;        }        // 使用勾股定理计算对角线长度作为基础半径，并应用倍数.        double diagonalLength = Math.Sqrt(Math.Pow(targetWidth, 2.0) + Math.Pow(targetHeight, 2.0));        this.RippleSize = 2.0 * diagonalLength * RippleAssist.GetRippleSizeMultiplier(this);    }    /// <summary>    /// 全局鼠标弹起事件处理器，用于恢复波纹状态.    /// </summary>    /// <param name="sender">事件发送者.</param>    /// <param name="e">鼠标事件参数.</param>    private static void MouseButtonEventHandler(object sender, MouseButtonEventArgs e)    {        // 遍历所有当前被按下的波纹实例.        foreach (Ripple ripple in PressedInstances)        {            // 如果模板中存在缩放转换，动态调整动画时间.            if (ripple.Template.FindName("ScaleTransform", ripple) is ScaleTransform { ScaleX: var currentScale })            {                TimeSpan dynamicDuration = TimeSpan.FromMilliseconds(300.0 * (1.0 - currentScale));                // 更新缩放动画的关键帧时间.                if (ripple.Template.FindName("MousePressedToNormalScaleXKeyFrame", ripple) is EasingDoubleKeyFrame scaleXKey)                {                    scaleXKey.KeyTime = KeyTime.FromTimeSpan(dynamicDuration);                }                if (ripple.Template.FindName("MousePressedToNormalScaleYKeyFrame", ripple) is EasingDoubleKeyFrame scaleYKey)                {                    scaleYKey.KeyTime = KeyTime.FromTimeSpan(dynamicDuration);                }            }            // 将控件切换回正常视觉状态.            VisualStateManager.GoToState(ripple, TemplateStateNormal, useTransitions: true);        }        // 清空按下实例集合.        PressedInstances.Clear();    }    /// <summary>    /// 全局鼠标移动事件处理器，用于检测鼠标是否移出波纹区域.    /// </summary>    /// <param name="sender">事件发送者.</param>    /// <param name="e">鼠标事件参数.</param>    private static void MouseMoveEventHandler(object sender, MouseEventArgs e)    {        // 遍历快照副本以允许在迭代中移除元素.        foreach (Ripple ripple in PressedInstances.ToList())        {            Point relativePos = Mouse.GetPosition(ripple);            // 检查鼠标坐标是否超出控件边界.            if (relativePos.X < 0.0 || relativePos.Y < 0.0 || relativePos.X >= ripple.ActualWidth || relativePos.Y >= ripple.ActualHeight)            {                // 触发移出状态动画并从集合中移除.                VisualStateManager.GoToState(ripple, TemplateStateMouseOut, useTransitions: true);                PressedInstances.Remove(ripple);            }        }    }}