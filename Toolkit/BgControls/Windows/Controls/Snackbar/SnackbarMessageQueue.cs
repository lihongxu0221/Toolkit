namespace BgControls.Windows.Controls;/// <summary>/// 消息条消息队列类，用于管理消息的排队、显示持续时间及重复项处理./// </summary>public class SnackbarMessageQueue : ISnackbarMessageQueue, IDisposable{    /// <summary>    /// 内部类：用于管理当鼠标不在元素上方时的等待句柄.    /// </summary>    private class MouseNotOverManagedWaitHandle : IDisposable    {        private readonly UIElement uiElement;        private readonly ManualResetEvent waitHandle;        private readonly ManualResetEvent disposedWaitHandle = new ManualResetEvent(initialState: false);        private readonly object waitHandleGate = new object();        private bool isDisposed;        /// <summary>        /// Initializes a new instance of the <see cref="MouseNotOverManagedWaitHandle"/> class.        /// </summary>        /// <param name="uiElement">关联的 UI 元素.</param>        public MouseNotOverManagedWaitHandle(UIElement uiElement)        {            // 检查元素是否为空.            ArgumentNullException.ThrowIfNull(uiElement, nameof(uiElement));            this.uiElement = uiElement;            // 初始化等待句柄状态：如果鼠标不在上方则为有信号状态.            this.waitHandle = new ManualResetEvent(!uiElement.IsMouseOver);            WeakEventManager<UIElement, MouseEventArgs>.AddHandler(this.uiElement, nameof(this.uiElement.MouseEnter), this.UiElementOnMouseEnter);            WeakEventManager<UIElement, MouseEventArgs>.AddHandler(this.uiElement, nameof(this.uiElement.MouseLeave), this.UiElementOnMouseLeave);        }        /// <summary>        /// Gets 事件等待句柄.        /// </summary>        public EventWaitHandle WaitHandle => this.waitHandle;        /// <summary>        /// 鼠标进入时的处理逻辑.        /// </summary>        /// <param name="sender">事件源.</param>        /// <param name="mouseEventArgs">鼠标事件参数.</param>        private void UiElementOnMouseEnter(object? sender, MouseEventArgs mouseEventArgs)        {            // 重置句柄，表示鼠标在上方，需要暂停计时.            this.waitHandle.Reset();        }        /// <summary>        /// 鼠标离开时的处理逻辑.        /// </summary>        /// <param name="sender">事件源.</param>        /// <param name="mouseEventArgs">鼠标事件参数.</param>        private async void UiElementOnMouseLeave(object? sender, MouseEventArgs mouseEventArgs)        {            // 异步等待一段时间以确保鼠标确实离开了元素.            await Task.Run(() =>            {                try                {                    this.disposedWaitHandle.WaitOne(TimeSpan.FromSeconds(2.0));                }                catch (ObjectDisposedException)                {                    // 忽略对象已释放的异常.                }            });            // 如果鼠标仍在上方则直接返回.            if (((UIElement)sender!).IsMouseOver)            {                return;            }            lock (this.waitHandleGate)            {                if (!this.isDisposed)                {                    // 设置句柄，允许继续计时.                    this.waitHandle.Set();                }            }        }        /// <summary>        /// 释放资源.        /// </summary>        public void Dispose()        {            if (!this.isDisposed)            {                WeakEventManager<UIElement, MouseEventArgs>.RemoveHandler(this.uiElement, nameof(this.uiElement.MouseEnter), this.UiElementOnMouseEnter);                WeakEventManager<UIElement, MouseEventArgs>.RemoveHandler(this.uiElement, nameof(this.uiElement.MouseLeave), this.UiElementOnMouseLeave);                lock (this.waitHandleGate)                {                    this.waitHandle.Dispose();                    this.isDisposed = true;                }                this.disposedWaitHandle.Set();                this.disposedWaitHandle.Dispose();            }        }    }    private readonly Dispatcher dispatcher;    private readonly TimeSpan messageDuration;    private readonly HashSet<Snackbar> pairedSnackbars = new HashSet<Snackbar>();    private readonly LinkedList<SnackbarMessageQueueItem> snackbarMessages = new LinkedList<SnackbarMessageQueueItem>();    private readonly object snackbarMessagesLock = new object();    private readonly ManualResetEvent disposedEvent = new ManualResetEvent(initialState: false);    private readonly ManualResetEvent pausedEvent = new ManualResetEvent(initialState: false);    private readonly SemaphoreSlim showMessageSemaphore = new SemaphoreSlim(1, 1);    private int pauseCounter;    private bool isDisposed;    private ManualResetEvent? closeSnackbarEvent;    /// <summary>    /// Initializes a new instance of the <see cref="SnackbarMessageQueue"/> class.    /// </summary>    public SnackbarMessageQueue()        : this(TimeSpan.FromSeconds(3.0))    {    }    /// <summary>    /// Initializes a new instance of the <see cref="SnackbarMessageQueue"/> class.    /// </summary>    /// <param name="messageDuration">消息显示持续时间.</param>    public SnackbarMessageQueue(TimeSpan messageDuration)        : this(messageDuration, Dispatcher.FromThread(Thread.CurrentThread) ?? throw new InvalidOperationException("SnackbarMessageQueue must be created in a dispatcher thread."))    {    }    /// <summary>    /// Initializes a new instance of the <see cref="SnackbarMessageQueue"/> class.    /// </summary>    /// <param name="messageDuration">消息显示持续时间.</param>    /// <param name="dispatcher">关联的调度器.</param>    public SnackbarMessageQueue(TimeSpan messageDuration, Dispatcher dispatcher)    {        ArgumentNullException.ThrowIfNull(dispatcher, nameof(dispatcher));        this.messageDuration = messageDuration;        this.dispatcher = dispatcher;    }    /// <summary>    /// Gets 当前排队中的消息列表快照.    /// </summary>    public IReadOnlyList<SnackbarMessageQueueItem> QueuedMessages    {        get        {            lock (this.snackbarMessagesLock)            {                return this.snackbarMessages.ToList();            }        }    }    /// <summary>    /// Gets 关联的调度器.    /// </summary>    internal Dispatcher Dispatcher => this.dispatcher;    /// <summary>    /// Gets or sets a value indicating whether 是否丢弃重复的消息.    /// </summary>    public bool DiscardDuplicates { get; set; }    /// <summary>    /// 将消息条实例与队列配对.    /// </summary>    /// <param name="snackbar">要配对的消息条.</param>    /// <returns>用于取消配对的操作委托.</returns>    internal Action Pair(Snackbar snackbar)    {        ArgumentNullException.ThrowIfNull(snackbar, nameof(snackbar));        this.pairedSnackbars.Add(snackbar);        return new Action(() =>        {            this.pairedSnackbars.Remove(snackbar);        });    }    /// <summary>    /// 暂停消息显示.    /// </summary>    /// <returns>用于恢复显示的清理操作委托.</returns>    internal Action Pause()    {        if (this.isDisposed)        {            return new Action(() => { });        }        if (Interlocked.Increment(ref this.pauseCounter) == 1)        {            this.pausedEvent.Set();        }        return new Action(() =>        {            if (Interlocked.Decrement(ref this.pauseCounter) == 0)            {                this.pausedEvent.Reset();            }        });    }    /// <summary>    /// 将消息内容加入队列.    /// </summary>    /// <param name="content">消息内容.</param>    public void Enqueue(object content)    {        this.Enqueue(content, neverConsiderToBeDuplicate: false);    }    /// <summary>    /// 将消息内容加入队列.    /// </summary>    /// <param name="content">消息内容.</param>    /// <param name="neverConsiderToBeDuplicate">是否永不视为重复项.</param>    public void Enqueue(object content, bool neverConsiderToBeDuplicate)    {        this.Enqueue(content, null, null, null, promote: false, neverConsiderToBeDuplicate);    }    /// <summary>    /// 将包含操作的消息加入队列.    /// </summary>    /// <param name="content">消息内容.</param>    /// <param name="actionContent">操作内容.</param>    /// <param name="actionHandler">操作处理程序.</param>    public void Enqueue(object content, object? actionContent, Action? actionHandler)    {        this.Enqueue(content, actionContent, actionHandler, promote: false);    }    /// <summary>    /// 将包含操作的消息加入队列，并指定是否提升优先级.    /// </summary>    /// <param name="content">消息内容.</param>    /// <param name="actionContent">操作内容.</param>    /// <param name="actionHandler">操作处理程序.</param>    /// <param name="promote">是否提升至队列前端.</param>    public void Enqueue(object content, object? actionContent, Action? actionHandler, bool promote)    {        this.Enqueue(            content,            actionContent,            (object? actionArgument) => { actionHandler?.Invoke(); },            actionArgument: false,            promote,            neverConsiderToBeDuplicate: false);    }    /// <summary>    /// 将带有泛型参数的操作消息加入队列.    /// </summary>    /// <typeparam name="TArgument">参数类型.</typeparam>    /// <param name="content">消息内容.</param>    /// <param name="actionContent">操作内容.</param>    /// <param name="actionHandler">泛型操作处理程序.</param>    /// <param name="actionArgument">操作参数.</param>    public void Enqueue<TArgument>(object content, object? actionContent, Action<TArgument?>? actionHandler, TArgument? actionArgument)    {        this.Enqueue(content, actionContent, actionHandler, actionArgument, promote: false, neverConsiderToBeDuplicate: false);    }    /// <summary>    /// 将带有泛型参数的操作消息加入队列并指定是否提升.    /// </summary>    /// <typeparam name="TArgument">参数类型.</typeparam>    /// <param name="content">消息内容.</param>    /// <param name="actionContent">操作内容.</param>    /// <param name="actionHandler">泛型操作处理程序.</param>    /// <param name="actionArgument">操作参数.</param>    /// <param name="promote">是否提升至队列前端.</param>    public void Enqueue<TArgument>(object content, object? actionContent, Action<TArgument?>? actionHandler, TArgument? actionArgument, bool promote)    {        this.Enqueue(content, actionContent, actionHandler, actionArgument, promote, neverConsiderToBeDuplicate: false);    }    /// <summary>    /// 将带有完整参数的消息加入队列.    /// </summary>    /// <typeparam name="TArgument">参数类型.</typeparam>    /// <param name="content">消息内容.</param>    /// <param name="actionContent">操作内容.</param>    /// <param name="actionHandler">泛型操作处理程序.</param>    /// <param name="actionArgument">操作参数.</param>    /// <param name="promote">是否提升至队列前端.</param>    /// <param name="neverConsiderToBeDuplicate">如果设为 <c>true</c>，该消息将永不被视为重复项.</param>    /// <param name="durationOverride">消息显示的覆盖时长.</param>    public void Enqueue<TArgument>(object content, object? actionContent, Action<TArgument?>? actionHandler, TArgument? actionArgument, bool promote, bool neverConsiderToBeDuplicate, TimeSpan? durationOverride = null)    {        ArgumentNullException.ThrowIfNull(content, nameof(content));        if ((actionContent == null) ^ (actionHandler == null))        {            throw new ArgumentNullException(                actionContent != null ? nameof(actionContent) : nameof(actionHandler),                "如果提供了操作内容或处理程序，则必须同时提供两者.");        }        Action<object?> handler = argument => actionHandler?.Invoke((TArgument?)argument);        this.Enqueue(content, actionContent, handler, actionArgument, promote, neverConsiderToBeDuplicate, durationOverride);    }    /// <summary>    /// 执行消息入队的最终逻辑.    /// </summary>    /// <param name="content">消息内容.</param>    /// <param name="actionContent">操作内容.</param>    /// <param name="actionHandler">泛型操作处理程序.</param>    /// <param name="actionArgument">操作参数.</param>    /// <param name="promote">是否弹窗.</param>    /// <param name="neverConsiderToBeDuplicate">如果设为 <c>true</c>，该消息将永不被视为重复项.</param>    /// <param name="durationOverride">消息显示的覆盖时长.</param>    public void Enqueue(object content, object? actionContent, Action<object?>? actionHandler, object? actionArgument, bool promote, bool neverConsiderToBeDuplicate, TimeSpan? durationOverride = null)    {        ArgumentNullException.ThrowIfNull(content, nameof(content));        if ((actionContent == null) ^ (actionHandler == null))        {            throw new ArgumentNullException(actionContent != null ? nameof(actionContent) : nameof(actionHandler), "操作参数必须成对提供.");        }        var queueItem = new SnackbarMessageQueueItem(            content,            durationOverride ?? this.messageDuration,            actionContent,            actionHandler,            actionArgument,            promote,            neverConsiderToBeDuplicate);        this.InsertItem(queueItem);    }    /// <summary>    /// 将消息项插入双向链表并调度显示.    /// </summary>    private void InsertItem(SnackbarMessageQueueItem item)    {        lock (this.snackbarMessagesLock)        {            bool isAdded = false;            for (var currentNode = this.snackbarMessages.First; currentNode != null; currentNode = currentNode.Next)            {                if (this.DiscardDuplicates && item.IsDuplicate(currentNode.Value))                {                    return;                }                if (item.IsPromoted && !currentNode.Value.IsPromoted)                {                    this.snackbarMessages.AddBefore(currentNode, item);                    isAdded = true;                    break;                }            }            if (!isAdded)            {                this.snackbarMessages.AddLast(item);            }        }        this.dispatcher.InvokeAsync((Func<Task>)this.ShowNextAsync);    }    /// <summary>    /// 清空消息队列并关闭当前显示的消息条.    /// </summary>    public void Clear()    {        lock (this.snackbarMessagesLock)        {            this.snackbarMessages.Clear();            this.closeSnackbarEvent?.Set();        }    }    /// <summary>    /// 开始计算消息显示的持续时间.    /// </summary>    private void StartDuration(TimeSpan minimumDuration, EventWaitHandle durationPassedWaitHandle)    {        ArgumentNullException.ThrowIfNull(durationPassedWaitHandle, nameof(durationPassedWaitHandle));        DateTime completionTime = DateTime.Now.Add(minimumDuration);        TimeSpan granularity = TimeSpan.FromMilliseconds(200.0);        Task.Run(() =>        {            while (true)            {                if (DateTime.Now >= completionTime)                {                    durationPassedWaitHandle.Set();                    break;                }                if (this.disposedEvent.WaitOne(granularity) || durationPassedWaitHandle.WaitOne(TimeSpan.Zero))                {                    break;                }                if (this.pausedEvent.WaitOne(TimeSpan.Zero))                {                    completionTime = completionTime.Add(granularity);                }            }        });    }    /// <summary>    /// 异步展示下一条消息.    /// </summary>    private async Task ShowNextAsync()    {        await this.showMessageSemaphore.WaitAsync().ConfigureAwait(true);        try        {            Snackbar? targetSnackbar;            while (true)            {                if (this.isDisposed || this.dispatcher.HasShutdownStarted)                {                    return;                }                targetSnackbar = this.FindSnackbar();                if (targetSnackbar != null)                {                    break;                }                Trace.TraceWarning("消息正在等待，但没有可用的消息条实例.");                await Task.Delay(TimeSpan.FromSeconds(1.0)).ConfigureAwait(true);            }            LinkedListNode<SnackbarMessageQueueItem>? firstMessageNode;            lock (this.snackbarMessagesLock)            {                firstMessageNode = this.snackbarMessages.First;                if (firstMessageNode == null)                {                    return;                }                this.closeSnackbarEvent = new ManualResetEvent(initialState: false);            }            await this.ShowAsync(targetSnackbar, firstMessageNode.Value, this.closeSnackbarEvent).ConfigureAwait(false);            lock (this.snackbarMessagesLock)            {                if (firstMessageNode.List == this.snackbarMessages)                {                    this.snackbarMessages.Remove(firstMessageNode);                }                this.closeSnackbarEvent.Dispose();                this.closeSnackbarEvent = null;            }        }        finally        {            this.showMessageSemaphore.Release();        }    }    /// <summary>    /// 查找当前可用的消息条实例.    /// </summary>    private Snackbar? FindSnackbar()    {        return this.pairedSnackbars.FirstOrDefault(sb =>        {            if (!sb.IsLoaded || sb.Visibility != Visibility.Visible)            {                return false;            }            var ownerWindow = Window.GetWindow(sb);            return ownerWindow == null || ownerWindow.WindowState != WindowState.Minimized;        });    }    /// <summary>    /// 异步执行单条消息的展示逻辑.    /// </summary>    private async Task ShowAsync(Snackbar snackbar, SnackbarMessageQueueItem messageQueueItem, ManualResetEvent actionClickWaitHandle)    {        var resultTuple = CreateAndShowMessage(snackbar, messageQueueItem, actionClickWaitHandle);        SnackbarMessage snackbarMessage = resultTuple.Item1;        MouseNotOverManagedWaitHandle mouseWaitHandle = resultTuple.Item2;        using (var durationWaitHandle = new ManualResetEvent(initialState: false))        {            this.StartDuration(messageQueueItem.Duration.Add(snackbar.ActivateStoryboardDuration), durationWaitHandle);            await WaitForCompletionAsync(mouseWaitHandle, durationWaitHandle, actionClickWaitHandle);            snackbar.SetCurrentValue(Snackbar.IsActiveProperty, false);            await Task.Delay(snackbar.DeactivateStoryboardDuration);            snackbarMessage.Resources = SnackbarMessage.DefaultResources;            snackbar.SetCurrentValue(Snackbar.MessageProperty, null);            mouseWaitHandle.Dispose();        }    }    /// <summary>    /// 创建并显示消息 UI.    /// </summary>    private static Tuple<SnackbarMessage, MouseNotOverManagedWaitHandle> CreateAndShowMessage(Snackbar snackbar, SnackbarMessageQueueItem messageQueueItem, EventWaitHandle actionClickWaitHandle)    {        int clickExecutionCount = 0;        var messageControl = new SnackbarMessage        {            Content = messageQueueItem.Content,            ActionContent = messageQueueItem.ActionContent,        };        messageControl.ActionClick += (sender, e) =>        {            if (++clickExecutionCount == 1)            {                DoActionCallback(messageQueueItem);            }            if (!actionClickWaitHandle.SafeWaitHandle.IsInvalid && !actionClickWaitHandle.SafeWaitHandle.IsClosed)            {                actionClickWaitHandle.Set();            }        };        snackbar.SetCurrentValue(Snackbar.MessageProperty, messageControl);        snackbar.SetCurrentValue(Snackbar.IsActiveProperty, true);        return Tuple.Create(messageControl, new MouseNotOverManagedWaitHandle(snackbar));    }    /// <summary>    /// 等待消息显示完成或用户操作点击.    /// </summary>    private static async Task WaitForCompletionAsync(MouseNotOverManagedWaitHandle mouseWaitHandle, EventWaitHandle durationWaitHandle, EventWaitHandle actionWaitHandle)    {        Task durationCompletionTask = Task.Run(() =>        {            WaitHandle.WaitAll(new[] { mouseWaitHandle.WaitHandle, durationWaitHandle });        });        Task<bool> actionTriggerTask = Task.Run(actionWaitHandle.WaitOne);        await Task.WhenAny(durationCompletionTask, actionTriggerTask);        mouseWaitHandle.WaitHandle.Set();        durationWaitHandle.Set();        actionWaitHandle.Set();        await Task.WhenAll(durationCompletionTask, actionTriggerTask);    }    /// <summary>    /// 执行消息关联的回调操作.    /// </summary>    private static void DoActionCallback(SnackbarMessageQueueItem messageQueueItem)    {        try        {            messageQueueItem.ActionHandler?.Invoke(messageQueueItem.ActionArgument);        }        catch (Exception ex)        {            Trace.WriteLine("Snackbar 消息回调执行错误: " + ex.Message);            throw;        }    }    /// <summary>    /// 释放队列占用的资源.    /// </summary>    public void Dispose()    {        if (!this.isDisposed)        {            this.isDisposed = true;            this.disposedEvent.Set();            this.disposedEvent.Dispose();            this.pausedEvent.Dispose();            this.showMessageSemaphore.Dispose();        }        GC.SuppressFinalize(this);    }}