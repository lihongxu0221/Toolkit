namespace BgControls.Windows.Controls;/// <summary>/// 实现一个受 Material Design 规范启发的消息条（Snackbar）控件./// </summary>[ContentProperty("Message")]public class Snackbar : Control{    // 动画资源名称常量.    private const string ActivateStoryboardName = "ActivateStoryboard";    private const string DeactivateStoryboardName = "DeactivateStoryboard";    /// <summary>    /// 标识 Message 依赖属性.    /// </summary>    public static readonly DependencyProperty MessageProperty =        DependencyProperty.Register("Message", typeof(SnackbarMessage), typeof(Snackbar), new PropertyMetadata(null));    /// <summary>    /// 标识 MessageQueue 依赖属性.    /// </summary>    public static readonly DependencyProperty MessageQueueProperty =        DependencyProperty.Register("MessageQueue", typeof(SnackbarMessageQueue), typeof(Snackbar), new PropertyMetadata(null, MessageQueuePropertyChangedCallback), MessageQueueValidateValueCallback);    /// <summary>    /// 标识 IsActive 依赖属性.    /// </summary>    public static readonly DependencyProperty IsActiveProperty =        DependencyProperty.Register("IsActive", typeof(bool), typeof(Snackbar), new PropertyMetadata(false, IsActivePropertyChangedCallback));    /// <summary>    /// 标识 ActionButtonStyle 依赖属性.    /// </summary>    public static readonly DependencyProperty ActionButtonStyleProperty =        DependencyProperty.Register("ActionButtonStyle", typeof(Style), typeof(Snackbar), new PropertyMetadata(null));    /// <summary>    /// 标识 ActionButtonPlacement 依赖属性.    /// </summary>    public static readonly DependencyProperty ActionButtonPlacementProperty =        DependencyProperty.Register("ActionButtonPlacement", typeof(SnackbarActionButtonPlacementMode), typeof(Snackbar), new PropertyMetadata(SnackbarActionButtonPlacementMode.Auto));    /// <summary>    /// 标识 IsActive 属性更改的路由事件.    /// </summary>    public static readonly RoutedEvent IsActiveChangedEvent =        EventManager.RegisterRoutedEvent("IsActiveChanged", RoutingStrategy.Bubble, typeof(RoutedPropertyChangedEventHandler<bool>), typeof(Snackbar));    /// <summary>    /// 标识停用动画完成时的路由事件.    /// </summary>    public static readonly RoutedEvent DeactivateStoryboardCompletedEvent =        EventManager.RegisterRoutedEvent("DeactivateStoryboardCompleted", RoutingStrategy.Bubble, typeof(SnackbarMessageEventArgs), typeof(Snackbar));    /// <summary>    /// Initializes static members of the <see cref="Snackbar"/> class.    /// </summary>    static Snackbar()    {        // 覆盖默认样式键元数据.        DefaultStyleKeyProperty.OverrideMetadata(            typeof(Snackbar),            new FrameworkPropertyMetadata(typeof(Snackbar)));    }    /// <summary>    /// Initializes a new instance of the <see cref="Snackbar"/> class.    /// </summary>    public Snackbar()    {        // 构造函数初始化逻辑.    }    // 消息队列注册清理委托字段，不以下划线开头.    private Action? messageQueueRegistrationCleanUp;    /// <summary>    /// Gets or sets 消息内容.    /// </summary>    public SnackbarMessage? Message    {        get { return (SnackbarMessage)this.GetValue(MessageProperty); }        set { this.SetValue(MessageProperty, value); }    }    /// <summary>    /// Gets or sets 消息队列.    /// </summary>    public SnackbarMessageQueue? MessageQueue    {        get { return (SnackbarMessageQueue)this.GetValue(MessageQueueProperty); }        set { this.SetValue(MessageQueueProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether 消息条是否处于激活状态.    /// </summary>    public bool IsActive    {        get { return (bool)this.GetValue(IsActiveProperty); }        set { this.SetValue(IsActiveProperty, value); }    }    /// <summary>    /// Gets or sets 操作按钮样式.    /// </summary>    public Style? ActionButtonStyle    {        get { return (Style)this.GetValue(ActionButtonStyleProperty); }        set { this.SetValue(ActionButtonStyleProperty, value); }    }    /// <summary>    /// Gets or sets 操作按钮布局方式.    /// </summary>    public SnackbarActionButtonPlacementMode ActionButtonPlacement    {        get { return (SnackbarActionButtonPlacementMode)this.GetValue(ActionButtonPlacementProperty); }        set { this.SetValue(ActionButtonPlacementProperty, value); }    }    /// <summary>    /// 激活状态改变时触发的事件.    /// </summary>    public event RoutedPropertyChangedEventHandler<bool> IsActiveChanged    {        add { this.AddHandler(IsActiveChangedEvent, value); }        remove { this.RemoveHandler(IsActiveChangedEvent, value); }    }    /// <summary>    /// 停用动画完成时触发的事件.    /// </summary>    public event RoutedPropertyChangedEventHandler<SnackbarMessage> DeactivateStoryboardCompleted    {        add { this.AddHandler(DeactivateStoryboardCompletedEvent, value); }        remove { this.RemoveHandler(DeactivateStoryboardCompletedEvent, value); }    }    /// <summary>    /// Gets 激活动画的持续时间.    /// </summary>    public TimeSpan ActivateStoryboardDuration { get; private set; }    /// <summary>    /// Gets 停用动画的持续时间.    /// </summary>    public TimeSpan DeactivateStoryboardDuration { get; private set; }    /// <summary>    /// 在应用模板时执行，用于获取动画持续时间.    /// </summary>    public override void OnApplyTemplate()    {        // 获取激活和停用动画的时长.        this.ActivateStoryboardDuration = this.GetStoryboardResourceDuration(ActivateStoryboardName);        this.DeactivateStoryboardDuration = this.GetStoryboardResourceDuration(DeactivateStoryboardName);        // 调用基类方法.        base.OnApplyTemplate();    }    /// <summary>    /// 获取指定名称的故事板资源时长.    /// </summary>    /// <param name="resourceName">资源名称.</param>    /// <returns>返回动画时长，如果未找到则返回零.</returns>    private TimeSpan GetStoryboardResourceDuration(string resourceName)    {        // 检查模板资源中是否包含该名称.        if (this.Template.Resources.Contains(resourceName))        {            // 尝试将其转换为 Storyboard 对象.            Storyboard? targetStoryboard = this.Template.Resources[resourceName] as Storyboard;            if (targetStoryboard != null && targetStoryboard.Duration.HasTimeSpan)            {                // 返回故事板定义的时长.                return targetStoryboard.Duration.TimeSpan;            }        }        // 默认返回零时长.        return TimeSpan.Zero;    }    /// <summary>    /// 消息队列属性更改的回调函数.    /// </summary>    /// <param name="dobj">目标对象.</param>    /// <param name="args">属性更改参数.</param>    private static void MessageQueuePropertyChangedCallback(DependencyObject dobj, DependencyPropertyChangedEventArgs args)    {        if (dobj is Snackbar snackbarInstance)        {            // 执行旧队列的清理逻辑.            snackbarInstance.messageQueueRegistrationCleanUp?.Invoke();            // 将当前消息条与新队列进行配对，并存储清理操作.            snackbarInstance.messageQueueRegistrationCleanUp = (args.NewValue as SnackbarMessageQueue)?.Pair(snackbarInstance);        }    }    /// <summary>    /// 验证消息队列值的合法性.    /// </summary>    /// <param name="value">待验证的值.</param>    /// <returns>验证通过返回 true.</returns>    /// <exception cref="ArgumentException">当队列跨线程创建时抛出.</exception>    private static bool MessageQueueValidateValueCallback(object value)    {        // 检查值是否为空或是否在当前线程的调度器上创建.        if (value == null || ((SnackbarMessageQueue)value).Dispatcher == Dispatcher.CurrentDispatcher)        {            return true;        }        // 跨线程使用时抛出异常.        throw new ArgumentException("SnackbarMessageQueue must be created by the same thread.", nameof(value));    }    /// <summary>    /// 处理激活状态改变的内部方法.    /// </summary>    /// <param name="dobj">目标对象.</param>    /// <param name="args">属性更改参数.</param>    private static void OnIsActiveChanged(DependencyObject dobj, DependencyPropertyChangedEventArgs args)    {        if (dobj is Snackbar snackbarInstance)        {            // 创建并引发状态更改的路由事件.            var changedArgs = new RoutedPropertyChangedEventArgs<bool>((bool)args.OldValue, (bool)args.NewValue)            {                RoutedEvent = IsActiveChangedEvent,            };            snackbarInstance.RaiseEvent(changedArgs);        }    }    /// <summary>    /// 引发停用动画完成事件.    /// </summary>    /// <param name="snackbarInput">输入元素.</param>    /// <param name="message">关联的消息对象.</param>    private static void OnDeactivateStoryboardCompleted(Snackbar snackbarInput, SnackbarMessage message)    {        // 创建消息事件参数并引发事件.        var completedArgs = new SnackbarMessageEventArgs(DeactivateStoryboardCompletedEvent, message);        snackbarInput.RaiseEvent(completedArgs);    }    /// <summary>    /// 激活状态属性更改的回调函数.    /// </summary>    /// <param name="dobj">目标对象.</param>    /// <param name="args">属性更改参数.</param>    private static void IsActivePropertyChangedCallback(DependencyObject dobj, DependencyPropertyChangedEventArgs args)    {        // 调用状态更改处理逻辑.        OnIsActiveChanged(dobj, args);        // 如果状态变为非激活.        if (!(bool)args.NewValue)        {            Snackbar snackbarInstance = (Snackbar)dobj;            if (snackbarInstance.Message != null)            {                // 创建定时器以等待停用动画完成.                DispatcherTimer deactivateTimer = new DispatcherTimer();                deactivateTimer.Tag = new Tuple<Snackbar, SnackbarMessage>(snackbarInstance, snackbarInstance.Message);                deactivateTimer.Interval = snackbarInstance.DeactivateStoryboardDuration;                deactivateTimer.Tick += DeactivateStoryboardDispatcherTimerOnTick;                deactivateTimer.Start();            }        }    }    /// <summary>    /// 停用动画定时器滴答事件处理.    /// </summary>    /// <param name="sender">定时器对象.</param>    /// <param name="e">事件参数.</param>    private static void DeactivateStoryboardDispatcherTimerOnTick(object? sender, EventArgs e)    {        if (sender is DispatcherTimer timer)        {            // 停止并解除绑定，防止内存泄漏.            timer.Stop();            timer.Tick -= DeactivateStoryboardDispatcherTimerOnTick;            // 获取存储的快照状态并触发完成回调.            Tuple<Snackbar, SnackbarMessage> state = (Tuple<Snackbar, SnackbarMessage>)timer.Tag;            OnDeactivateStoryboardCompleted(state.Item1, state.Item2);        }    }}