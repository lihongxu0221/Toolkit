using BgControls.Core.Utilities;using BgControls.Windows.Controls.PropertyGrid.Attributes;using BgControls.Windows.Controls.PropertyGrid.Commands;using System.Windows.Automation.Peers;namespace BgControls.Windows.Controls.PropertyGrid;/// <summary>/// 定义一个委托，用于在 PropertyGrid 中动态过滤属性./// </summary>/// <param name="selectedObjectName">绑定数据源属性名.</param>/// <param name="propertyItem">要检查的属性.</param>/// <returns>如果该属性应该显示，则返回 true；否则返回 false.</returns>public delegate bool PropertyItemFilterCallback(string selectedObjectName, PropertyItem propertyItem);/// <summary>///   <para>Represents a control that allows users to inspect and edit the properties of an object.</para>/// </summary>[TemplatePart(Name = PART_DragThumb, Type = typeof(Thumb))][TemplatePart(Name = PART_PropertyItemsControl, Type = typeof(PropertyItemsControl))][StyleTypedProperty(Property = "PropertyContainerStyle", StyleTargetType = typeof(PropertyItemBase))]public class PropertyGrid : Control, ISupportInitialize, IPropertyContainer, INotifyPropertyChanged{    private const string PART_DragThumb = "PART_DragThumb";    internal const string PART_PropertyItemsControl = "PART_PropertyItemsControl";    private static readonly ComponentResourceKey SelectedObjectAdvancedOptionsMenuKey = new ComponentResourceKey(typeof(PropertyGrid), "SelectedObjectAdvancedOptionsMenu");    #region DependencyProperties    /// <summary>    /// Identifies the AdvancedOptionsMenu dependency property.    /// </summary>    public static readonly DependencyProperty AdvancedOptionsMenuProperty =        DependencyProperty.Register("AdvancedOptionsMenu", typeof(ContextMenu), typeof(PropertyGrid), new UIPropertyMetadata(null));    /// <summary>    /// Identifies the AutoGenerateProperties dependency property.    /// </summary>    public static readonly DependencyProperty AutoGeneratePropertiesProperty =        DependencyProperty.Register("AutoGenerateProperties", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true));    /// <summary>    /// Identifies the CategoryGroupHeaderTemplate dependency property.    /// </summary>    public static readonly DependencyProperty CategoryGroupHeaderTemplateProperty =        DependencyProperty.Register("CategoryGroupHeaderTemplate", typeof(DataTemplate), typeof(PropertyGrid));    /// <summary>    /// Identifies the ShowDescriptionByTooltip dependency property.    /// </summary>    public static readonly DependencyProperty ShowDescriptionByTooltipProperty =        DependencyProperty.Register("ShowDescriptionByTooltip", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false));    /// <summary>    /// Identifies the ShowSummary dependency property.    /// </summary>    public static readonly DependencyProperty ShowSummaryProperty =        DependencyProperty.Register("ShowSummary", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true));    /// <summary>    /// Identifies the EditorDefinitions dependency property.    /// </summary>    public static readonly DependencyProperty EditorDefinitionsProperty =        DependencyProperty.Register("EditorDefinitions", typeof(EditorDefinitionCollection), typeof(PropertyGrid), new UIPropertyMetadata(null, OnEditorDefinitionsChanged));    /// <summary>    /// Identifies the Filter dependency property.    /// </summary>    public static readonly DependencyProperty FilterProperty =        DependencyProperty.Register("Filter", typeof(string), typeof(PropertyGrid), new UIPropertyMetadata(string.Empty, OnFilterChanged));    /// <summary>    /// Identifies the FilterAdvance dependency property.    /// </summary>    public static readonly DependencyProperty FilterAdvanceProperty =        DependencyProperty.Register("FilterAdvance", typeof(PropertyItemFilterCallback), typeof(PropertyGrid), new UIPropertyMetadata(null, OnFilterAdvanceChanged));    /// <summary>    /// Identifies the FilterWatermark dependency property.    /// </summary>    public static readonly DependencyProperty FilterWatermarkProperty =        DependencyProperty.Register("FilterWatermark", typeof(string), typeof(PropertyGrid), new UIPropertyMetadata("Search"));    /// <summary>    /// Identifies the HideInheritedProperties dependency property.    /// </summary>    public static readonly DependencyProperty HideInheritedPropertiesProperty =        DependencyProperty.Register("HideInheritedProperties", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false));    /// <summary>    /// Identifies the IsCategorized dependency property.    /// </summary>    public static readonly DependencyProperty IsCategorizedProperty =        DependencyProperty.Register("IsCategorized", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true, OnIsCategorizedChanged));    /// <summary>    /// Identifies the IsMiscCategoryLabelHidden dependency property.    /// </summary>    public static readonly DependencyProperty IsMiscCategoryLabelHiddenProperty =        DependencyProperty.Register("IsMiscCategoryLabelHidden", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false));    /// <summary>    /// Identifies the IsScrollingToTopAfterRefresh dependency property.    /// </summary>    public static readonly DependencyProperty IsScrollingToTopAfterRefreshProperty =        DependencyProperty.Register("IsScrollingToTopAfterRefresh", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true));    /// <summary>    /// Identifies the IsVirtualizing dependency property.    /// </summary>    public static readonly DependencyProperty IsVirtualizingProperty =        DependencyProperty.Register("IsVirtualizing", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false, OnIsVirtualizingChanged));    /// <summary>    /// Identifies the IsExpandingNonPrimitiveTypes dependency property.    /// </summary>    public static readonly DependencyProperty IsExpandingNonPrimitiveTypesProperty =        DependencyProperty.Register("IsExpandingNonPrimitiveTypes", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false, OnIsExpandingNonPrimitiveTypesChanged));    /// <summary>    /// Identifies the CategoryGroupDescription dependency property.    /// </summary>    public static readonly DependencyProperty CategoryGroupDescriptionProperty = DependencyProperty.Register("CategoryGroupDescription", typeof(GroupDescription), typeof(PropertyGrid), new UIPropertyMetadata(null, OnCategoryGroupDescriptionChanged, OnCoerceCategoryGroupDescription));    /// <summary>    /// Identifies the DefaultEditorDefinition dependency property.    /// </summary>    public static readonly DependencyProperty DefaultEditorDefinitionProperty =        DependencyProperty.Register("DefaultEditorDefinition", typeof(EditorDefinitionBase), typeof(PropertyGrid), new UIPropertyMetadata(null, null, OnCoerceDefaultEditorDefinition));    /// <summary>    /// Identifies the NameColumnWidth dependency property.    /// </summary>    public static readonly DependencyProperty NameColumnWidthProperty = DependencyProperty.Register("NameColumnWidth", typeof(double), typeof(PropertyGrid), new UIPropertyMetadata(150.0, OnNameColumnWidthChanged));    /// <summary>    /// Identifies the PropertyNameLeftPadding dependency property.    /// </summary>    public static readonly DependencyProperty PropertyNameLeftPaddingProperty =        DependencyProperty.Register("PropertyNameLeftPadding", typeof(double), typeof(PropertyGrid), new UIPropertyMetadata(15.0));    /// <summary>    /// Identifies the PropertyNameTextWrapping dependency property.    /// </summary>    public static readonly DependencyProperty PropertyNameTextWrappingProperty =        DependencyProperty.Register("PropertyNameTextWrapping", typeof(TextWrapping), typeof(PropertyGrid), new UIPropertyMetadata(TextWrapping.NoWrap));    /// <summary>    /// Identifies the PropertiesSource dependency property.    /// </summary>    public static readonly DependencyProperty PropertiesSourceProperty =        DependencyProperty.Register("PropertiesSource", typeof(IEnumerable), typeof(PropertyGrid), new UIPropertyMetadata(null, OnPropertiesSourceChanged, OnCoercePropertiesSourceChanged));    /// <summary>    /// Identifies the PropertyContainerStyle dependency property.    /// </summary>    public static readonly DependencyProperty PropertyContainerStyleProperty =        DependencyProperty.Register("PropertyContainerStyle", typeof(Style), typeof(PropertyGrid), new UIPropertyMetadata(null, OnPropertyContainerStyleChanged));    /// <summary>    /// Identifies the PropertyDefinitions dependency property.    /// </summary>    public static readonly DependencyProperty PropertyDefinitionsProperty =        DependencyProperty.Register("PropertyDefinitions", typeof(PropertyDefinitionCollection), typeof(PropertyGrid), new UIPropertyMetadata(null, OnPropertyDefinitionsChanged));    /// <summary>    /// Identifies the IsReadOnly dependency property.    /// </summary>    public static readonly DependencyProperty IsReadOnlyProperty =        DependencyProperty.Register("IsReadOnly", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false, OnIsReadOnlyChanged));    /// <summary>    /// Identifies the SelectedObject dependency property.    /// </summary>    public static readonly DependencyProperty SelectedObjectProperty =        DependencyProperty.Register("SelectedObject", typeof(object), typeof(PropertyGrid), new UIPropertyMetadata(null, OnSelectedObjectChanged));    /// <summary>    /// Identifies the SelectedObjectType dependency property.    /// </summary>    public static readonly DependencyProperty SelectedObjectTypeProperty =        DependencyProperty.Register("SelectedObjectType", typeof(Type), typeof(PropertyGrid), new UIPropertyMetadata(null, OnSelectedObjectTypeChanged));    /// <summary>    /// Identifies the SelectedObjectTypeName dependency property.    /// </summary>    public static readonly DependencyProperty SelectedObjectTypeNameProperty =        DependencyProperty.Register("SelectedObjectTypeName", typeof(string), typeof(PropertyGrid), new UIPropertyMetadata(string.Empty));    /// <summary>    /// Identifies the SelectedObjectName dependency property.    /// </summary>    public static readonly DependencyProperty SelectedObjectNameProperty =        DependencyProperty.Register("SelectedObjectName", typeof(string), typeof(PropertyGrid), new UIPropertyMetadata(string.Empty, OnSelectedObjectNameChanged, OnCoerceSelectedObjectName));    /// <summary>    /// Identifies the SelectedObjectsOverride dependency property.    /// </summary>    public static readonly DependencyProperty SelectedObjectsOverrideProperty =        DependencyProperty.Register("SelectedObjectsOverride", typeof(IList), typeof(PropertyGrid), new UIPropertyMetadata(null, OnSelectedObjectsOverrideChanged, OnCoerceSelectedObjectsOverride));    /// <summary>    /// Identifies the SelectedPropertyItem dependency property key.    /// </summary>    private static readonly DependencyPropertyKey SelectedPropertyItemPropertyKey =        DependencyProperty.RegisterReadOnly("SelectedPropertyItem", typeof(PropertyItemBase), typeof(PropertyGrid), new UIPropertyMetadata(null, OnSelectedPropertyItemChanged));    /// <summary>    /// Identifies the SelectedPropertyItem dependency property.    /// </summary>    public static readonly DependencyProperty SelectedPropertyItemProperty = SelectedPropertyItemPropertyKey.DependencyProperty;    /// <summary>    /// Identifies the SelectedProperty dependency property.    /// </summary>    public static readonly DependencyProperty SelectedPropertyProperty =        DependencyProperty.Register("SelectedProperty", typeof(object), typeof(PropertyGrid), new UIPropertyMetadata(null, OnSelectedPropertyChanged));    /// <summary>    /// Identifies the ShowAdvancedOptions dependency property.    /// </summary>    public static readonly DependencyProperty ShowAdvancedOptionsProperty =        DependencyProperty.Register("ShowAdvancedOptions", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false));    /// <summary>    /// Identifies the ShowHorizontalScrollBar dependency property.    /// </summary>    public static readonly DependencyProperty ShowHorizontalScrollBarProperty =        DependencyProperty.Register("ShowHorizontalScrollBar", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false));    /// <summary>    /// Identifies the ShowPreview dependency property.    /// </summary>    public static readonly DependencyProperty ShowPreviewProperty =        DependencyProperty.Register("ShowPreview", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(false));    /// <summary>    /// Identifies the ShowSearchBox dependency property.    /// </summary>    public static readonly DependencyProperty ShowSearchBoxProperty =        DependencyProperty.Register("ShowSearchBox", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true));    /// <summary>    /// Identifies the ShowSortOptions dependency property.    /// </summary>    public static readonly DependencyProperty ShowSortOptionsProperty =        DependencyProperty.Register("ShowSortOptions", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true));    /// <summary>    /// Identifies the ShowTitle dependency property.    /// </summary>    public static readonly DependencyProperty ShowTitleProperty =        DependencyProperty.Register("ShowTitle", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true));    /// <summary>    /// Identifies the UpdateTextBoxSourceOnEnterKey dependency property.    /// </summary>    public static readonly DependencyProperty UpdateTextBoxSourceOnEnterKeyProperty =        DependencyProperty.Register("UpdateTextBoxSourceOnEnterKey", typeof(bool), typeof(PropertyGrid), new UIPropertyMetadata(true));    /// <summary>    /// Identifies the PropertyValueChanged routed event.    /// </summary>    public static readonly RoutedEvent PropertyValueChangedEvent =        EventManager.RegisterRoutedEvent("PropertyValueChanged", RoutingStrategy.Bubble, typeof(PropertyValueChangedEventHandler), typeof(PropertyGrid));    /// <summary>    /// Identifies the SelectedPropertyItemChanged routed event.    /// </summary>    public static readonly RoutedEvent SelectedPropertyItemChangedEvent =        EventManager.RegisterRoutedEvent("SelectedPropertyItemChanged", RoutingStrategy.Bubble, typeof(RoutedPropertyChangedEventHandler<PropertyItemBase>), typeof(PropertyGrid));    /// <summary>    /// Identifies the SelectedObjectChanged routed event.    /// </summary>    public static readonly RoutedEvent SelectedObjectChangedEvent =        EventManager.RegisterRoutedEvent("SelectedObjectChanged", RoutingStrategy.Bubble, typeof(RoutedPropertyChangedEventHandler<object>), typeof(PropertyGrid));    /// <summary>    /// Identifies the SelectedObjectsOverrideChanged routed event.    /// </summary>    public static readonly RoutedEvent SelectedObjectsOverrideChangedEvent =        EventManager.RegisterRoutedEvent("SelectedObjectsOverrideChanged", RoutingStrategy.Bubble, typeof(RoutedPropertyChangedEventHandler<object>), typeof(PropertyGrid));    /// <summary>    /// Identifies the CategoryExpanded routed event.    /// </summary>    public static readonly RoutedEvent CategoryExpandedEvent =        EventManager.RegisterRoutedEvent("CategoryExpanded", RoutingStrategy.Bubble, typeof(CategoryEventHandler), typeof(PropertyGrid));    /// <summary>    /// Identifies the CategoryCollapsed routed event.    /// </summary>    public static readonly RoutedEvent CategoryCollapsedEvent =        EventManager.RegisterRoutedEvent("CategoryCollapsed", RoutingStrategy.Bubble, typeof(CategoryEventHandler), typeof(PropertyGrid));    /// <summary>    /// Identifies the PreparePropertyItem routed event.    /// </summary>    public static readonly RoutedEvent PreparePropertyItemEvent =        EventManager.RegisterRoutedEvent("PreparePropertyItem", RoutingStrategy.Bubble, typeof(PropertyItemEventHandler), typeof(PropertyGrid));    /// <summary>    /// Identifies the ClearPropertyItem routed event.    /// </summary>    public static readonly RoutedEvent ClearPropertyItemEvent =        EventManager.RegisterRoutedEvent("ClearPropertyItem", RoutingStrategy.Bubble, typeof(PropertyItemEventHandler), typeof(PropertyGrid));    /// <summary>    /// Identifies the PropertiesGenerated routed event.    /// </summary>    public static readonly RoutedEvent PropertiesGeneratedEvent =        EventManager.RegisterRoutedEvent("PropertiesGenerated", RoutingStrategy.Bubble, typeof(EventHandler), typeof(PropertyGrid));    #endregion    static PropertyGrid()    {        DefaultStyleKeyProperty.OverrideMetadata(typeof(PropertyGrid), new FrameworkPropertyMetadata(typeof(PropertyGrid)));    }    private bool hasPendingSelectedObjectChanged;    private int initializationCount;    private Thumb? dragThumb;    private ContainerHelperBase containerHelper;    private CategoryDefinitionCollection? categoryDefinitions;    private Binding? propertyValueBinding;    private Binding? propertyNameBinding;    private IList? selectedObjects;    private WeakEventListener<NotifyCollectionChangedEventArgs> propertyDefinitionsListener;    private WeakEventListener<NotifyCollectionChangedEventArgs> editorDefinitionsListener;    private List<KeyValuePair<string, PropertyItem>> dependsOnPropertyItemsList = new List<KeyValuePair<string, PropertyItem>>();    private WeakEventListener<NotifyCollectionChangedEventArgs> categoryDefinitionsListener;    private WeakEventListener<NotifyCollectionChangedEventArgs> selectedObjectsListener;    /// <summary>    /// Initializes a new instance of the <see cref="PropertyGrid"/> class.    /// </summary>    public PropertyGrid()    {        this.propertyDefinitionsListener = new WeakEventListener<NotifyCollectionChangedEventArgs>(this.OnPropertyDefinitionsCollectionChanged);        this.editorDefinitionsListener = new WeakEventListener<NotifyCollectionChangedEventArgs>(this.OnEditorDefinitionsCollectionChanged);        this.selectedObjectsListener = new WeakEventListener<NotifyCollectionChangedEventArgs>(this.OnSelectedObjectsCollectionChanged);        this.categoryDefinitionsListener = new WeakEventListener<NotifyCollectionChangedEventArgs>(this.OnCategoryDefinitionsCollectionChanged);        this.UpdateContainerHelper();        this.SetCurrentValue(EditorDefinitionsProperty, new EditorDefinitionCollection());        this.SetCurrentValue(PropertyDefinitionsProperty, new PropertyDefinitionCollection());        this.CategoryDefinitions = new CategoryDefinitionCollection();        this.SetSelectedObjects(new ObservableCollection<object>());        this.PropertyValueChanged += this.OnPropertyValueChanged;        this.AddHandler(PropertyItemBase.ItemSelectionChangedEvent, new RoutedEventHandler(this.OnItemSelectionChanged));        this.AddHandler(PropertyItemsControl.PreparePropertyItemEvent, new PropertyItemEventHandler(this.OnPreparePropertyItemInternal));        this.AddHandler(PropertyItemsControl.ClearPropertyItemEvent, new PropertyItemEventHandler(this.OnClearPropertyItemInternal));        this.CommandBindings.Add(new CommandBinding(PropertyGridCommands.ClearFilter, this.OnClearFilter, this.OnCanClearFilter));    }    #region  Properties    /// <summary>    /// Gets or sets the contextual menu to use when the advanced menu button is clicked.    /// </summary>    public ContextMenu AdvancedOptionsMenu    {        get { return (ContextMenu)GetValue(AdvancedOptionsMenuProperty); }        set { SetValue(AdvancedOptionsMenuProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the PropertyGrid will generate all properties for a given object.    /// </summary>    public bool AutoGenerateProperties    {        get { return (bool)GetValue(AutoGeneratePropertiesProperty); }        set { SetValue(AutoGeneratePropertiesProperty, value); }    }    /// <summary>    /// Gets or sets the DataTemplate to use to define the category headers when the propertyGrid is categorized.    /// </summary>    public DataTemplate CategoryGroupHeaderTemplate    {        get { return (DataTemplate)GetValue(CategoryGroupHeaderTemplateProperty); }        set { SetValue(CategoryGroupHeaderTemplateProperty, value); }    }    /// <summary>Gets or sets a value indicating whether gets or sets if the Description of the PropertyItem will be displayed as a tooltip on the PART_Name of the PropertyItem. When ShowDescriptionByTooltip is True and    /// the DescriptionAttribute on the PropertyItem is not null and not empty, it will be displayed as a tooltip.</summary>    public bool ShowDescriptionByTooltip    {        get { return (bool)GetValue(ShowDescriptionByTooltipProperty); }        set { SetValue(ShowDescriptionByTooltipProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the summary pane is shown.    /// </summary>    public bool ShowSummary    {        get { return (bool)GetValue(ShowSummaryProperty); }        set { SetValue(ShowSummaryProperty, value); }    }    /// <summary>    ///   <para>Gets or sets a collection of custom editors to use in place of the default editors.</para>    /// </summary>    public EditorDefinitionCollection? EditorDefinitions    {        get { return (EditorDefinitionCollection?)GetValue(EditorDefinitionsProperty); }        set { SetValue(EditorDefinitionsProperty, value); }    }    /// <summary>    /// Gets or sets the filter used to filter the visible properties in the PropertyGrid.    /// </summary>    public string Filter    {        get { return (string)GetValue(FilterProperty); }        set { SetValue(FilterProperty, value); }    }    /// <summary>    /// Gets or sets the FilterAdvance used to filter the visibleproperties and set property value.    /// </summary>    public PropertyItemFilterCallback? FilterAdvance    {        get { return (PropertyItemFilterCallback?)GetValue(FilterAdvanceProperty); }        set { SetValue(FilterAdvanceProperty, value); }    }    /// <summary>    /// Gets or sets the watermark used in the filter field.    /// </summary>    public string FilterWatermark    {        get { return (string)GetValue(FilterWatermarkProperty); }        set { SetValue(FilterWatermarkProperty, value); }    }    /// <summary>    ///   Gets or sets a value indicating whether a value indicating if the inherited properties of the selected object will be hidden.    /// </summary>    public bool HideInheritedProperties    {        get { return (bool)GetValue(HideInheritedPropertiesProperty); }        set { SetValue(HideInheritedPropertiesProperty, value); }    }    /// <summary>Gets or sets a value indicating whether the properties displayed in the PropertyGrid are categorized.</summary>    public bool IsCategorized    {        get { return (bool)GetValue(IsCategorizedProperty); }        set { SetValue(IsCategorizedProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the "Misc" category expander should be hidden.    /// </summary>    public bool IsMiscCategoryLabelHidden    {        get { return (bool)GetValue(IsMiscCategoryLabelHiddenProperty); }        set { SetValue(IsMiscCategoryLabelHiddenProperty, value); }    }    /// <summary>    ///   Gets or sets a value indicating whether  if the PropertyGrid's vertical scrollViewer will scroll to top following a refresh of the PropertyItems.    /// </summary>    public bool IsScrollingToTopAfterRefresh    {        get { return (bool)GetValue(IsScrollingToTopAfterRefreshProperty); }        set { SetValue(IsScrollingToTopAfterRefreshProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether  if the PropertyGrid is using Virtualization.    /// </summary>    public bool IsVirtualizing    {        get { return (bool)GetValue(IsVirtualizingProperty); }        set { SetValue(IsVirtualizingProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether if the non-primitive types properties will be expandables to edit their sub-items directly from the PropertyGrid. Default is false.    /// </summary>    public bool IsExpandingNonPrimitiveTypes    {        get { return (bool)GetValue(IsExpandingNonPrimitiveTypesProperty); }        set { SetValue(IsExpandingNonPrimitiveTypesProperty, value); }    }    /// <summary>    /// Gets or sets the collection of CategoryDefinition instances.    /// </summary>    public CategoryDefinitionCollection? CategoryDefinitions    {        get        {            return this.categoryDefinitions;        }        set        {            if (this.categoryDefinitions != value)            {                var oldValue = this.categoryDefinitions;                this.categoryDefinitions = value;                this.OnCategoryDefinitionsChanged(categoryDefinitions, value);            }        }    }    /// <summary>    ///   <para>Gets or sets the GroupDescription to be applied on the source items in order to define the groups when the PropertyGrid is Categorized.</para>    /// </summary>    public GroupDescription CategoryGroupDescription    {        get { return (GroupDescription)GetValue(CategoryGroupDescriptionProperty); }        set { SetValue(CategoryGroupDescriptionProperty, value); }    }    /// <summary>    /// Gets or sets the Binding to be used on the property's underlying item to get the name of the property to display.    /// </summary>    public Binding? PropertyNameBinding    {        get        {            return this.propertyNameBinding;        }        set        {            if (this.propertyNameBinding != value)            {                this.ValidatePropertyBinding(value, nameof(this.PropertyNameBinding));                propertyNameBinding = value;            }        }    }    /// <summary>Gets or sets the Binding to be used on the property's underlying item to get the value of the property to display.</summary>    public Binding? PropertyValueBinding    {        get        {            return this.propertyValueBinding;        }        set        {            if (this.propertyValueBinding != value)            {                this.ValidatePropertyBinding(value, nameof(PropertyValueBinding));                this.propertyValueBinding = value;            }        }    }    /// <summary>    /// Gets or sets the default editor definition to use when the property value type is not supported.    /// </summary>    public EditorDefinitionBase DefaultEditorDefinition    {        get { return (EditorDefinitionBase)GetValue(DefaultEditorDefinitionProperty); }        set { SetValue(DefaultEditorDefinitionProperty, value); }    }    /// <summary>    /// Gets or sets the width of the property name column.    /// </summary>    public double NameColumnWidth    {        get { return (double)GetValue(NameColumnWidthProperty); }        set { SetValue(NameColumnWidthProperty, value); }    }    /// <summary>    /// Gets or sets the left padding of each propertyItem name in the PropertyGrid.    /// </summary>    public double PropertyNameLeftPadding    {        get { return (double)GetValue(PropertyNameLeftPaddingProperty); }        set { SetValue(PropertyNameLeftPaddingProperty, value); }    }    /// <summary>Gets or sets if text wrapping should be used for the long property names.</summary>    public TextWrapping PropertyNameTextWrapping    {        get { return (TextWrapping)GetValue(PropertyNameTextWrappingProperty); }        set { SetValue(PropertyNameTextWrappingProperty, value); }    }    /// <summary>    /// Gets the current collection of generated PropertyItem instances.    /// </summary>    public IList? Properties => this.containerHelper?.Properties;    /// <summary>    /// Gets or sets the items source for the properties of the PropertyGrid.    /// </summary>    public IEnumerable PropertiesSource    {        get { return (IEnumerable)GetValue(PropertiesSourceProperty); }        set { SetValue(PropertiesSourceProperty, value); }    }    /// <summary>    /// Gets or sets the style that will be applied to all PropertyItemBase instances displayed in the property grid.    /// </summary>    public Style? PropertyContainerStyle    {        get { return (Style?)GetValue(PropertyContainerStyleProperty); }        set { SetValue(PropertyContainerStyleProperty, value); }    }    /// <summary>    ///   <para>Gets or sets the collection of PropertyDefinition instances.</para>    /// </summary>    public PropertyDefinitionCollection? PropertyDefinitions    {        get { return (PropertyDefinitionCollection?)GetValue(PropertyDefinitionsProperty); }        set { SetValue(PropertyDefinitionsProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the property grid is read-only.    /// </summary>    public bool IsReadOnly    {        get { return (bool)GetValue(IsReadOnlyProperty); }        set { SetValue(IsReadOnlyProperty, value); }    }    /// <summary>    /// Gets or sets the current object the PropertyGrid is inspecting.    /// </summary>    public object? SelectedObject    {        get { return GetValue(SelectedObjectProperty); }        set { SetValue(SelectedObjectProperty, value); }    }    /// <summary>    /// Gets or sets the Type of the SelectedObject.    /// </summary>    public Type SelectedObjectType    {        get { return (Type)GetValue(SelectedObjectTypeProperty); }        set { SetValue(SelectedObjectTypeProperty, value); }    }    /// <summary>    /// Gets or sets the name of the Type of the SelectedObject.    /// </summary>    public string SelectedObjectTypeName    {        get { return (string)GetValue(SelectedObjectTypeNameProperty); }        set { SetValue(SelectedObjectTypeNameProperty, value); }    }    /// <summary>    /// Gets or sets the name of the SelectedObject.    /// </summary>    public string SelectedObjectName    {        get { return (string)GetValue(SelectedObjectNameProperty); }        set { SetValue(SelectedObjectNameProperty, value); }    }    /// <summary>    /// Gets the currently selected objects the PropertyGrid is inspecting.    /// </summary>    public IList? SelectedObjects => selectedObjects;    /// <summary>    /// Gets or sets the list of selected objects.    /// </summary>    public IList? SelectedObjectsOverride    {        get { return (IList)GetValue(SelectedObjectsOverrideProperty); }        set { SetValue(SelectedObjectsOverrideProperty, value); }    }    /// <summary>    /// Gets the selected PropertyItem.    /// </summary>    public PropertyItemBase? SelectedPropertyItem    {        get { return (PropertyItemBase)GetValue(SelectedPropertyItemProperty); }        internal set { SetValue(SelectedPropertyItemPropertyKey, value); }    }    /// <summary>    /// Gets or sets the selected property or returns null if the selection is empty.    /// </summary>    public object? SelectedProperty    {        get { return GetValue(SelectedPropertyProperty); }        set { SetValue(SelectedPropertyProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the advanced options button next to the properties is displayed.    /// </summary>    public bool ShowAdvancedOptions    {        get { return (bool)GetValue(ShowAdvancedOptionsProperty); }        set { SetValue(ShowAdvancedOptionsProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether if the horizontal scroll bar will be visible in the PropertyGrid.    /// </summary>    public bool ShowHorizontalScrollBar    {        get { return (bool)GetValue(ShowHorizontalScrollBarProperty); }        set { SetValue(ShowHorizontalScrollBarProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the preview pane is displayed.    /// </summary>    public bool ShowPreview    {        get { return (bool)GetValue(ShowPreviewProperty); }        set { SetValue(ShowPreviewProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the search box is displayed.    /// </summary>    public bool ShowSearchBox    {        get { return (bool)GetValue(ShowSearchBoxProperty); }        set { SetValue(ShowSearchBoxProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the sort options are displayed (Categorized and Alphabetical).    /// </summary>    public bool ShowSortOptions    {        get { return (bool)GetValue(ShowSortOptionsProperty); }        set { SetValue(ShowSortOptionsProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the PropertyGrid's title is displayed.    /// </summary>    public bool ShowTitle    {        get { return (bool)GetValue(ShowTitleProperty); }        set { SetValue(ShowTitleProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether the TextBox used to enter the filter text will update its source only when the Enter key is pressed.    /// </summary>    public bool UpdateTextBoxSourceOnEnterKey    {        get { return (bool)GetValue(UpdateTextBoxSourceOnEnterKeyProperty); }        set { SetValue(UpdateTextBoxSourceOnEnterKeyProperty, value); }    }    /// <inheritdoc/>    FilterInfo IPropertyContainer.FilterInfo => new FilterInfo    {        Predicate = this.CreateFilter(this.Filter),        InputString = this.Filter,    };    /// <inheritdoc/>    ContainerHelperBase IPropertyContainer.ContainerHelper => this.containerHelper;    /// <inheritdoc/>    bool IPropertyContainer.IsSortedAlphabetically    {        get        {            if (this.SelectedObject != null)            {                var categoryPropertyOrderAttribute = TypeDescriptor.GetAttributes(this.SelectedObject)                    .OfType<CategoryPropertyOrderAttribute>()                    .FirstOrDefault();                if (this.IsCategorized &&                    categoryPropertyOrderAttribute != null &&                    categoryPropertyOrderAttribute.CategoryPropertyOrder == CategoryPropertyOrderEnum.Declaration)                {                    return false;                }            }            return true;        }    }    /// <inheritdoc/>    List<KeyValuePair<string, PropertyItem>> IPropertyContainer.DependsOnPropertyItemsList => dependsOnPropertyItemsList;    /// <inheritdoc/>    bool? IPropertyContainer.IsPropertyVisible(PropertyDescriptor pd)    {        if (this.IsPropertyBrowsable != null)        {            var e = new IsPropertyBrowsableArgs(pd);            this.IsPropertyBrowsable.Invoke(this, e);            return e.IsBrowsable;        }        return null;    }    /// <inheritdoc/>    bool? IPropertyContainer.IsPropertyExpandable(PropertyDescriptor pd)    {        if (this.IsPropertyExpandable != null)        {            var e = new IsPropertyExpandableArgs(pd);            this.IsPropertyExpandable.Invoke(this, e);            return e.IsExpandable;        }        return null;    }    #endregion    #region event listener    private void OnPropertyDefinitionsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)    {        if (this.containerHelper != null)        {            this.containerHelper.NotifyPropertyDefinitionsCollectionChanged();        }        if (this.IsLoaded)        {            this.UpdateContainerHelper();        }    }    private void OnEditorDefinitionsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)    {        if (this.containerHelper != null)        {            this.containerHelper.NotifyEditorDefinitionsCollectionChanged();        }    }    private void OnSelectedObjectsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)    {        ValidateSelectedObjectsCollection((IList)sender);        this.UpdateContainerHelper();    }    private void OnCategoryDefinitionsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)    {        if (containerHelper != null)        {            containerHelper.NotifyCategoryDefinitionsCollectionChanged();        }    }    private void OnItemSelectionChanged(object sender, RoutedEventArgs args)    {        if (args.OriginalSource is PropertyItemBase propertyItemBase)        {            if (propertyItemBase.IsSelected)            {                this.SelectedPropertyItem = propertyItemBase;            }            else if (propertyItemBase == this.SelectedPropertyItem)            {                this.SelectedPropertyItem = null;            }        }    }    private void OnPreparePropertyItemInternal(object sender, PropertyItemEventArgs args)    {        if (this.containerHelper != null)        {            this.containerHelper.PrepareChildrenPropertyItem(args.PropertyItem, args.Item);        }        args.Handled = true;    }    private void OnClearPropertyItemInternal(object sender, PropertyItemEventArgs args)    {        if (this.containerHelper != null)        {            this.containerHelper.ClearChildrenPropertyItem(args.PropertyItem, args.Item);        }        args.Handled = true;    }    private void OnDragThumbDragDelta(object sender, DragDeltaEventArgs e)    {        NameColumnWidth = Math.Min(Math.Max(this.ActualWidth * 0.1, NameColumnWidth + e.HorizontalChange), this.ActualWidth * 0.9);    }    private void OnDragThumbMouseWheel(object sender, MouseWheelEventArgs e)    {        ScrollToPosition(GetScrollPosition() - (e.Delta * 0.4));    }    private void OnPropertyValueChanged(object sender, PropertyValueChangedEventArgs e)    {        if (e.OriginalSource is PropertyItem propertyItem)        {            if (propertyItem.WillRefreshPropertyGrid)            {                Dictionary<string, bool> dictionary = new Dictionary<string, bool>();                if (this.Properties != null)                {                    foreach (object property in this.Properties)                    {                        if (property is CustomPropertyItem customPropertyItem)                        {                            if (!dictionary.ContainsKey(customPropertyItem.Category))                            {                                dictionary.Add(customPropertyItem.Category, customPropertyItem.IsCategoryExpanded);                            }                        }                    }                }                this.UpdateContainerHelper();                foreach (var item in dictionary)                {                    if (item.Value)                    {                        this.ExpandCategory(item.Key);                    }                    else                    {                        this.CollapseCategory(item.Key);                    }                }            }            else            {                this.UpdateDependingPropertyItemEditors(propertyItem);            }            // 属性变更：触发推模式更新            if (this.Properties != null)            {                propertyItem.OnHandlePropertyValueChanged(this.Properties.Cast<PropertyItem>());            }            // 重构PropertyItemEditor            var parentProperty = propertyItem.ParentNode as PropertyItem;            while (parentProperty != null && parentProperty.IsExpandable)            {                this.RebuildPropertyItemEditor(parentProperty);                parentProperty = parentProperty.ParentNode as PropertyItem;            }        }    }    private void OnClearFilter(object sender, ExecutedRoutedEventArgs e)    {        this.Filter = string.Empty;    }    private void OnCanClearFilter(object sender, CanExecuteRoutedEventArgs e)    {        e.CanExecute = !string.IsNullOrEmpty(this.Filter);    }    private void OnObjectsGenerated(object? sender, EventArgs e)    {        if (sender is ObjectContainerHelperBase objectContainerHelper)        {            objectContainerHelper.ObjectsGenerated -= this.OnObjectsGenerated;            this.SetContainerHelper(objectContainerHelper);            this.FinalizeUpdateContainerHelper(objectContainerHelper.ChildrenItemsControl);            this.RaiseEvent(new RoutedEventArgs(PropertiesGeneratedEvent, this));        }    }    #endregion    #region public methods    /// <summary>    /// Returns a value that contains the vertical offset of the PropertyGrid's ScrollViewer.    /// </summary>    /// <returns>The vertical offset position of the PropertyGrid's ScrollViewer.</returns>    public double GetScrollPosition()    {        return GetScrollViewer()?.VerticalOffset ?? 0.0;    }    /// <summary>    /// Scrolls the PropertyGrid's scrollViewer to the specified vertical offset position.    /// </summary>    /// <param name="position">The vertical offset position to scroll to.</param>    public void ScrollToPosition(double position)    {        GetScrollViewer()?.ScrollToVerticalOffset(position);    }    /// <summary>    /// Scrolls vertically to the beginning of the PropertyGrid's ScrollViewer.    /// </summary>    public void ScrollToTop()    {        GetScrollViewer()?.ScrollToTop();    }    /// <summary>    /// Scrolls vertically to the end of the PropertyGrid's ScrollViewer.    /// </summary>    public void ScrollToBottom()    {        GetScrollViewer()?.ScrollToBottom();    }    /// <summary>    /// Collapse all the PropertyItems and their sub-PropertyItems.    /// </summary>    public void CollapseAllProperties()    {        if (containerHelper != null)        {            containerHelper.SetPropertiesExpansion(isExpanded: false);        }    }    /// <summary>    /// Expand all the PropertyItems and their sub-PropertyItems.    /// </summary>    public void ExpandAllProperties()    {        if (containerHelper != null)        {            containerHelper.SetPropertiesExpansion(isExpanded: true);        }    }    /// <summary>    /// Expand the PropertyItem( or the sub-PropertyItem) with the specific propertyName.    /// </summary>    /// <param name="propertyName">The name of the property to expand.</param>    public void ExpandProperty(string propertyName)    {        if (containerHelper != null)        {            containerHelper.SetPropertiesExpansion(propertyName, true);        }    }    /// <summary>    /// Collapse the PropertyItem( or the sub-PropertyItem) with the specific propertyName.    /// </summary>    /// <param name="propertyName">The name of the property to collapse.</param>    public void CollapseProperty(string propertyName)    {        if (containerHelper != null)        {            containerHelper.SetPropertiesExpansion(propertyName, false);        }    }    /// <summary>    /// Collapses all categories in the PropertyGrid.    /// </summary>    public void CollapseAllCategories()    {        this.SetCategoryItemsExpansion(false);    }    /// <summary>    /// Collapses the specified property in the PropertyGrid.    /// </summary>    /// <param name="groupName">A string representing the name of the category to collapse.</param>    public void CollapseCategory(string groupName)    {        this.SetCategoryItemsExpansion(groupName, false);    }    /// <summary>    /// Expands all categories in the PropertyGrid.    /// </summary>    public void ExpandAllCategories()    {        this.SetCategoryItemsExpansion(true);    }    /// <summary>    /// Expands the specified property in the PropertyGrid.    /// </summary>    /// <param name="groupName">A string representing the name of the category to expand.</param>    public void ExpandCategory(string groupName)    {        this.SetCategoryItemsExpansion(groupName, true);    }    /// <summary>    /// Gets if the specified category is expanded.    /// </summary>    /// <param name="categoryName">The name of the category.</param>    /// <returns>    ///   <strong>true</strong> if the specified category is expanded, otherwise <strong>false</strong>.    /// </returns>    public bool IsCategoryExpanded(string categoryName)    {        return this.IsCategoryInWantedState(categoryName, true);    }    /// <summary>Gets if the specified category is collapsed.</summary>    /// <returns>    ///   <strong>true</strong> if the specified category is collapsed, otherwise <strong>false</strong>.</returns>    /// <param name="categoryName">The name of the category.</param>    public bool IsCategoryCollapsed(string categoryName)    {        return IsCategoryInWantedState(categoryName, isExpanded: false);    }    /// <summary>Gets a list containing the names of the categories that are collapsed.</summary>    /// <returns>A list containing the names of the categories that are collapsed.</returns>    public List<string> GetCollapsedCategories()    {        return GetSpecificCategories(false);    }    /// <summary>Gets a list containing the names of the categories that are expanded.</summary>    /// <returns>A list containing the names of the categories that are expanded.</returns>    public List<string> GetExpandedCategories()    {        return GetSpecificCategories(true);    }    /// <summary>Gets a list containing all the category names.</summary>    /// <returns>A list containing all the category names.</returns>    public List<string> GetCategories()    {        return GetSpecificCategories();    }    #endregion    #region protected override methods    /// <inheritdoc/>    public override void OnApplyTemplate()    {        base.OnApplyTemplate();        if (this.dragThumb != null)        {            this.dragThumb.DragDelta -= this.OnDragThumbDragDelta;            this.dragThumb.MouseWheel -= this.OnDragThumbMouseWheel;        }        this.dragThumb = GetTemplateChild(PART_DragThumb) as Thumb;        if (this.dragThumb != null)        {            this.dragThumb.DragDelta += this.OnDragThumbDragDelta;            this.dragThumb.MouseWheel += this.OnDragThumbMouseWheel;        }        if (this.containerHelper != null)        {            this.containerHelper.ChildrenItemsControl = this.GetTemplateChild(PART_PropertyItemsControl) as PropertyItemsControl;        }        if (this.dragThumb != null)        {            TranslateTransform translateTransform = new TranslateTransform();            translateTransform.X = NameColumnWidth;            this.dragThumb.RenderTransform = translateTransform;        }        this.UpdateThumb();    }    /// <inheritdoc/>    protected override void OnPreviewKeyDown(KeyEventArgs e)    {        if (e.OriginalSource is TextBox textBox)        {            if (this.SelectedPropertyItem != null &&                this.UpdateTextBoxSourceOnEnterKey &&                e.Key == Key.Return && !textBox.AcceptsReturn)            {                textBox.GetBindingExpression(TextBox.TextProperty)?.UpdateSource();            }        }    }    /// <inheritdoc/>    protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e)    {        base.OnPropertyChanged(e);        if (ReflectionHelper.IsPublicInstanceProperty(this.GetType(), e.Property.Name))        {            this.Notify(this.PropertyChanged, e.Property.Name);        }    }    /// <inheritdoc/>    protected override AutomationPeer OnCreateAutomationPeer()    {        return new Automation.Peers.GenericAutomationPeer(this);    }    /// <inheritdoc/>    public override void BeginInit()    {        base.BeginInit();        initializationCount++;    }    /// <inheritdoc/>    public override void EndInit()    {        base.EndInit();        if (--initializationCount == 0)        {            if (hasPendingSelectedObjectChanged)            {                this.UpdateContainerHelper();                this.hasPendingSelectedObjectChanged = false;            }            if (containerHelper != null)            {                containerHelper.OnEndInit();            }        }    }    #endregion    #region virtual methods    /// <summary>Called when EditorDefinitions changes.</summary>    /// <param name="oldValue">The old EditorDefinitionCollection value.</param>    /// <param name="newValue">The new EditorDefinitionCollection value.</param>    protected virtual void OnEditorDefinitionsChanged(EditorDefinitionCollection oldValue, EditorDefinitionCollection newValue)    {        if (oldValue != null)        {            CollectionChangedEventManager.RemoveListener(oldValue, editorDefinitionsListener);        }        if (newValue != null)        {            CollectionChangedEventManager.AddListener(newValue, editorDefinitionsListener);        }        this.Notify(this.PropertyChanged, () => EditorDefinitions);    }    /// <summary>    /// Called when Filter changes.    /// </summary>    /// <param name="oldValue">The old string value of Filter.</param>    /// <param name="newValue">The new string value of Filter.</param>    protected virtual void OnFilterChanged(string oldValue, string newValue)    {        this.Notify(this.PropertyChanged, () => ((IPropertyContainer)this).FilterInfo);    }    /// <summary>    /// Called when FilterAdvance changes.    /// </summary>    /// <param name="oldValue">The old PropertyItemFilterCallback value of FilterAdvance.</param>    /// <param name="newValue">The new PropertyItemFilterCallback value of FilterAdvance.</param>    protected virtual void OnFilterAdvanceChanged(PropertyItemFilterCallback? oldValue, PropertyItemFilterCallback? newValue)    {        this.Notify(this.PropertyChanged, () => ((IPropertyContainer)this).FilterInfo);    }    /// <summary>    /// Called when IsCategorized changes.    /// </summary>    /// <param name="oldValue">The old bool value of IsCategorized.</param>    /// <param name="newValue">The new bool value of IsCategorized.</param>    protected virtual void OnIsCategorizedChanged(bool oldValue, bool newValue)    {        this.UpdateThumb();    }    /// <summary>    /// Called when IsVirtualizing changes.    /// </summary>    /// <param name="oldValue">The old bool value of IsVirtualizing.</param>    /// <param name="newValue">The new bool value of IsVirtualizing.</param>    protected virtual void OnIsVirtualizingChanged(bool oldValue, bool newValue)    {        this.UpdateContainerHelper();    }    /// <summary>    /// Called when IsExpandingNonPrimitiveTypes changes.    /// </summary>    /// <param name="oldValue">The old bool value of IsExpandingNonPrimitiveTypes.</param>    /// <param name="newValue">The new bool value of IsExpandingNonPrimitiveTypes.</param>    protected virtual void OnIsExpandingNonPrimitiveTypesChanged(bool oldValue, bool newValue)    {        this.UpdateContainerHelper();    }    /// <summary>    /// Called when CategoryDefinitions changes.    /// </summary>    /// <param name="oldValue">The old bool value of CategoryDefinitions.</param>    /// <param name="newValue">The new bool value of CategoryDefinitions.</param>    protected virtual void OnCategoryDefinitionsChanged(CategoryDefinitionCollection? oldValue, CategoryDefinitionCollection? newValue)    {        if (oldValue != null)        {            CollectionChangedEventManager.RemoveListener(oldValue, categoryDefinitionsListener);        }        if (newValue != null)        {            CollectionChangedEventManager.AddListener(newValue, categoryDefinitionsListener);        }        this.Notify(this.PropertyChanged, () => CategoryDefinitions);    }    /// <summary>    /// Called when NameColumnWidth changes.    /// </summary>    /// <param name="oldValue">The old bool value of NameColumnWidth.</param>    /// <param name="newValue">The new bool value of NameColumnWidth.</param>    protected virtual void OnNameColumnWidthChanged(double oldValue, double newValue)    {        if (dragThumb?.RenderTransform is TranslateTransform transform)        {            transform.X = newValue;        }    }    /// <summary>    /// Called when PropertyContainerStyle has changed.    /// </summary>    /// <param name="oldValue">The old bool value of PropertyContainerStyle.</param>    /// <param name="newValue">The new bool value of PropertyContainerStyle.</param>    protected virtual void OnPropertyContainerStyleChanged(Style? oldValue, Style? newValue)    {    }    /// <summary>    /// Called when PropertyDefinitions changes.    /// </summary>    /// <param name="oldValue">The old PropertyDefinitionCollection value.</param>    /// <param name="newValue">The new PropertyDefinitionCollection value.</param>    protected virtual void OnPropertyDefinitionsChanged(PropertyDefinitionCollection? oldValue, PropertyDefinitionCollection? newValue)    {        if (oldValue != null)        {            CollectionChangedEventManager.RemoveListener(oldValue, propertyDefinitionsListener);        }        if (newValue != null)        {            CollectionChangedEventManager.AddListener(newValue, propertyDefinitionsListener);        }        this.Notify(this.PropertyChanged, () => PropertyDefinitions);    }    /// <summary>    /// Called when IsReadOnly has changed.    /// </summary>    /// <param name="oldValue">The old bool value of IsReadOnly.</param>    /// <param name="newValue">The new bool value of IsReadOnly.</param>    protected virtual void OnIsReadOnlyChanged(bool oldValue, bool newValue)    {        List<string> collapsedCategories = this.GetCollapsedCategories();        this.UpdateContainerHelper();        this.ExpandAllCategories();        foreach (string item in collapsedCategories)        {            this.CollapseCategory(item);        }    }    /// <summary>    /// Called when SelectedObject changes.    /// </summary>    /// <param name="oldValue">The old value of SelectedObject.</param>    /// <param name="newValue">The new value of SelectedObject.</param>    protected virtual void OnSelectedObjectChanged(object oldValue, object newValue)    {        if (initializationCount != 0)        {            hasPendingSelectedObjectChanged = true;            return;        }        this.UpdateContainerHelper();        this.RaiseEvent(new RoutedPropertyChangedEventArgs<object>(oldValue, newValue, SelectedObjectChangedEvent));        // 使用 Dispatcher 确保在 UI 容器生成 PropertyItem 后执行        this.Dispatcher.BeginInvoke(            () =>            {                this.Properties?.Cast<PropertyItem>().Initialize();            },            System.Windows.Threading.DispatcherPriority.Loaded);    }    /// <summary>    /// Called when SelectedObjectType changes.    /// </summary>    /// <param name="oldValue">The old SelectedObjectType value.</param>    /// <param name="newValue">The new SelectedObjectType value.</param>    protected virtual void OnSelectedObjectTypeChanged(Type? oldValue, Type? newValue)    {    }    /// <summary>    /// Called when SelectedObjectName changes.    /// </summary>    /// <param name="oldValue">The old string value of SelectedObjectName.</param>    /// <param name="newValue">The new string value of SelectedObjectName.</param>    protected virtual void SelectedObjectNameChanged(string oldValue, string newValue)    {    }    /// <summary>    /// Called when SelectedPropertyItem has changed.    /// </summary>    /// <param name="oldValue">The old bool value of SelectedPropertyItem.</param>    /// <param name="newValue">The new bool value of SelectedPropertyItem.</param>    protected virtual void OnSelectedPropertyItemChanged(PropertyItemBase? oldValue, PropertyItemBase? newValue)    {        if (oldValue != null)        {            oldValue.IsSelected = false;        }        if (newValue != null)        {            newValue.IsSelected = true;        }        this.SelectedProperty = newValue != null && containerHelper != null ? containerHelper.ItemFromContainer(newValue) : null;        this.RaiseEvent(new RoutedPropertyChangedEventArgs<PropertyItemBase>(oldValue, newValue, SelectedPropertyItemChangedEvent));    }    #endregion    #region events    /// <summary>    /// Raised when a property's value changes.    /// </summary>    public event PropertyValueChangedEventHandler PropertyValueChanged    {        add { AddHandler(PropertyValueChangedEvent, value); }        remove { RemoveHandler(PropertyValueChangedEvent, value); }    }    /// <summary>    /// Raised when SelectedProperty changes.    /// </summary>    public event RoutedPropertyChangedEventHandler<PropertyItemBase> SelectedPropertyItemChanged    {        add { AddHandler(SelectedPropertyItemChangedEvent, value); }        remove { RemoveHandler(SelectedPropertyItemChangedEvent, value); }    }    /// <summary>    /// Raised when the selected object changes.    /// </summary>    public event RoutedPropertyChangedEventHandler<object> SelectedObjectChanged    {        add { AddHandler(SelectedObjectChangedEvent, value); }        remove { RemoveHandler(SelectedObjectChangedEvent, value); }    }    /// <summary>    /// Raised when the value of a property has changed.    /// </summary>    public event PropertyChangedEventHandler? PropertyChanged;    /// <summary>    ///   <font size="2">Raised for each propertyItem of the PropertyGrid.SelectedObject when someone is registered to this event and want to set individually the    /// visibility of propertyItems in the PropertyGrid.</font>    /// </summary>    public event IsPropertyBrowsableHandler? IsPropertyBrowsable;    /// <summary>    /// Raised for each propertyItem of the PropertyGrid.SelectedObject when someone is registered to this event and want to set individually if propertyItems are expandables in the PropertyGrid.    /// </summary>    public event IsPropertyExpandableHandler? IsPropertyExpandable;    /// <summary>    /// Raised when the SelectedObjectsOverride property changes.    /// </summary>    public event RoutedPropertyChangedEventHandler<object> SelectedObjectsOverrideChanged    {        add { AddHandler(SelectedObjectsOverrideChangedEvent, value); }        remove { RemoveHandler(SelectedObjectsOverrideChangedEvent, value); }    }    /// <summary>    /// Raised when a category is expanded.    /// </summary>    public event CategoryEventHandler? CategoryExpanded    {        add { AddHandler(CategoryExpandedEvent, value); }        remove { RemoveHandler(CategoryExpandedEvent, value); }    }    /// <summary>    /// Raised when a category is collapsed.    /// </summary>    public event CategoryEventHandler CategoryCollapsed    {        add { AddHandler(CategoryCollapsedEvent, value); }        remove { RemoveHandler(CategoryCollapsedEvent, value); }    }    /// <summary>    ///   <para>Raised when a property item is about to be displayed, either from PropertyItem or PropertyGrid, depending on which one is being expanded.</para>    /// </summary>    public event PropertyItemEventHandler PreparePropertyItem    {        add { AddHandler(PreparePropertyItemEvent, value); }        remove { RemoveHandler(PreparePropertyItemEvent, value); }    }    /// <summary>    /// Raised when an property item is about to be remove from the display in the PropertyGrid.    /// </summary>    public event PropertyItemEventHandler ClearPropertyItem    {        add { AddHandler(ClearPropertyItemEvent, value); }        remove { RemoveHandler(ClearPropertyItemEvent, value); }    }    /// <summary>    /// Raised when all the properties of the PropertyGrid are generated.    /// </summary>    public event RoutedEventHandler PropertiesGenerated    {        add { AddHandler(PropertiesGeneratedEvent, value); }        remove { RemoveHandler(PropertiesGeneratedEvent, value); }    }    #endregion    internal void RaiseCategoryRoutedEvent(RoutedEvent routedEvent, string categoryName)    {        CategoryEventArgs e = new CategoryEventArgs(routedEvent, this, categoryName);        RaiseEvent(e);    }    /// <summary>    /// Override this call to control the filter applied based on the text input.    /// </summary>    /// <param name="filter">The filter string.</param>    /// <returns>A Predicate to filter the properties.</returns>    protected virtual Predicate<object>? CreateFilter(string filter)    {        return null;    }    /// <summary>    ///  Updates all property values in the PropertyGrid with the data from the SelectedObject or <see cref="PropertyGrid">SelectedObjects</see>.    /// </summary>    public void Update()    {        if (this.containerHelper != null)        {            this.containerHelper.UpdateValuesFromSource();        }    }    private void FinalizeUpdateContainerHelper(ItemsControl? childrenItemsControl)    {        if (this.containerHelper != null)        {            this.containerHelper.ChildrenItemsControl = childrenItemsControl;        }        if (this.IsScrollingToTopAfterRefresh)        {            this.ScrollToTop();        }        this.Notify(this.PropertyChanged, () => Properties);    }    private ScrollViewer? GetScrollViewer()    {        if (containerHelper != null && containerHelper.ChildrenItemsControl != null)        {            return TreeHelper.FindChild<ScrollViewer>(containerHelper.ChildrenItemsControl);        }        return null;    }    private List<string> GetSpecificCategories(bool? isExpanded = null)    {        List<string> list = new List<string>();        if (containerHelper == null ||            containerHelper.ChildrenItemsControl == null ||            !containerHelper.ChildrenItemsControl.HasItems ||            containerHelper.ChildrenItemsControl.Items.Groups == null)        {            return list;        }        foreach (object group in containerHelper.ChildrenItemsControl.Items.Groups)        {            if (group is CollectionViewGroup { Items: not null } collectionViewGroup && collectionViewGroup.Items.Count > 0 && collectionViewGroup.Items[0] is CustomPropertyItem customPropertyItem && (!isExpanded.HasValue || (isExpanded.HasValue && isExpanded.Value && customPropertyItem.IsCategoryExpanded) || (isExpanded.HasValue && !isExpanded.Value && !customPropertyItem.IsCategoryExpanded)))            {                list.Add(customPropertyItem.Category);            }        }        return list;    }    private bool IsCategoryInWantedState(string categoryName, bool isExpanded)    {        if (containerHelper == null || containerHelper.ChildrenItemsControl == null || !containerHelper.ChildrenItemsControl.HasItems || containerHelper.ChildrenItemsControl.Items.Groups == null)        {            return false;        }        if (containerHelper.ChildrenItemsControl.Items.Groups.FirstOrDefault(x => x is CollectionViewGroup viewGroup && viewGroup.Name.Equals(categoryName)) is CollectionViewGroup { Items: not null } collectionViewGroup)        {            foreach (object item in collectionViewGroup.Items)            {                if (item is CustomPropertyItem customPropertyItem)                {                    return (isExpanded && customPropertyItem.IsCategoryExpanded) || (!isExpanded && !customPropertyItem.IsCategoryExpanded);                }            }        }        return false;    }    private void OnCategoryGroupDescriptionChanged(GroupDescription oldValue, GroupDescription newValue)    {        this.UpdateThumb();    }    private void OnPropertiesSourceChanged(IEnumerable oldValue, IEnumerable newValue)    {        this.UpdateContainerHelper();    }    private void OnSelectedPropertyChanged(object oldValue, object newValue)    {        if (containerHelper != null && !object.Equals(containerHelper.ItemFromContainer(this.SelectedPropertyItem), newValue))        {            this.SelectedPropertyItem = containerHelper.ContainerFromItem(newValue);        }    }    private void OnSelectedObjectsOverrideChanged(IList oldValue, IList newValue)    {        IList? selectedObjects;        if (newValue == null)        {            IList list = new ObservableCollection<object>();            selectedObjects = list;        }        else        {            selectedObjects = newValue;        }        this.SetSelectedObjects(selectedObjects);        this.RaiseEvent(new RoutedPropertyChangedEventArgs<object>(oldValue, newValue, SelectedObjectsOverrideChangedEvent));    }    private void RebuildPropertyItemEditor(PropertyItem propertyItem)    {        propertyItem.RebuildEditor();    }    private void SetCategoryItemsExpansion(bool isExpanded)    {        if (containerHelper == null ||            containerHelper.ChildrenItemsControl == null ||            !containerHelper.ChildrenItemsControl.HasItems ||            containerHelper.ChildrenItemsControl.Items.Groups == null)        {            return;        }        var groups = containerHelper.ChildrenItemsControl.Items.Groups;        foreach (object item in groups)        {            if (!(item is CollectionViewGroup { Items: not null } collectionViewGroup) ||                collectionViewGroup.Items.All(item => (item is CustomPropertyItem viewGroup) && viewGroup.IsCategoryExpanded == isExpanded))            {                continue;            }            foreach (object item2 in collectionViewGroup.Items)            {                if (item2 is CustomPropertyItem)                {                    ((CustomPropertyItem)item2).IsCategoryExpanded = isExpanded;                }            }        }    }    private void SetCategoryItemsExpansion(string categoryName, bool isExpanded)    {        if (containerHelper == null ||            containerHelper.ChildrenItemsControl == null ||            !containerHelper.ChildrenItemsControl.HasItems ||            containerHelper.ChildrenItemsControl.Items.Groups == null ||            !(containerHelper.ChildrenItemsControl.Items.Groups.FirstOrDefault(x => (x is CollectionViewGroup viewGroup) && viewGroup.Name.Equals(categoryName)) is CollectionViewGroup { Items: not null } collectionViewGroup) ||            collectionViewGroup.Items.All((object item) => (item is CustomPropertyItem viewGroup) && viewGroup.IsCategoryExpanded == isExpanded))        {            return;        }        foreach (object item in collectionViewGroup.Items)        {            if (item is CustomPropertyItem)            {                ((CustomPropertyItem)item).IsCategoryExpanded = isExpanded;            }        }    }    private void SetContainerHelper(ContainerHelperBase containerHelper)    {        if (this.containerHelper != null)        {            this.containerHelper.ClearHelper();        }        this.containerHelper = containerHelper;    }    private void SetSelectedObjects(IList newSelectedObjectsList)    {        ArgumentNullException.ThrowIfNull(newSelectedObjectsList, nameof(newSelectedObjectsList));        var oldListener = selectedObjects as INotifyCollectionChanged;        var newListener = newSelectedObjectsList as INotifyCollectionChanged;        if (oldListener != null)        {            CollectionChangedEventManager.RemoveListener(oldListener, selectedObjectsListener);        }        if (newListener != null)        {            CollectionChangedEventManager.AddListener(newListener, selectedObjectsListener);        }        this.selectedObjects = newSelectedObjectsList;        this.UpdateContainerHelper();    }    private void ValidatePropertyBinding(Binding? value, string propertyName)    {        if (value != null)        {            if (!string.IsNullOrEmpty(value.BindingGroupName))            {                throw new InvalidOperationException("BindingGroupName must be null on " + propertyName);            }            if (value.IsAsync)            {                throw new InvalidOperationException("IsAsync must be false on " + propertyName);            }            if (value.RelativeSource != null)            {                throw new InvalidOperationException("RelativeSource must be null on " + propertyName);            }            if (value.Source != null)            {                throw new InvalidOperationException("Source must be null on " + propertyName);            }        }    }    private void UpdateContainerHelper()    {        ObjectContainerHelperBase? container = null;        if (this.PropertiesSource != null)        {            this.SetContainerHelper(new PropertiesSourceContainerHelper(this, this.PropertiesSource));        }        else if (this.SelectedObjects != null && this.SelectedObjects.Count > 0)        {            container = new ObjectsContainerHelper(this, this.SelectedObjects);        }        else if (this.SelectedObject != null)        {            container = new ObjectContainerHelper(this, this.SelectedObject);        }        else        {            this.SetContainerHelper(new PropertiesContainerHelper(this));        }        ItemsControl? childrenItemsControl = this.containerHelper?.ChildrenItemsControl;        if (container != null)        {            container.ChildrenItemsControl = childrenItemsControl;            container.ObjectsGenerated += this.OnObjectsGenerated;            container.GenerateProperties();        }        else if (this.containerHelper != null)        {            this.FinalizeUpdateContainerHelper(childrenItemsControl);        }    }    private void UpdateDependingPropertyItemEditors(PropertyItem modifiedPropertyItem)    {        if (modifiedPropertyItem == null)        {            return;        }        string? text = (modifiedPropertyItem.DescriptorDefinition != null) ?            modifiedPropertyItem.DescriptorDefinition.PropertyName :            null;        if (string.IsNullOrEmpty(text) ||            modifiedPropertyItem.ParentNode == null ||            modifiedPropertyItem.ParentNode.DependsOnPropertyItemsList.Count == 0)        {            return;        }        foreach (var dependsOnPropertyItems in modifiedPropertyItem.ParentNode.DependsOnPropertyItemsList)        {            if (dependsOnPropertyItems.Key == text)            {                PropertyItem value = dependsOnPropertyItems.Value;                RebuildPropertyItemEditor(value);            }        }    }    private void UpdateThumb()    {        if (dragThumb != null)        {            if (IsCategorized)            {                dragThumb.Margin = new Thickness(6.0, 0.0, 0.0, 0.0);            }            else            {                dragThumb.Margin = new Thickness(-1.0, 0.0, 0.0, 0.0);            }        }    }    /// <summary>    /// Adds a handler for the ClearPropertyItem attached event.    /// </summary>    /// <param name="element">The element to attach the handler.</param>    /// <param name="handler">The handler for the event.</param>    public static void AddClearPropertyItemHandler(UIElement element, PropertyItemEventHandler handler)    {        element.AddHandler(ClearPropertyItemEvent, handler);    }    /// <summary>    /// Adds a handler for the PreparePropertyItem attached event.    /// </summary>    /// <param name="element">The element to attach the handler.</param>    /// <param name="handler">The handler for the event.</param>    public static void AddPreparePropertyItemHandler(UIElement element, PropertyItemEventHandler handler)    {        element.AddHandler(PreparePropertyItemEvent, handler);    }    /// <summary>    /// Removes a handler for the PreparePropertyItem attached event.    /// </summary>    /// <param name="element">The element to attach the handler.</param>    /// <param name="handler">The handler for the event.</param>    public static void RemovePreparePropertyItemHandler(UIElement element, PropertyItemEventHandler handler)    {        element.RemoveHandler(PreparePropertyItemEvent, handler);    }    /// <summary>    /// Removes a handler for the ClearPropertyItem attached event.    /// </summary>    /// <param name="element">The element to attach the handler.</param>    /// <param name="handler">The handler for the event.</param>    public static void RemoveClearPropertyItemHandler(UIElement element, PropertyItemEventHandler handler)    {        element.RemoveHandler(ClearPropertyItemEvent, handler);    }    /// <summary>    /// Raises the PreparePropertyItem attached event.    /// </summary>    /// <param name="source">The element to attach the handler.</param>    /// <param name="propertyItem">The propertyItem for the event.</param>    /// <param name="item">The item for the event.</param>    internal static void RaisePreparePropertyItemEvent(UIElement source, PropertyItemBase propertyItem, object item)    {        source.RaiseEvent(new PropertyItemEventArgs(PreparePropertyItemEvent, source, propertyItem, item));    }    /// <summary>    /// Raises the ClearPropertyItem attached event.    /// </summary>    /// <param name="source">The element to attach the handler.</param>    /// <param name="propertyItem">The propertyItem for the event.</param>    /// <param name="item">The item for the event.</param>    internal static void RaiseClearPropertyItemEvent(UIElement source, PropertyItemBase propertyItem, object item)    {        source.RaiseEvent(new PropertyItemEventArgs(ClearPropertyItemEvent, source, propertyItem, item));    }    private static void OnEditorDefinitionsChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnEditorDefinitionsChanged((EditorDefinitionCollection)e.OldValue, (EditorDefinitionCollection)e.NewValue);        }    }    private static void OnFilterChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnFilterChanged((string)e.OldValue, (string)e.NewValue);        }    }    private static void OnFilterAdvanceChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnFilterAdvanceChanged((PropertyItemFilterCallback?)e.OldValue, (PropertyItemFilterCallback?)e.NewValue);        }    }    private static void OnIsCategorizedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnIsCategorizedChanged((bool)e.OldValue, (bool)e.NewValue);        }    }    private static void OnIsVirtualizingChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnIsVirtualizingChanged((bool)e.OldValue, (bool)e.NewValue);        }    }    private static void OnIsExpandingNonPrimitiveTypesChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnIsExpandingNonPrimitiveTypesChanged((bool)e.OldValue, (bool)e.NewValue);        }    }    private static object OnCoerceCategoryGroupDescription(DependencyObject o, object value)    {        return value;    }    private static void OnCategoryGroupDescriptionChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnCategoryGroupDescriptionChanged((GroupDescription)e.OldValue, (GroupDescription)e.NewValue);        }    }    private static object OnCoerceDefaultEditorDefinition(DependencyObject o, object value)    {        return value;    }    private static void OnNameColumnWidthChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnNameColumnWidthChanged((double)e.OldValue, (double)e.NewValue);        }    }    private static object OnCoercePropertiesSourceChanged(DependencyObject o, object value)    {        return value;    }    private static void OnPropertiesSourceChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnPropertiesSourceChanged((IEnumerable)e.OldValue, (IEnumerable)e.NewValue);        }    }    private static void OnPropertyContainerStyleChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnPropertyContainerStyleChanged((Style)e.OldValue, (Style)e.NewValue);        }    }    private static void OnPropertyDefinitionsChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnPropertyDefinitionsChanged((PropertyDefinitionCollection)e.OldValue, (PropertyDefinitionCollection)e.NewValue);        }    }    private static void OnIsReadOnlyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnIsReadOnlyChanged((bool)e.OldValue, (bool)e.NewValue);        }    }    private static void OnSelectedObjectChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnSelectedObjectChanged(e.OldValue, e.NewValue);        }    }    private static void OnSelectedObjectTypeChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnSelectedObjectTypeChanged((Type)e.OldValue, (Type)e.NewValue);        }    }    private static object OnCoerceSelectedObjectName(DependencyObject o, object baseValue)    {        if (o is PropertyGrid propertyGrid && propertyGrid.SelectedObject is FrameworkElement && string.IsNullOrEmpty((string)baseValue))        {            return "<no name>";        }        return baseValue;    }    private static void OnSelectedObjectNameChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.SelectedObjectNameChanged((string)e.OldValue, (string)e.NewValue);        }    }    private static object OnCoerceSelectedObjectsOverride(DependencyObject sender, object value)    {        ValidateSelectedObjectsCollection((IList)value);        return value;    }    private static void OnSelectedObjectsOverrideChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)    {        ((PropertyGrid)sender).OnSelectedObjectsOverrideChanged((IList)args.OldValue, (IList)args.NewValue);    }    private static void OnSelectedPropertyItemChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)    {        if (o is PropertyGrid propertyGrid)        {            propertyGrid.OnSelectedPropertyItemChanged((PropertyItemBase)e.OldValue, (PropertyItemBase)e.NewValue);        }    }    private static void OnSelectedPropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)    {        if (sender is PropertyGrid propertyGrid)        {            propertyGrid.OnSelectedPropertyChanged(args.OldValue, args.NewValue);        }    }    private static void ValidateSelectedObjectsCollection(IList objectList)    {        if (objectList != null && objectList.Cast<object>().Any((object o) => o == null))        {            throw new InvalidOperationException("The SelectedObjects collection cannot contain any null entries");        }    }}