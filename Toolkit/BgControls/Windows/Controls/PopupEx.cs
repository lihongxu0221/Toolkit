using System;using System.Runtime.InteropServices;using System.Security;using System.Windows;using System.Windows.Controls;using System.Windows.Controls.Primitives;using System.Windows.Input;using System.Windows.Interop;namespace BgControls.Windows.Controls;/// <summary>/// 增强的弹出框控件，支持置顶控制、自动跟随宿主窗口移动以及解决验证模板显示问题./// </summary>public class PopupEx : Popup{    /// <summary>    /// Win32 SetWindowPos 函数的标志选项枚举.    /// </summary>    [Flags]    internal enum SWP    {        /// <summary>如果调用线程不拥有窗口，系统会向拥有窗口的线程发送消息.</summary>        ASYNCWINDOWPOS = 0x4000,        /// <summary>防止生成 WM_SYNCPAINT 消息.</summary>        DEFERERASE = 0x2000,        /// <summary>在窗口周围绘制框架.</summary>        DRAWFRAME = 0x20,        /// <summary>发送 WM_NCCALCSIZE 消息，即使窗口大小未改变.</summary>        FRAMECHANGED = 0x20,        /// <summary>隐藏窗口.</summary>        HIDEWINDOW = 0x80,        /// <summary>不激活窗口.</summary>        NOACTIVATE = 0x10,        /// <summary>丢弃客户区的全部内容.</summary>        NOCOPYBITS = 0x100,        /// <summary>保留当前位置（忽略 x 和 y 参数）.</summary>        NOMOVE = 2,        /// <summary>不改变所有者窗口在 Z 序中的位置主动权.</summary>        NOOWNERZORDER = 0x200,        /// <summary>不重绘更改.</summary>        NOREDRAW = 8,        /// <summary>与 NOOWNERZORDER 相同.</summary>        NOREPOSITION = 0x200,        /// <summary>防止窗口接收 WM_WINDOWPOSCHANGING 消息.</summary>        NOSENDCHANGING = 0x400,        /// <summary>保留当前大小（忽略 cx 和 cy 参数）.</summary>        NOSIZE = 1,        /// <summary>保留当前 Z 序（忽略 hWndInsertAfter 参数）.</summary>        NOZORDER = 4,        /// <summary>显示窗口.</summary>        SHOWWINDOW = 0x40,        /// <summary>置顶标志组合.</summary>        TOPMOST = 0x61B    }    /// <summary>    /// 表示 Win32 的点结构.    /// </summary>    internal struct POINT    {        /// <summary>X 坐标.</summary>        public int x;        /// <summary>Y 坐标.</summary>        public int y;    }    /// <summary>    /// 表示 Win32 的尺寸结构.    /// </summary>    internal struct SIZE    {        /// <summary>宽度.</summary>        public int cx;        /// <summary>高度.</summary>        public int cy;    }    /// <summary>    /// 表示 Win32 的矩形结构.    /// </summary>    internal struct RECT    {        private int left;        private int top;        private int right;        private int bottom;        /// <summary>获取或设置左边界.</summary>        public int Left        {            get => this.left;            set => this.left = value;        }        /// <summary>获取或设置右边界.</summary>        public int Right        {            get => this.right;            set => this.right = value;        }        /// <summary>获取或设置上边界.</summary>        public int Top        {            get => this.top;            set => this.top = value;        }        /// <summary>获取或设置下边界.</summary>        public int Bottom        {            get => this.bottom;            set => this.bottom = value;        }        /// <summary>获取矩形宽度.</summary>        public int Width => this.right - this.left;        /// <summary>获取矩形高度.</summary>        public int Height => this.bottom - this.top;        /// <summary>获取矩形位置.</summary>        public POINT Position => new POINT        {            x = this.left,            y = this.top        };        /// <summary>获取矩形尺寸.</summary>        public SIZE Size => new SIZE        {            cx = this.Width,            cy = this.Height        };        /// <summary>        /// 偏移矩形位置.        /// </summary>        /// <param name="dx">水平偏移.</param>        /// <param name="dy">垂直偏移.</param>        public void Offset(int dx, int dy)        {            this.left += dx;            this.top += dy;            this.right += dx;            this.bottom += dy;        }        /// <summary>        /// 合并两个矩形区域.        /// </summary>        /// <param name="rect1">矩形1.</param>        /// <param name="rect2">矩形2.</param>        /// <returns>合并后的矩形.</returns>        public static RECT Union(RECT rect1, RECT rect2)        {            return new RECT            {                Left = Math.Min(rect1.Left, rect2.Left),                Top = Math.Min(rect1.Top, rect2.Top),                Right = Math.Max(rect1.Right, rect2.Right),                Bottom = Math.Max(rect1.Bottom, rect2.Bottom),            };        }        /// <summary>        /// 比较当前矩形与对象是否相等.        /// </summary>        /// <param name="obj">待比较对象.</param>        /// <returns>是否相等.</returns>        public override bool Equals(object? obj)        {            try            {                if (obj == null || obj is not Rect otherRect)                {                    return false;                }                return (double)this.bottom == otherRect.Bottom && (double)this.left == otherRect.Left && (double)this.right == otherRect.Right && (double)this.top == otherRect.Top;            }            catch (InvalidCastException)            {                return false;            }        }        /// <summary>        /// 获取哈希码.        /// </summary>        /// <returns>哈希码值.</returns>        public override int GetHashCode()        {            return ((this.left << 16) | PopupEx.LOWORD(this.right)) ^ ((this.top << 16) | PopupEx.LOWORD(this.bottom));        }    }    /// <summary>    /// 标识 CloseOnMouseLeftButtonDown 依赖属性.    /// </summary>    public static readonly DependencyProperty CloseOnMouseLeftButtonDownProperty =        DependencyProperty.Register("CloseOnMouseLeftButtonDown", typeof(bool), typeof(PopupEx), new PropertyMetadata(false));    /// <summary>    /// 标识 AllowTopMost 依赖属性.    /// </summary>    public static readonly DependencyProperty AllowTopMostProperty =        DependencyProperty.Register("AllowTopMost", typeof(bool), typeof(PopupEx), new PropertyMetadata(true));    private static readonly nint HWND_TOPMOST = new IntPtr(-1);    private static readonly nint HWND_NOTOPMOST = new IntPtr(-2);    private static readonly nint HWND_TOP = new IntPtr(0);    private static readonly nint HWND_BOTTOM = new IntPtr(1);    private Window? hostWindow;    private bool? appliedTopMost;    /// <summary>    /// Initializes a new instance of the <see cref="PopupEx"/> class.    /// </summary>    public PopupEx()    {        this.Loaded += this.PopupEx_Loaded;        this.Opened += this.PopupEx_Opened;    }    /// <summary>    /// Gets or sets a value indicating whether 是否在按下鼠标左键时关闭弹出框.    /// </summary>    public bool CloseOnMouseLeftButtonDown    {        get => (bool)this.GetValue(CloseOnMouseLeftButtonDownProperty);        set => this.SetValue(CloseOnMouseLeftButtonDownProperty, value);    }    /// <summary>    /// Gets or sets a value indicating whether 是否允许弹出框置顶显示.    /// </summary>    public bool AllowTopMost    {        get => (bool)this.GetValue(AllowTopMostProperty);        set => this.SetValue(AllowTopMostProperty, value);    }    /// <summary>    /// 根据当前设置强制更新弹出框的位置.    /// </summary>    public void RefreshPosition()    {        // 通过微调 HorizontalOffset 强制触发弹出框位置重算逻辑        double currentOffset = this.HorizontalOffset;        this.SetCurrentValue(Popup.HorizontalOffsetProperty, currentOffset + 1.0);        this.SetCurrentValue(Popup.HorizontalOffsetProperty, currentOffset);    }    /// <summary>    /// 当控件加载时，查找并监听宿主窗口的事件.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void PopupEx_Loaded(object? sender, RoutedEventArgs e)    {        if (this.PlacementTarget is FrameworkElement targetElement)        {            this.hostWindow = Window.GetWindow(targetElement);            if (this.hostWindow != null)            {                // 卸载旧事件防止重复监听                this.hostWindow.LocationChanged -= this.HostWindow_SizeOrLocationChanged;                this.hostWindow.SizeChanged -= this.HostWindow_SizeOrLocationChanged;                targetElement.SizeChanged -= this.HostWindow_SizeOrLocationChanged;                this.hostWindow.StateChanged -= this.HostWindow_StateChanged;                this.hostWindow.Activated -= this.HostWindow_Activated;                this.hostWindow.Deactivated -= this.HostWindow_Deactivated;                this.Unloaded -= this.PopupEx_Unloaded;                // 注册监听事件                this.hostWindow.LocationChanged += this.HostWindow_SizeOrLocationChanged;                this.hostWindow.SizeChanged += this.HostWindow_SizeOrLocationChanged;                targetElement.SizeChanged += this.HostWindow_SizeOrLocationChanged;                this.hostWindow.StateChanged += this.HostWindow_StateChanged;                this.hostWindow.Activated += this.HostWindow_Activated;                this.hostWindow.Deactivated += this.HostWindow_Deactivated;                this.Unloaded += this.PopupEx_Unloaded;            }        }    }    /// <summary>    /// 当弹出框打开时，同步置顶状态.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void PopupEx_Opened(object? sender, EventArgs e)    {        this.SetTopmostState(this.hostWindow?.IsActive ?? true);    }    /// <summary>    /// 宿主窗口激活时置顶弹出框.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void HostWindow_Activated(object? sender, EventArgs e)    {        this.SetTopmostState(isTop: true);    }    /// <summary>    /// 宿主窗口失去激活时，根据宿主窗口状态同步置顶状态.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void HostWindow_Deactivated(object? sender, EventArgs e)    {        this.SetTopmostState(this.hostWindow?.Topmost ?? false);    }    /// <summary>    /// 当控件卸载时清理所有注册的事件处理器.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void PopupEx_Unloaded(object? sender, RoutedEventArgs e)    {        if (this.PlacementTarget is FrameworkElement targetElement)        {            targetElement.SizeChanged -= this.HostWindow_SizeOrLocationChanged;        }        if (this.hostWindow != null)        {            this.hostWindow.LocationChanged -= this.HostWindow_SizeOrLocationChanged;            this.hostWindow.SizeChanged -= this.HostWindow_SizeOrLocationChanged;            this.hostWindow.StateChanged -= this.HostWindow_StateChanged;            this.hostWindow.Activated -= this.HostWindow_Activated;            this.hostWindow.Deactivated -= this.HostWindow_Deactivated;        }        this.Unloaded -= this.PopupEx_Unloaded;        this.Opened -= this.PopupEx_Opened;        this.hostWindow = null;    }    /// <summary>    /// 宿主窗口状态改变时的处理逻辑，特别是针对验证占位符的处理.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void HostWindow_StateChanged(object? sender, EventArgs e)    {        if (this.hostWindow != null && this.hostWindow.WindowState != WindowState.Minimized)        {            if (this.PlacementTarget is FrameworkElement targetElement)            {                var holder = targetElement.DataContext as AdornedElementPlaceholder;                if (holder != null && holder.AdornedElement != null)                {                    // 重置验证模板以修复显示异常                    this.PopupAnimation = PopupAnimation.None;                    this.IsOpen = false;                    object errorTemplate = holder.AdornedElement.GetValue(Validation.ErrorTemplateProperty);                    holder.AdornedElement.SetValue(Validation.ErrorTemplateProperty, null);                    holder.AdornedElement.SetValue(Validation.ErrorTemplateProperty, errorTemplate);                }            }        }    }    /// <summary>    /// 宿主尺寸或位置改变时刷新弹出框位置.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void HostWindow_SizeOrLocationChanged(object? sender, EventArgs e)    {        this.RefreshPosition();    }    /// <summary>    /// 使用 Win32 API 设置弹出框的置顶状态.    /// </summary>    /// <param name="isTop">是否置顶.</param>    private void SetTopmostState(bool isTop)    {        isTop &= this.AllowTopMost;        if ((!this.appliedTopMost.HasValue || this.appliedTopMost != isTop) &&            this.Child != null &&            PresentationSource.FromVisual(this.Child) is HwndSource { Handle: var windowHandle } &&            PopupEx.GetWindowRect(windowHandle, out var windowRect))        {            int left = windowRect.Left;            int top = windowRect.Top;            int width = windowRect.Width;            int height = windowRect.Height;            if (isTop)            {                PopupEx.SetWindowPos(windowHandle, HWND_TOPMOST, left, top, width, height, SWP.TOPMOST);            }            else            {                // 通过 Z 序的切换强制取消置顶状态                PopupEx.SetWindowPos(windowHandle, HWND_BOTTOM, left, top, width, height, SWP.TOPMOST);                PopupEx.SetWindowPos(windowHandle, HWND_TOP, left, top, width, height, SWP.TOPMOST);                PopupEx.SetWindowPos(windowHandle, HWND_NOTOPMOST, left, top, width, height, SWP.TOPMOST);            }            this.appliedTopMost = isTop;        }    }    /// <summary>    /// 响应鼠标预览按下事件，若开启配置则关闭弹出框.    /// </summary>    /// <param name="e">鼠标按键事件参数.</param>    protected override void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e)    {        if (this.CloseOnMouseLeftButtonDown)        {            this.IsOpen = false;        }    }    /// <summary>    /// 获取整数的低位字.    /// </summary>    /// <param name="i">整数值.</param>    /// <returns>低位字.</returns>    internal static int LOWORD(int i)    {        return (short)(i & 0xFFFF);    }    /// <summary>    /// 获取窗口矩形区域.    /// </summary>    /// <param name="hWnd">窗口句柄.</param>    /// <param name="lpRect">返回的矩形结构.</param>    /// <returns>操作是否成功.</returns>    [DllImport("user32.dll", SetLastError = true)]    [SecurityCritical]    [return: MarshalAs(UnmanagedType.Bool)]    private static extern bool GetWindowRect(nint hWnd, out RECT lpRect);    /// <summary>    /// 内部 Win32 SetWindowPos 函数.    /// </summary>    [DllImport("user32.dll", EntryPoint = "SetWindowPos", SetLastError = true)]    [SecurityCritical]    [return: MarshalAs(UnmanagedType.Bool)]    private static extern bool _SetWindowPos(nint hWnd, nint hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags);    /// <summary>    /// 安全地设置窗口位置及 Z 序.    /// </summary>    /// <param name="hWnd">窗口句柄.</param>    /// <param name="hWndInsertAfter">Z 序参考句柄.</param>    /// <param name="x">X 坐标.</param>    /// <param name="y">Y 坐标.</param>    /// <param name="cx">宽度.</param>    /// <param name="cy">高度.</param>    /// <param name="uFlags">标志位.</param>    /// <returns>操作是否成功.</returns>    [SecurityCritical]    private static bool SetWindowPos(nint hWnd, nint hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags)    {        return PopupEx._SetWindowPos(hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);    }}