using BgControls.Windows.Attach;namespace BgControls.Windows.Controls;/// <summary>/// 对话框宿主控件，用于管理并显示弹出式对话框./// </summary>[TemplatePart(Name = PopupPartName, Type = typeof(Popup))][TemplatePart(Name = PopupPartName, Type = typeof(ContentControl))][TemplatePart(Name = ContentCoverGridName, Type = typeof(Grid))][TemplateVisualState(GroupName = "PopupStates", Name = OpenStateName)][TemplateVisualState(GroupName = "PopupStates", Name = ClosedStateName)]public class DialogHost : ContentControl{    private const string PopupPartName = "PART_Popup"; // Popup 模板部件名称.    private const string PopupContentPartName = "PART_PopupContentElement"; // Popup 内容元素模板部件名称.    private const string ContentCoverGridName = "PART_ContentCoverGrid"; // 内容覆盖网格模板部件名称.    private const string OpenStateName = "Open"; // 打开状态名称.    private const string ClosedStateName = "Closed"; // 关闭状态名称.    /// <summary>    /// 标识 Identifier 依赖属性.    /// </summary>    public static readonly DependencyProperty IdentifierProperty =        DependencyProperty.Register("Identifier", typeof(object), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 IsOpen 依赖属性.    /// </summary>    public static readonly DependencyProperty IsOpenProperty =        DependencyProperty.Register("IsOpen", typeof(bool), typeof(DialogHost), new FrameworkPropertyMetadata(false, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, IsOpenPropertyChangedCallback));    /// <summary>    /// 标识 Placement 依赖属性.    /// </summary>    public static readonly DependencyProperty PlacementProperty =        DependencyProperty.Register("Placement", typeof(PlacementMode), typeof(DialogHost), new PropertyMetadata(PlacementMode.Center));    /// <summary>    /// 标识 CornerRadius 依赖属性.    /// </summary>    public static readonly DependencyProperty CornerRadiusProperty =        DependencyProperty.Register("CornerRadius", typeof(CornerRadius), typeof(DialogHost), new PropertyMetadata(default(CornerRadius)));    /// <summary>    /// 标识 DialogContent 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogContentProperty =        DependencyProperty.Register("DialogContent", typeof(object), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogContentTemplate 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogContentTemplateProperty =        DependencyProperty.Register("DialogContentTemplate", typeof(DataTemplate), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogContentTemplateSelector 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogContentTemplateSelectorProperty =        DependencyProperty.Register("DialogContentTemplateSelector", typeof(DataTemplateSelector), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogContentStringFormat 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogContentStringFormatProperty =        DependencyProperty.Register("DialogContentStringFormat", typeof(string), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogMargin 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogMarginProperty =        DependencyProperty.Register("DialogMargin", typeof(Thickness), typeof(DialogHost), new PropertyMetadata(default(Thickness)));    /// <summary>    /// 标识 OpenDialogCommandDataContextSource 依赖属性.    /// </summary>    public static readonly DependencyProperty OpenDialogCommandDataContextSourceProperty =        DependencyProperty.Register("OpenDialogCommandDataContextSource", typeof(DialogHostOpenDialogCommandDataContextSource), typeof(DialogHost), new PropertyMetadata(DialogHostOpenDialogCommandDataContextSource.SenderElement));    /// <summary>    /// 标识 CloseOnClickAway 依赖属性.    /// </summary>    public static readonly DependencyProperty CloseOnClickAwayProperty =        DependencyProperty.Register("CloseOnClickAway", typeof(bool), typeof(DialogHost), new PropertyMetadata(false));    /// <summary>    /// 标识 CloseOnClickAwayParameter 依赖属性.    /// </summary>    public static readonly DependencyProperty CloseOnClickAwayParameterProperty =        DependencyProperty.Register("CloseOnClickAwayParameter", typeof(object), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 SnackbarMessageQueue 依赖属性.    /// </summary>    public static readonly DependencyProperty SnackbarMessageQueueProperty =        DependencyProperty.Register("SnackbarMessageQueue", typeof(SnackbarMessageQueue), typeof(DialogHost), new PropertyMetadata(null, SnackbarMessageQueuePropertyChangedCallback));    /// <summary>    /// 标识 PopupStyle 依赖属性.    /// </summary>    public static readonly DependencyProperty PopupStyleProperty =        DependencyProperty.Register("PopupStyle", typeof(Style), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 OverlayBackground 依赖属性.    /// </summary>    public static readonly DependencyProperty OverlayBackgroundProperty =        DependencyProperty.Register("OverlayBackground", typeof(Brush), typeof(DialogHost), new PropertyMetadata(Brushes.Black));    /// <summary>    /// 标识 DialogBackground 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogBackgroundProperty =        DependencyProperty.Register("DialogBackground", typeof(Brush), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogOpenedAttached 附加属性.    /// </summary>    public static readonly DependencyProperty DialogOpenedAttachedProperty =        DependencyProperty.RegisterAttached("DialogOpenedAttached", typeof(DialogOpenedEventHandler), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogOpenedCallback 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogOpenedCallbackProperty =        DependencyProperty.Register("DialogOpenedCallback", typeof(DialogOpenedEventHandler), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogClosingAttached 附加属性.    /// </summary>    public static readonly DependencyProperty DialogClosingAttachedProperty =        DependencyProperty.RegisterAttached("DialogClosingAttached", typeof(DialogClosingEventHandler), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogClosingCallback 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogClosingCallbackProperty =        DependencyProperty.Register("DialogClosingCallback", typeof(DialogClosingEventHandler), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogClosedAttached 附加属性.    /// </summary>    public static readonly DependencyProperty DialogClosedAttachedProperty =        DependencyProperty.RegisterAttached("DialogClosedAttached", typeof(DialogClosedEventHandler), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 标识 DialogClosedCallback 依赖属性.    /// </summary>    public static readonly DependencyProperty DialogClosedCallbackProperty =        DependencyProperty.Register("DialogClosedCallback", typeof(DialogClosedEventHandler), typeof(DialogHost), new PropertyMetadata(null));    /// <summary>    /// 对话框打开时引发的路由事件.    /// </summary>    public static readonly RoutedEvent DialogOpenedEvent =        EventManager.RegisterRoutedEvent("DialogOpened", RoutingStrategy.Bubble, typeof(DialogOpenedEventHandler), typeof(DialogHost));    /// <summary>    /// 对话框关闭前引发的路由事件.    /// </summary>    public static readonly RoutedEvent DialogClosingEvent =        EventManager.RegisterRoutedEvent("DialogClosing", RoutingStrategy.Bubble, typeof(DialogClosingEventHandler), typeof(DialogHost));    /// <summary>    /// 对话框关闭后引发的路由事件.    /// </summary>    public static readonly RoutedEvent DialogClosedEvent =        EventManager.RegisterRoutedEvent("DialogClosed", RoutingStrategy.Bubble, typeof(DialogClosedEventHandler), typeof(DialogHost));    /// <summary>    /// 打开对话框的路由命令.    /// </summary>    public static readonly RoutedCommand OpenDialogCommand;    /// <summary>    /// 关闭对话框的路由命令.    /// </summary>    public static readonly RoutedCommand CloseDialogCommand;    /// <summary>    /// 存储当前已加载的 DialogHost 实例弱引用集合.    /// </summary>    private static readonly HashSet<WeakReference<DialogHost>> LoadedInstances;    static DialogHost()    {        OpenDialogCommand = new RoutedCommand();        CloseDialogCommand = new RoutedCommand();        LoadedInstances = new HashSet<WeakReference<DialogHost>>();        DefaultStyleKeyProperty.OverrideMetadata(typeof(DialogHost), new FrameworkPropertyMetadata(typeof(DialogHost)));    }    private Popup? popup;    private ContentControl? popupContentControl;    private Grid? contentCoverGrid;    private IInputElement? restoreFocusDialogClose;    private DialogOpenedEventHandler? asyncShowOpenedEventHandler;    private DialogClosingEventHandler? asyncShowClosingEventHandler;    private DialogClosedEventHandler? asyncShowClosedEventHandler;    private TaskCompletionSource<object?>? dialogTaskCompletionSource;    private DialogOpenedEventHandler? attachedDialogOpenedEventHandler;    private DialogClosingEventHandler? attachedDialogClosingEventHandler;    private DialogClosedEventHandler? attachedDialogClosedEventHandler;    private Action? currentSnackbarMessageQueueUnPauseAction;    /// <summary>    /// Initializes a new instance of the <see cref="DialogHost"/> class.    /// </summary>    public DialogHost()    {        // 绑定弱事件监听，防止内存泄漏.        WeakEventManager<DialogHost, RoutedEventArgs>.AddHandler(this, nameof(this.Loaded), this.OnLoaded);        WeakEventManager<DialogHost, RoutedEventArgs>.AddHandler(this, nameof(this.Unloaded), this.OnUnloaded);        // 注册命令绑定.        this.CommandBindings.Add(new CommandBinding(CloseDialogCommand, this.CloseDialogHandler, this.CloseDialogCanExecute));        this.CommandBindings.Add(new CommandBinding(OpenDialogCommand, this.OpenDialogHandler));    }    /// <summary>    /// Gets or sets 用于标识对话框宿主的标识符.    /// </summary>    public object? Identifier    {        get { return this.GetValue(IdentifierProperty); }        set { this.SetValue(IdentifierProperty, value); }    }    /// <summary>    /// Gets 当前打开对话框的会话对象.    /// </summary>    public DialogSession? CurrentSession { get; private set; }    /// <summary>    /// Gets or sets a value indicating whether 对话框是否处于打开状态.    /// </summary>    public bool IsOpen    {        get { return (bool)this.GetValue(IsOpenProperty); }        set { this.SetValue(IsOpenProperty, value); }    }    /// <summary>    /// Gets or sets 对话框相对于其宿主的位置.    /// </summary>    public PlacementMode Placement    {        get { return (PlacementMode)this.GetValue(PlacementProperty); }        set { this.SetValue(PlacementProperty, value); }    }    /// <summary>    /// Gets or sets 对话框的圆角半径.    /// </summary>    public CornerRadius CornerRadius    {        get { return (CornerRadius)this.GetValue(CornerRadiusProperty); }        set { this.SetValue(CornerRadiusProperty, value); }    }    /// <summary>    /// Gets or sets 对话框显示的内容.    /// </summary>    public object? DialogContent    {        get { return this.GetValue(DialogContentProperty); }        set { this.SetValue(DialogContentProperty, value); }    }    /// <summary>    /// Gets or sets 对话框内容的数据模板.    /// </summary>    public DataTemplate? DialogContentTemplate    {        get { return (DataTemplate)this.GetValue(DialogContentTemplateProperty); }        set { this.SetValue(DialogContentTemplateProperty, value); }    }    /// <summary>    /// Gets or sets 对话框内容的数据模板选择器.    /// </summary>    public DataTemplateSelector? DialogContentTemplateSelector    {        get { return (DataTemplateSelector)this.GetValue(DialogContentTemplateSelectorProperty); }        set { this.SetValue(DialogContentTemplateSelectorProperty, value); }    }    /// <summary>    /// Gets or sets 对话框内容的字符串格式.    /// </summary>    public string? DialogContentStringFormat    {        get { return (string)this.GetValue(DialogContentStringFormatProperty); }        set { this.SetValue(DialogContentStringFormatProperty, value); }    }    /// <summary>    /// Gets or sets 对话框的外边距.    /// </summary>    public Thickness DialogMargin    {        get { return (Thickness)this.GetValue(DialogMarginProperty); }        set { this.SetValue(DialogMarginProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether 打开对话框命令的数据上下文来源.    /// </summary>    public DialogHostOpenDialogCommandDataContextSource OpenDialogCommandDataContextSource    {        get { return (DialogHostOpenDialogCommandDataContextSource)this.GetValue(OpenDialogCommandDataContextSourceProperty); }        set { this.SetValue(OpenDialogCommandDataContextSourceProperty, value); }    }    /// <summary>    /// Gets or sets a value indicating whether 当用户点击对话框以外区域时是否关闭对话框.    /// </summary>    public bool CloseOnClickAway    {        get { return (bool)this.GetValue(CloseOnClickAwayProperty); }        set { this.SetValue(CloseOnClickAwayProperty, value); }    }    /// <summary>    /// Gets or sets 因点击外部区域导致关闭时传递的参数.    /// </summary>    public object? CloseOnClickAwayParameter    {        get { return this.GetValue(CloseOnClickAwayParameterProperty); }        set { this.SetValue(CloseOnClickAwayParameterProperty, value); }    }    /// <summary>    /// Gets or sets 关联的消息条消息队列，以便在显示对话框时暂停通知.    /// </summary>    public SnackbarMessageQueue? SnackbarMessageQueue    {        get { return (SnackbarMessageQueue)this.GetValue(SnackbarMessageQueueProperty); }        set { this.SetValue(SnackbarMessageQueueProperty, value); }    }    /// <summary>    /// Gets or sets 弹出层的样式.    /// </summary>    public Style? PopupStyle    {        get { return (Style)this.GetValue(PopupStyleProperty); }        set { this.SetValue(PopupStyleProperty, value); }    }    /// <summary>    /// Gets or sets 用于遮罩背景的画刷.    /// </summary>    public Brush? OverlayBackground    {        get { return (Brush)this.GetValue(OverlayBackgroundProperty); }        set { this.SetValue(OverlayBackgroundProperty, value); }    }    /// <summary>    /// Gets or sets 对话框自身的背景画刷.    /// </summary>    public Brush? DialogBackground    {        get { return (Brush)this.GetValue(DialogBackgroundProperty); }        set { this.SetValue(DialogBackgroundProperty, value); }    }    /// <summary>    /// Gets or sets 当对话框打开时触发的回调处理程序.    /// </summary>    public DialogOpenedEventHandler? DialogOpenedCallback    {        get { return (DialogOpenedEventHandler)this.GetValue(DialogOpenedCallbackProperty); }        set { this.SetValue(DialogOpenedCallbackProperty, value); }    }    /// <summary>    /// Gets or sets 当对话框正在关闭时触发的回调处理程序.    /// </summary>    public DialogClosingEventHandler? DialogClosingCallback    {        get { return (DialogClosingEventHandler)this.GetValue(DialogClosingCallbackProperty); }        set { this.SetValue(DialogClosingCallbackProperty, value); }    }    /// <summary>    /// Gets or sets 当对话框已关闭时触发的回调处理程序.    /// </summary>    public DialogClosedEventHandler? DialogClosedCallback    {        get { return (DialogClosedEventHandler)this.GetValue(DialogClosedCallbackProperty); }        set { this.SetValue(DialogClosedCallbackProperty, value); }    }    /// <summary>    /// 当对话框打开时引发.    /// </summary>    public event DialogOpenedEventHandler DialogOpened    {        add { this.AddHandler(DialogOpenedEvent, value); }        remove { this.RemoveHandler(DialogOpenedEvent, value); }    }    /// <summary>    /// 当对话框关闭前引发.    /// </summary>    public event DialogClosingEventHandler DialogClosing    {        add { this.AddHandler(DialogClosingEvent, value); }        remove { this.RemoveHandler(DialogClosingEvent, value); }    }    /// <summary>    /// 当对话框关闭后引发.    /// </summary>    public event DialogClosedEventHandler DialogClosed    {        add { this.AddHandler(DialogClosedEvent, value); }        remove { this.RemoveHandler(DialogClosedEvent, value); }    }    /// <summary>    /// 应用控件模板并初始化模板部件.    /// </summary>    public override void OnApplyTemplate()    {        // 清理旧的事件处理程序.        if (this.contentCoverGrid != null)        {            WeakEventManager<Grid, MouseButtonEventArgs>.RemoveHandler(                this.contentCoverGrid,                nameof(this.contentCoverGrid.MouseLeftButtonUp),                this.ContentCoverGridOnMouseLeftButtonUp);        }        // 获取并初始化模板部件.        this.popup = this.GetTemplateChild(PopupPartName) as Popup;        this.popupContentControl = this.GetTemplateChild(PopupContentPartName) as ContentControl;        this.contentCoverGrid = this.GetTemplateChild(ContentCoverGridName) as Grid;        if (this.contentCoverGrid != null)        {            WeakEventManager<Grid, MouseButtonEventArgs>.AddHandler(                this.contentCoverGrid,                nameof(this.contentCoverGrid.MouseLeftButtonUp),                this.ContentCoverGridOnMouseLeftButtonUp);        }        // 切换到正确的视觉状态.        VisualStateManager.GoToState(this, this.GetStateName(), useTransitions: false);        base.OnApplyTemplate();    }    /// <summary>    /// 内部显示对话框逻辑.    /// </summary>    /// <param name="content">显示内容.</param>    /// <param name="openedEventHandler">打开事件处理程序.</param>    /// <param name="closingEventHandler">正在关闭事件处理程序.</param>    /// <param name="closedEventHandler">已关闭事件处理程序.</param>    /// <returns>返回关闭时的参数结果.</returns>    internal async Task<object?> ShowInternalAsync(object content, DialogOpenedEventHandler? openedEventHandler, DialogClosingEventHandler? closingEventHandler, DialogClosedEventHandler? closedEventHandler)    {        if (this.IsOpen)        {            throw new InvalidOperationException("DialogHost 已经处于打开状态.");        }        // 初始化任务源以支持异步返回结果.        this.dialogTaskCompletionSource = new TaskCompletionSource<object?>();        this.AssertTargetableContent();        if (content != null)        {            this.DialogContent = content;        }        // 存储异步调用的回调.        this.asyncShowOpenedEventHandler = openedEventHandler;        this.asyncShowClosingEventHandler = closingEventHandler;        this.asyncShowClosedEventHandler = closedEventHandler;        // 打开对话框.        this.SetCurrentValue(IsOpenProperty, true);        // 等待对话框关闭任务完成.        object? resultValue = await this.dialogTaskCompletionSource.Task;        // 清理回调引用.        this.asyncShowOpenedEventHandler = null;        this.asyncShowClosingEventHandler = null;        this.asyncShowClosedEventHandler = null;        return resultValue;    }    /// <summary>    /// 验证 DialogContent 是否可以被赋值（是否存在绑定冲突）.    /// </summary>    internal void AssertTargetableContent()    {        if (BindingOperations.GetBindingExpression(this, DialogContentProperty) != null)        {            throw new InvalidOperationException("当 DialogContent 已存在绑定时，无法通过 Show 方法传递内容.");        }    }    /// <summary>    /// 尝试将焦点移动到弹出层内部.    /// </summary>    /// <returns>弹出层内容元素.</returns>    internal UIElement? FocusPopup()    {        // 尝试获取弹出层子元素.        UIElement? popupChild = this.popup?.Child ?? this.popupContentControl;        if (popupChild == null)        {            return null;        }        CommandManager.InvalidateRequerySuggested();        // 深度优先查找可获取焦点的可见元素.        UIElement? focusTarget = popupChild.VisualDepthFirstTraversal()                                           .OfType<UIElement>()                                           .FirstOrDefault(uiElement => uiElement.Focusable && uiElement.IsVisible);        if (focusTarget != null)        {            // 在后台优先级异步执行焦点转移，确保 UI 渲染完成.            focusTarget.Dispatcher.InvokeAsync(                () =>                {                    if (focusTarget.Focus())                    {                        focusTarget.MoveFocus(new TraversalRequest(FocusNavigationDirection.First));                    }                },                DispatcherPriority.Background);        }        return popupChild;    }    /// <summary>    /// 内部关闭逻辑处理.    /// </summary>    /// <param name="parameter">关闭参数.</param>    internal void InternalClose(object? parameter)    {        DialogSession sessionInstance = this.CurrentSession ?? throw new InvalidOperationException("DialogHost 当前不存在会话对象.");        sessionInstance.CloseParameter = parameter;        sessionInstance.IsEnded = true;        // 触发正在关闭事件.        DialogClosingEventArgs closingArgs = new DialogClosingEventArgs(sessionInstance, DialogClosingEvent);        this.OnDialogClosing(closingArgs);        this.attachedDialogClosingEventHandler?.Invoke(this, closingArgs);        this.DialogClosingCallback?.Invoke(this, closingArgs);        this.asyncShowClosingEventHandler?.Invoke(this, closingArgs);        // 检查是否在事件处理程序中取消了关闭.        if (closingArgs.IsCancelled)        {            sessionInstance.IsEnded = false;        }        else        {            this.SetCurrentValue(IsOpenProperty, false);        }    }    /// <summary>    /// 预览鼠标按下事件，处理窗口激活.    /// </summary>    /// <param name="e">鼠标事件参数.</param>    protected override void OnPreviewMouseDown(MouseButtonEventArgs e)    {        var ownerWindow = Window.GetWindow(this);        if (ownerWindow != null && !ownerWindow.IsActive && ownerWindow.OwnedWindows.OfType<Window>().All(windowItem => !windowItem.IsActive))        {            ownerWindow.Activate();        }        base.OnPreviewMouseDown(e);    }    /// <summary>    /// 引发 DialogOpened 路由事件.    /// </summary>    /// <param name="eventArgs">事件参数.</param>    protected void OnDialogOpened(DialogOpenedEventArgs eventArgs)    {        this.RaiseEvent(eventArgs);    }    /// <summary>    /// 引发 DialogClosing 路由事件.    /// </summary>    /// <param name="eventArgs">事件参数.</param>    protected void OnDialogClosing(DialogClosingEventArgs eventArgs)    {        this.RaiseEvent(eventArgs);    }    /// <summary>    /// 引发 DialogClosed 路由事件.    /// </summary>    /// <param name="eventArgs">事件参数.</param>    protected void OnDialogClosed(DialogClosedEventArgs eventArgs)    {        this.RaiseEvent(eventArgs);    }    /// <summary>    /// 处理内容覆盖层鼠标抬起事件.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="mouseButtonEventArgs">事件参数.</param>    private void ContentCoverGridOnMouseLeftButtonUp(object? sender, MouseButtonEventArgs mouseButtonEventArgs)    {        // 如果开启了点击外部关闭功能，则执行关闭逻辑.        if (this.CloseOnClickAway && this.CurrentSession != null)        {            this.InternalClose(this.CloseOnClickAwayParameter);        }    }    /// <summary>    /// 处理打开对话框的路由命令.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="executedRoutedEventArgs">事件参数.</param>    private void OpenDialogHandler(object? sender, ExecutedRoutedEventArgs executedRoutedEventArgs)    {        if (executedRoutedEventArgs.Handled)        {            return;        }        // 获取触发源上的附加事件处理程序.        if (executedRoutedEventArgs.OriginalSource is DependencyObject sourceObject)        {            this.attachedDialogOpenedEventHandler = GetDialogOpenedAttached(sourceObject);            this.attachedDialogClosingEventHandler = GetDialogClosingAttached(sourceObject);            this.attachedDialogClosedEventHandler = GetDialogClosedAttached(sourceObject);        }        // 如果命令携带了参数，将其作为对话框内容.        if (executedRoutedEventArgs.Parameter != null)        {            this.AssertTargetableContent();            if (this.popupContentControl != null)            {                this.popupContentControl.DataContext = this.OpenDialogCommandDataContextSource switch                {                    DialogHostOpenDialogCommandDataContextSource.SenderElement => (executedRoutedEventArgs.OriginalSource as FrameworkElement)?.DataContext,                    DialogHostOpenDialogCommandDataContextSource.DialogHostInstance => this.DataContext,                    DialogHostOpenDialogCommandDataContextSource.None => null,                    _ => throw new ArgumentOutOfRangeException(),                };            }            this.DialogContent = executedRoutedEventArgs.Parameter;        }        this.SetCurrentValue(IsOpenProperty, true);        executedRoutedEventArgs.Handled = true;    }    /// <summary>    /// 确定关闭命令是否可以执行.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="canExecuteRoutedEventArgs">事件参数.</param>    private void CloseDialogCanExecute(object sender, CanExecuteRoutedEventArgs canExecuteRoutedEventArgs)    {        canExecuteRoutedEventArgs.CanExecute = this.CurrentSession != null;    }    /// <summary>    /// 处理关闭对话框的路由命令.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="executedRoutedEventArgs">事件参数.</param>    private void CloseDialogHandler(object sender, ExecutedRoutedEventArgs executedRoutedEventArgs)    {        if (!executedRoutedEventArgs.Handled)        {            this.InternalClose(executedRoutedEventArgs.Parameter);            executedRoutedEventArgs.Handled = true;        }    }    /// <summary>    /// 获取当前应处于的视觉状态名称.    /// </summary>    /// <returns>状态名称.</returns>    private string GetStateName()    {        return !this.IsOpen ? ClosedStateName : OpenStateName;    }    /// <summary>    /// 处理 Unloaded 事件，移除静态实例引用.    /// </summary>    private void OnUnloaded(object? sender, RoutedEventArgs routedEventArgs)    {        foreach (WeakReference<DialogHost> instanceRef in LoadedInstances.ToList())        {            if (!instanceRef.TryGetTarget(out var dialogHostInstance) || object.Equals(dialogHostInstance, this))            {                LoadedInstances.Remove(instanceRef);            }        }    }    /// <summary>    /// 处理 Loaded 事件，注册静态实例引用.    /// </summary>    private void OnLoaded(object? sender, RoutedEventArgs routedEventArgs)    {        foreach (WeakReference<DialogHost> instanceRef in LoadedInstances.ToList())        {            if (instanceRef.TryGetTarget(out var dialogHostInstance) && object.Equals(dialogHostInstance, this))            {                return;            }        }        LoadedInstances.Add(new WeakReference<DialogHost>(this));    }    /// <summary>    /// 显示模态对话框.    /// </summary>    /// <param name="content">显示的内容（控件或视图模型）.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static Task<object?> ShowAsync(object content)    {        return ShowAsync(content, null, null);    }    /// <summary>    /// 显示模态对话框并指定打开后的回调.    /// </summary>    /// <param name="content">内容.</param>    /// <param name="openedEventHandler">打开事件回调.</param>    /// <returns>异步任务结果.</returns>    public static Task<object?> ShowAsync(object content, DialogOpenedEventHandler openedEventHandler)    {        return ShowAsync(content, null, openedEventHandler, null);    }    /// <summary>    /// 显示模态对话框并指定关闭前的回调.    /// </summary>    /// <param name="content">内容.</param>    /// <param name="closingEventHandler">关闭前回调.</param>    /// <returns>异步任务结果.</returns>    public static Task<object?> Show(object content, DialogClosingEventHandler closingEventHandler)    {        return ShowAsync(content, null, null, closingEventHandler);    }    /// <summary>    /// 显示模态对话框并指定多个阶段的回调.    /// </summary>    /// <param name="content">显示的内容 (可以是控件或视图模型).</param>    /// <param name="openedEventHandler">允许访问在实例上订阅的打开事件处理程序.</param>    /// <param name="closingEventHandler">允许访问在实例上订阅的关闭前事件处理程序.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static Task<object?> ShowAsync(object content, DialogOpenedEventHandler? openedEventHandler, DialogClosingEventHandler? closingEventHandler)    {        return ShowAsync(content, null, openedEventHandler, closingEventHandler);    }    /// <summary>    /// 显示模态对话框并指定所有生命周期的回调.    /// </summary>    /// <param name="content">显示的内容 (可以是控件或视图模型).</param>    /// <param name="openedEventHandler">允许访问在实例上订阅的打开事件处理程序.</param>    /// <param name="closingEventHandler">允许访问在实例上订阅的关闭前事件处理程序.</param>    /// <param name="closedEventHandler">允许访问在实例上订阅的关闭后事件处理程序.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static Task<object?> ShowAsync(object content, DialogOpenedEventHandler? openedEventHandler, DialogClosingEventHandler? closingEventHandler, DialogClosedEventHandler? closedEventHandler)    {        return ShowAsync(content, null, openedEventHandler, closingEventHandler, closedEventHandler);    }    /// <summary>    /// 使用特定的标识符显示模态对话框.    /// </summary>    /// <param name="content">显示的内容 (可以是控件或视图模型).</param>    /// <param name="dialogIdentifier">用于确定对话框显示位置的 DialogHost 标识符. 通常与 XAML 中设置的标识符匹配. 允许为 null.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static Task<object?> ShowAsync(object content, object dialogIdentifier)    {        return ShowAsync(content, dialogIdentifier, null, null);    }    /// <summary>    /// 使用特定的标识符显示模态对话框并指定打开回调.    /// </summary>    /// <param name="content">显示的内容 (可以是控件或视图模型).</param>    /// <param name="dialogIdentifier">用于确定对话框显示位置的 DialogHost 标识符. 通常与 XAML 中设置的标识符匹配. 允许为 null.</param>    /// <param name="openedEventHandler">允许访问在实例上订阅的打开事件处理程序.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static Task<object?> ShowAsync(object content, object dialogIdentifier, DialogOpenedEventHandler openedEventHandler)    {        return ShowAsync(content, dialogIdentifier, openedEventHandler, null);    }    /// <summary>    /// 使用特定的标识符显示模态对话框并指定关闭前回调.    /// </summary>    /// <param name="content">显示的内容 (可以是控件或视图模型).</param>    /// <param name="dialogIdentifier">用于确定对话框显示位置的 DialogHost 标识符. 通常与 XAML 中设置的标识符匹配. 允许为 null.</param>    /// <param name="closingEventHandler">允许访问在实例上订阅的关闭前事件处理程序.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static Task<object?> ShowAsync(object content, object dialogIdentifier, DialogClosingEventHandler closingEventHandler)    {        return ShowAsync(content, dialogIdentifier, null, closingEventHandler);    }    /// <summary>    /// 使用特定的标识符显示模态对话框，并指定多个阶段的回调.    /// </summary>    /// <param name="content">显示的内容 (可以是控件或视图模型).</param>    /// <param name="dialogIdentifier">用于确定对话框显示位置的 DialogHost 标识符. 通常与 XAML 中设置的标识符匹配. 允许为 null.</param>    /// <param name="openedEventHandler">允许访问在实例上订阅的打开事件处理程序.</param>    /// <param name="closingEventHandler">允许访问在实例上订阅的关闭前事件处理程序.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static Task<object?> ShowAsync(object content, object? dialogIdentifier, DialogOpenedEventHandler? openedEventHandler, DialogClosingEventHandler? closingEventHandler)    {        return ShowAsync(content, dialogIdentifier, openedEventHandler, closingEventHandler, null);    }    /// <summary>    /// 最全参数的静态显示方法，用于根据标识符定位 DialogHost 并显示内容.    /// </summary>    /// <param name="content">显示的内容 (可以是控件或视图模型).</param>    /// <param name="dialogIdentifier">用于确定对话框显示位置的 DialogHost 标识符. 通常与 XAML 中设置的标识符匹配. 允许为 null.</param>    /// <param name="openedEventHandler">允许访问在实例上订阅的打开事件处理程序.</param>    /// <param name="closingEventHandler">允许访问在实例上订阅的关闭前事件处理程序.</param>    /// <param name="closedEventHandler">允许访问在实例上订阅的关闭后事件处理程序.</param>    /// <returns>异步任务结果为关闭对话框时传递的参数.</returns>    public static async Task<object?> ShowAsync(object content, object? dialogIdentifier, DialogOpenedEventHandler? openedEventHandler, DialogClosingEventHandler? closingEventHandler, DialogClosedEventHandler? closedEventHandler)    {        // 验证必填参数.        ArgumentNullException.ThrowIfNull(content, nameof(content));        // 根据标识符查找实例并调用其内部显示方法.        DialogHost targetHost = GetInstance(dialogIdentifier);        return await targetHost.ShowInternalAsync(content, openedEventHandler, closingEventHandler, closedEventHandler);    }    /// <summary>    /// 根据标识符关闭模态对话框.    /// </summary>    /// <param name="dialogIdentifier">标识符.</param>    public static void Close(object? dialogIdentifier)    {        Close(dialogIdentifier, null);    }    /// <summary>    /// 根据标识符关闭模态对话框，并提供关闭参数.    /// </summary>    /// <param name="dialogIdentifier">标识符.</param>    /// <param name="parameter">传递给关闭处理程序的参数.</param>    public static void Close(object? dialogIdentifier, object? parameter)    {        DialogHost targetHost = GetInstance(dialogIdentifier);        DialogSession? activeSession = targetHost.CurrentSession;        if (activeSession != null)        {            activeSession.Close(parameter);            return;        }        throw new InvalidOperationException("对应的 DialogHost 当前未打开.");    }    /// <summary>    /// 获取指定标识符对应的当前对话框会话.    /// </summary>    /// <param name="dialogIdentifier">标识符.</param>    /// <returns>会话对象或 null.</returns>    public static DialogSession? GetDialogSession(object? dialogIdentifier)    {        return GetInstance(dialogIdentifier).CurrentSession;    }    /// <summary>    /// 检查指定标识符的对话框是否处于打开状态.    /// </summary>    /// <param name="dialogIdentifier">标识符.</param>    /// <returns>如果是则返回 true.</returns>    public static bool IsDialogOpen(object? dialogIdentifier)    {        DialogSession? sessionInstance = GetDialogSession(dialogIdentifier);        return sessionInstance != null && !sessionInstance.IsEnded;    }    /// <summary>    /// 根据标识符在加载的实例中查找唯一的 DialogHost 实例.    /// </summary>    /// <param name="dialogIdentifier">标识符.</param>    /// <returns>DialogHost 实例.</returns>    private static DialogHost GetInstance(object? dialogIdentifier)    {        if (LoadedInstances.Count == 0)        {            throw new InvalidOperationException("没有找到已加载的 DialogHost 实例.");        }        List<DialogHost> matchedTargets = new List<DialogHost>();        foreach (WeakReference<DialogHost> instanceRef in LoadedInstances.ToList())        {            if (instanceRef.TryGetTarget(out var dialogInstance))            {                // 处理跨线程访问标识符的情况.                object? instanceId = !dialogInstance.CheckAccess()                    ? dialogInstance.Dispatcher.Invoke(() => dialogInstance.Identifier)                    : dialogInstance.Identifier;                if (object.Equals(dialogIdentifier, instanceId))                {                    matchedTargets.Add(dialogInstance);                }            }            else            {                LoadedInstances.Remove(instanceRef);            }        }        if (matchedTargets.Count == 0)        {            throw new InvalidOperationException($"没有找到标识符匹配 '{dialogIdentifier}' 的 DialogHost 实例.");        }        if (matchedTargets.Count > 1)        {            throw new InvalidOperationException("存在多个标识符相同的 DialogHost。请确保标识符的唯一性，尤其是在涉及多窗口时.");        }        return matchedTargets[0];    }    /// <summary>    /// IsOpen 属性更改后的回调逻辑.    /// </summary>    /// <param name="dependencyObject">宿主对象.</param>    /// <param name="args">更改参数.</param>    private static void IsOpenPropertyChangedCallback(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs args)    {        DialogHost dialogHost = (DialogHost)dependencyObject;        // 控制 Popup 内容的验证显示抑制状态.        if (dialogHost.popupContentControl != null)        {            ValidationAssist.SetSuppress(dialogHost.popupContentControl, !dialogHost.IsOpen);        }        // 执行视觉状态转换动画.        VisualStateManager.GoToState(dialogHost, dialogHost.GetStateName(), !TransitionAssist.GetDisableTransitions(dialogHost));        if (dialogHost.IsOpen)        {            // 对话框打开时的逻辑：暂停消息队列、创建会话、保存焦点等.            dialogHost.currentSnackbarMessageQueueUnPauseAction = dialogHost.SnackbarMessageQueue?.Pause();            dialogHost.CurrentSession = new DialogSession(dialogHost);            Window? parentWindow = Window.GetWindow(dialogHost);            dialogHost.restoreFocusDialogClose = parentWindow != null ? FocusManager.GetFocusedElement(parentWindow) : null;            DialogOpenedEventArgs openedArgs = new DialogOpenedEventArgs(dialogHost.CurrentSession, DialogOpenedEvent);            dialogHost.OnDialogOpened(openedArgs);            dialogHost.attachedDialogOpenedEventHandler?.Invoke(dialogHost, openedArgs);            dialogHost.DialogOpenedCallback?.Invoke(dialogHost, openedArgs);            dialogHost.asyncShowOpenedEventHandler?.Invoke(dialogHost, openedArgs);            // 异步处理焦点移动和视觉刷新.            dialogHost.Dispatcher.BeginInvoke(DispatcherPriority.Background, () =>            {                CommandManager.InvalidateRequerySuggested();                UIElement? childElement = dialogHost.FocusPopup();                if (childElement != null)                {                    Task.Delay(300).ContinueWith(t => childElement.Dispatcher.BeginInvoke(childElement.InvalidateVisual));                }            });            return;        }        // 对话框关闭后的逻辑：清理回调、恢复消息队列、处理关闭事件等.        dialogHost.attachedDialogClosingEventHandler = null;        if (dialogHost.currentSnackbarMessageQueueUnPauseAction != null)        {            dialogHost.currentSnackbarMessageQueueUnPauseAction();            dialogHost.currentSnackbarMessageQueueUnPauseAction = null;        }        object? finalCloseParameter = null;        DialogSession? activeSession = dialogHost.CurrentSession;        if (activeSession != null)        {            DialogClosedEventArgs closedArgs = new DialogClosedEventArgs(activeSession, DialogClosedEvent);            dialogHost.OnDialogClosed(closedArgs);            dialogHost.attachedDialogClosedEventHandler?.Invoke(dialogHost, closedArgs);            dialogHost.DialogClosedCallback?.Invoke(dialogHost, closedArgs);            dialogHost.asyncShowClosedEventHandler?.Invoke(dialogHost, closedArgs);            dialogHost.attachedDialogClosedEventHandler = null;            // 如果会话尚未由于命令手动结束，则在此强制结束.            if (!activeSession.IsEnded)            {                activeSession.Close(activeSession.CloseParameter);            }            if (!activeSession.IsEnded)            {                throw new InvalidOperationException("在 IsOpen 属性设置为 False 后，无法取消对话框关闭逻辑.");            }            finalCloseParameter = activeSession.CloseParameter;            dialogHost.CurrentSession = null;        }        // 通知异步等待任务结果.        dialogHost.dialogTaskCompletionSource?.TrySetResult(finalCloseParameter);        // 尝试恢复之前丢失焦点的元素.        dialogHost.Dispatcher.InvokeAsync(() => dialogHost.restoreFocusDialogClose?.Focus(), DispatcherPriority.Input);    }    /// <summary>    /// 消息队列属性更改后的回调，用于同步暂停/恢复状态.    /// </summary>    private static void SnackbarMessageQueuePropertyChangedCallback(DependencyObject dependencyObject, DependencyPropertyChangedEventArgs args)    {        DialogHost dialogHost = (DialogHost)dependencyObject;        if (dialogHost.currentSnackbarMessageQueueUnPauseAction != null)        {            dialogHost.currentSnackbarMessageQueueUnPauseAction();            dialogHost.currentSnackbarMessageQueueUnPauseAction = null;        }        if (dialogHost.IsOpen)        {            dialogHost.currentSnackbarMessageQueueUnPauseAction = (args.NewValue as SnackbarMessageQueue)?.Pause();        }    }    /// <summary>    /// 设置 DialogOpenedAttached 附加属性.    /// </summary>    /// <param name="element">目标依赖对象.</param>    /// <param name="value">附加属性填充值.</param>    public static void SetDialogOpenedAttached(DependencyObject element, DialogOpenedEventHandler value)    {        ArgumentNullException.ThrowIfNull(element, nameof(element));        element.SetValue(DialogOpenedAttachedProperty, value);    }    /// <summary>    /// 获取 DialogOpenedAttached 附加属性.    /// </summary>    /// <param name="element">目标依赖对象.</param>    /// <returns>返回弹窗打开回调事件.</returns>    public static DialogOpenedEventHandler GetDialogOpenedAttached(DependencyObject element)    {        ArgumentNullException.ThrowIfNull(element, nameof(element));        return (DialogOpenedEventHandler)element.GetValue(DialogOpenedAttachedProperty);    }    /// <summary>    /// 设置 DialogClosingAttached 附加属性.    /// </summary>    /// <param name="element">目标依赖对象.</param>    /// <param name="value">附加属性填充值.</param>    public static void SetDialogClosingAttached(DependencyObject element, DialogClosingEventHandler value)    {        ArgumentNullException.ThrowIfNull(element, nameof(element));        element.SetValue(DialogClosingAttachedProperty, value);    }    /// <summary>    /// 获取 DialogClosingAttached 附加属性.    /// </summary>    /// <param name="element">目标依赖对象.</param>    /// <returns>返回弹窗正在关闭回调事件.</returns>    public static DialogClosingEventHandler GetDialogClosingAttached(DependencyObject element)    {        ArgumentNullException.ThrowIfNull(element, nameof(element));        return (DialogClosingEventHandler)element.GetValue(DialogClosingAttachedProperty);    }    /// <summary>    /// 设置 DialogClosedAttached 附加属性.    /// </summary>    /// <param name="element">目标依赖对象.</param>    /// <param name="value">附加属性填充值.</param>    public static void SetDialogClosedAttached(DependencyObject element, DialogClosedEventHandler value)    {        ArgumentNullException.ThrowIfNull(element, nameof(element));        element.SetValue(DialogClosedAttachedProperty, value);    }    /// <summary>    /// 获取 DialogClosedAttached 附加属性.    /// </summary>    /// <param name="element">目标依赖对象.</param>    /// <returns>返回弹窗关闭回调事件.</returns>    public static DialogClosedEventHandler? GetDialogClosedAttached(DependencyObject element)    {        ArgumentNullException.ThrowIfNull(element, nameof(element));        return (DialogClosedEventHandler?)element.GetValue(DialogClosedAttachedProperty);    }}