using BgCommon.Core;using BgCommon.Prism.Wpf.Authority.Services.Implementation;using BgCommon.Prism.Wpf.Controls;using BgCommon.Prism.Wpf.Controls.ViewModels;using BgCommon.Prism.Wpf.Controls.Windows;using BgCommon.Prism.Wpf.Modules;using BgCommon.Prism.Wpf.Modules.Common.ViewModels;using BgCommon.Prism.Wpf.Modules.Common.Views;using BgCommon.Prism.Wpf.Modules.Logging;using BgCommon.Prism.Wpf.Modules.Module.ViewModels;using BgCommon.Prism.Wpf.Modules.Module.Views;using BgCommon.Prism.Wpf.Modules.Parameters.ViewModels;using BgCommon.Prism.Wpf.Modules.Parameters.Views;using BgCommon.Prism.Wpf.Modules.Role.ViewModels;using BgCommon.Prism.Wpf.Modules.Role.Views;using BgCommon.Prism.Wpf.Modules.User.ViewModels;using BgCommon.Prism.Wpf.Modules.User.Views;using BgControls.Tools;using System.Runtime.Loader;namespace BgCommon.Prism.Wpf;/// <summary>/// BootstrapperBase.cs./// </summary>public abstract class BootstrapperBase : PrismBootstrapper, IDisposable{    private readonly Application app;    private readonly ManualResetEvent splashCreatedEvent = new ManualResetEvent(false);    private readonly string[] moduleDirectories;    private IEventAggregator? eventAggregator;    private SplashScreenView? splashScreenView;    private IModuleManager? moduleManager;    /// <summary>    /// Initializes a new instance of the <see cref="BootstrapperBase"/> class.    /// </summary>    /// <param name="app">入口进程实例.</param>    public BootstrapperBase(Application app)        : base()    {        AppContext.SetSwitch("Switch.MS.Internal.EnableWeakEventMemoryImprovements", true);        AppContext.SetSwitch("Switch.MS.Internal.EnableCleanupSchedulingImprovements", true);        this.moduleDirectories = new string[]        {            "Modules",            "DevLibs",            "Plugins",        };        this.app = app;        this.app.Exit += this.App_Exit;        this.app.DispatcherUnhandledException += this.App_OnDispatcherUnhandledException;        AppDomain.CurrentDomain.UnhandledException += this.CurrentDomain_UnhandledException;        TaskScheduler.UnobservedTaskException += this.TaskScheduler_UnobservedTaskException;        AppDomain.CurrentDomain.AssemblyResolve += this.CurrentDomain_AssemblyResolve;        // AssemblyLoadContext.Default.Resolving += this.Default_Resolving;    }    /// <summary>    /// Gets 模块和插件所在文件夹.    /// </summary>    protected virtual string[]? ModuleDirectories => moduleDirectories;    /// <summary>    /// Gets a value indicating whether gets 是否启用闪屏界面.    /// </summary>    protected virtual bool SplashScreenEnabled => true;    /// <inheritdoc/>    public void Dispose()    {        Dispose(true);        GC.SuppressFinalize(this);    }    /// <summary>    /// 释放资源.    /// </summary>    /// <param name="disposing">是否释放非托管资源.</param>    protected virtual void Dispose(bool disposing)    {        splashCreatedEvent.Dispose();    }    /// <summary>    /// Gets 初始化服务的实例类型,从InitializationServiceBase实现.    /// </summary>    /// <returns>返回 初始化服务的实例类型.</returns>    protected virtual Type GetInitialServiceType() => typeof(InitializationServiceBase);    /// <summary>    /// Gets 全局参数服务.    /// </summary>    /// <returns>返回 初始化全局参数服务</returns>    protected virtual Type GetGlobalVarService() => typeof(DefaultGlobalVarService);    /// <summary>    /// 通过ViewType获取 ViewModelType.    /// </summary>    /// <param name="viewType">View类型.</param>    /// <returns>ViewModelType.</returns>    protected virtual Type? GetViewModelType(Type viewType)    {        if (viewType != null && viewType.Namespace != null)        {            var vmTypeName = $"{viewType.Name}ViewModel";            if (vmTypeName.EndsWith("ViewViewModel", StringComparison.OrdinalIgnoreCase))            {                vmTypeName = vmTypeName.Replace("ViewViewModel", "ViewModel");            }            var @namespace = viewType.Namespace;            if (@namespace.EndsWith(".Views", StringComparison.OrdinalIgnoreCase))            {                @namespace = @namespace.Replace(".Views", ".ViewModels");            }            else if (@namespace.Contains(".Views."))            {                @namespace = @namespace.Replace(".Views.", ".ViewModels.");            }            else            {                @namespace = $"{@namespace}.ViewModels";            }            var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName;            var viewModelName = $"{@namespace}.{vmTypeName}, {viewAssemblyName}";            return Type.GetType(viewModelName);        }        return null;    }    /// <summary>    /// 主程序注入多语言资源.    /// </summary>    /// <param name="builder">多语言构建实例.</param>    protected virtual void RegisterStringLocalizer(LocalizationBuilder builder)    {    }    /// <summary>    /// 注入BgCommon.Prism.Wpf 中所有的应对注入的.    /// </summary>    private async void RegisterRequiredTypesOfBgCommon(IContainerRegistry containerRegistry)    {        if (containerRegistry is not IContainerExtension registry)        {            throw new ArgumentException("containerRegistry is not IContainerExtension");        }        // 0. 初始化Ioc 容器        Ioc.Initialize(registry);        // 1.注入多语言        _ = containerRegistry.AddStringLocalizer(b =>        {            // BgCommon            b.FromResource<BgCommon.Localization.Assets.Localization.TranslationsEnum>(true);            b.FromResource<BgCommon.Localization.Assets.Localization.Translations>(true);            // 主程序多语言资源.            this.RegisterStringLocalizer(b);        });        // 2. 注入全局变量管理服务        Type globalVarServiceType = this.GetGlobalVarService();        if (globalVarServiceType != null)        {            _ = containerRegistry.RegisterSingleton(typeof(IGlobalVarService), globalVarServiceType);        }        else        {            throw new ArgumentException(Ioc.GetString("GlobalVarService不能为空!"));        }        this.eventAggregator = this.Container.Resolve<IEventAggregator>();        // 3. 显示闪窗        if (this.SplashScreenEnabled)        {            this.OnShowSplashScreen(true);        }        // 4. 注入必要的弹窗和视图.        containerRegistry.RegisterDialogWindow<MessageDialogWindow>();        containerRegistry.RegisterDialogWindow<MessageDialogWindowEx>(Constraints.SizeableDialog);        containerRegistry.RegisterDialogWindow<LoginHostWindow>(Constraints.LoginHostWindow);        string title = string.Empty;        // 5.1 全局变量服务初始化.        IGlobalVarService globalVarService = this.Container.Resolve<IGlobalVarService>();        if (globalVarService != null)        {            globalVarService.IsDebugMode = System.IO.File.Exists("debugtest.txt");            // 0. 加载全局配置.            if (await globalVarService.InitializeAsync())            {                title = Ioc.GetString("[框架初始化]");                _ = this.eventAggregator?.OnReport(0, title, Ioc.GetString("基础初始化完成..."));            }        }        // 5.2 注入日志模块        Stopwatch sw = Stopwatch.StartNew();        // BgLoggerFactory.Register(containerRegistry);  // 200+ms        // _ = this.eventAggregator?.OnReport(0, title, Ioc.GetString("日志模块初始化完成，耗时 {Milliseconds} ms", sw.ElapsedMilliseconds));        // sw.Restart();        //        // 5.3 注入权限系统数据库 将 AuthorityDbContext 注册为单例，确保整个应用共享同一个数据库连接实例        this.RegisterAuthorityDbContext(containerRegistry); // 500ms        _ = this.eventAggregator?.OnReport(0, title,            Ioc.GetString("注入数据库服务初始化完成，耗时 {Milliseconds} ms", sw.ElapsedMilliseconds));        sw.Restart();        // 5.4 注入服务        Type initialServiceType = this.GetInitialServiceType();        if (initialServiceType == null || !initialServiceType.IsAssignableTo(typeof(InitializationServiceBase)))        {            throw new ArgumentException(Ioc.GetString("InitialServiceType 不能为空，且必须从InitializationServiceBase派生!"));        }        // 进程初始化服务        _ = containerRegistry.RegisterSingleton(typeof(IInitializationService), initialServiceType);        // 权限管理服务        _ = containerRegistry.RegisterSingleton<IAuthService, AuthService>(); // 权限认证服务        _ = containerRegistry.RegisterSingleton<ILoggingService, DatabaseLoggingService>(); // 记录操作信息        _ = containerRegistry.RegisterSingleton<ILoginService, LoginService>(); // 记住登陆管理服务        _ = containerRegistry.RegisterSingleton<IModuleService, ModuleService>(); // 模块信息管理服务        _ = containerRegistry.RegisterSingleton<IModuleViewService, ModuleViewService>(); // 模块信息管理服务        _ = containerRegistry.RegisterSingleton<IParameterActionService, ParameterActionService>(); // 参数对外服务        _ = containerRegistry            .RegisterSingleton<IParameterPermissionService, ParameterPermissionService>(); // 系统参数权限管理服务.        _ = containerRegistry.RegisterSingleton<IPermissionService, PermissionService>(); // 模块权限和操作权限管理服务.        _ = containerRegistry.RegisterSingleton<IRoleService, RoleService>(); // 用户角色管理服务.        _ = containerRegistry.RegisterSingleton<IUserAccessRightsService, UserAccessRightsService>(); // 用户访问权限服务.        _ = containerRegistry.RegisterSingleton<ISystemParameterService, SystemParameterService>(); // 系统参数管理服务.        _ = containerRegistry.RegisterSingleton<IUserService, UserService>(); // 用户管理服务.        _ = containerRegistry.RegisterSingleton<IFeatureProvider, AuthorityFeatureProvider>(); // 模块视图树结构及操作权限初始化服务        // Prism 视图自动注入服务.        _ = containerRegistry.RegisterSingleton<IRegistrationService, DynamicRegistrationService>();        // 其他服务        _ = containerRegistry.RegisterSingleton<IPluginFinderService, PluginFinderService>(); // 插件查找服务        _ = containerRegistry.RegisterSingleton<IFileDialogService, FileDialogService>(); // 文件对话框服务        _ = containerRegistry.RegisterSingleton<IUIService, WpfUIService>(); // UI线程执行服务        containerRegistry.RegisterDialog<UserLoginView, UserLoginViewModel>();        containerRegistry.RegisterDialog<MessageView, MessageViewModel>();        containerRegistry.RegisterDialog<InputMessageView, InputMessageViewModel>();        containerRegistry.RegisterDialog<InputMessageBoxView, InputMessageBoxViewModel>();        containerRegistry.RegisterDialog<PasswordConfirmationView, PasswordConfirmationViewModel>();        containerRegistry.RegisterDialog<PluginManagerView, PluginManagerViewModel>();        containerRegistry.RegisterDialog<ChangePasswordView, ChangePasswordViewModel>();        containerRegistry.RegisterForNavigation<LoadingView>();        containerRegistry.RegisterForNavigation<DefaultView, DefaultViewModel>();        containerRegistry.RegisterForNavigation<ErrorView, ErrorViewModel>();        containerRegistry.RegisterForNavigation<AuthorityView, AuthorityViewModel>();        // 模块管理        containerRegistry.RegisterForNavigation<ModuleView, ModuleViewModel>();        containerRegistry.RegisterForNavigation<ModuleEditView, ModuleEditViewModel>();        // 用户        containerRegistry.RegisterForNavigation<UserView, UserViewModel>();        containerRegistry.RegisterForNavigation<UserEditView, UserEditViewModel>();        // 角色 和 角色权限        containerRegistry.RegisterForNavigation<RolePermissionView, RolePermissionViewModel>();        // 系统参数        containerRegistry.RegisterForNavigation<SystemParameterView, SystemParameterViewModel>();        containerRegistry.RegisterForNavigation<SystemParameterEditView, SystemParameterEditViewModel>();        containerRegistry.RegisterForNavigation<ConstraintView, ConstraintViewModel>();        containerRegistry.RegisterForNavigation<ConstraintEditView, ConstraintEditViewModel>();        containerRegistry.RegisterForNavigation<ParameterConfigView, ParameterConfigViewModel>();        // 模块权限和操作权限        containerRegistry.RegisterForNavigation<PermissionView, PermissionViewModel>();        containerRegistry.RegisterForNavigation<PermissionEditView, PermissionEditViewModel>();        long millis = sw.ElapsedMilliseconds;        _ = this.eventAggregator?.OnReport(0, title, Ioc.GetString("基础模块初始化完成，耗时 {Milliseconds} ms", millis));        sw.Stop();    }    /// <summary>    /// 初始化权限系统数据库.    /// </summary>    /// <param name="containerRegistry">Ioc容器.</param>    protected void RegisterAuthorityDbContext(IContainerRegistry containerRegistry)    {        // 1. 【指定数据库文件路径】        if (!Directory.Exists(DbFileNames.DbDirectory))        {            _ = Directory.CreateDirectory(DbFileNames.DbDirectory);        }        // 2. 【注册 DbContext 并配置】        //    手动创建和注册 DbContextOptions        //    我们创建一个 DbContextOptionsBuilder，就像在 OnConfiguring 中一样        var optionsBuilder = new DbContextOptionsBuilder<AuthorityDbContextSQLite>();        _ = optionsBuilder.UseSqlite(DbFileNames.ConnectionString);        // 3. 【在Prism中注册 DbContext】        //    我们使用 RegisterInstance 方法将【配置好】的 options 对象注册为一个单例。        //    这样，所有需要 DbContextOptions 的地方都能获取到它。        _ = containerRegistry.RegisterInstance(optionsBuilder.Options);        // 然后，我们将 DbContext 本身注册为【瞬时】的。        //    这意味着每次从容器请求 AuthorityDbContextSQLite 时，都会创建一个新实例。        //    Prism 的默认注册行为就是瞬时的，所以我们直接注册即可。        _ = containerRegistry.Register<AuthorityDbContextSQLite>();        _ = containerRegistry.Register(typeof(IRepository<>), typeof(EFRepository<>));        return;        // --- 数据库自动迁移与创建 ---        // 1. 【关键】执行自动迁移        try        {            // 从Prism容器获取底层的 DryIoc 容器            // Prism.DryIoc 的 IContainerExtension.GetContainer() 返回的是 IContainer (DryIoc)            DryIoc.IContainer dryIocContainer = containerRegistry.GetContainer();            // 创建一个临时的依赖注入作用域            using (IResolverContext scope = dryIocContainer.OpenScope())            {                // 从这个临时的作用域中解析出 DbContext                // DryIoc 的作用域本身就是一个解析器 (IResolver)                AuthorityDbContextSQLite dbContext = scope.Resolve<AuthorityDbContextSQLite>();                // 我们将把EF Core的“确保数据库存在”和“应用迁移”这两个行为分离开来。                // Database.EnsureCreated(): 这个方法会检查数据库是否存在。如果不存在，它会根据当前的C#模型直接创建数据库，但它完全忽略 Migrations 文件夹。它是一个“一次性快照式”的创建方法。                // Database.CanConnect(): 这是一个更轻量级的方法，它只尝试与数据库建立一个连接，来判断数据库文件（对于SQLite）或服务器是否可访问。它不关心数据库的结构是否与模型匹配。                // Database.GetPendingMigrations(): 这个方法会返回一个尚未被应用到数据库的迁移名称列表。                // Database.Migrate(): 应用所有挂起的迁移。                // ----------------------------------------------------------------------------------                // 生成您的第一个迁移文件(如果还没做)                //     在使用 Migrate() 之前，您必须至少有一个迁移文件。                //     确保工具已安装: 在您的数据层项目（包含DbContext的那个）中，确保已添加 NuGet 包 Microsoft.EntityFrameworkCore.Tools。                //     打开包管理器控制台: 在 Visual Studio 中，选择 视图 -> 其他窗口->包管理器控制台。                //     设置默认项目: 在控制台的“默认项目”下拉框中，选择包含您的 AuthorityDbContextSQLite 的项目。                //     运行命令: 在控制台中输入以下命令并回车：                //              Add-Migration InitialCreate                //  执行成功后，您的项目中会出现一个新的 Migrations 文件夹，里面包含了 _InitialCreate.cs 和一个 ...Snapshot.cs 文件。这些文件就是您数据库的“蓝图”。                //  以后每次修改实体模型，您都需要重复此步骤，例如 Add-Migration AddNewPropertyToUser。                // 这行代码将自动应用所有挂起的迁移，如果数据库不存在，则会先创建它。                // Migrate() 会检查数据库是否存在:                // - 如果数据库不存在，它会自动创建数据库，并将所有已生成的迁移按顺序一次性应用，效果等同于 EnsureCreated()。                // - 如果数据库已存在，它会检查哪些迁移尚未被应用，然后只执行那些新的迁移来更新数据库结构。                // - 如果数据库已经是最新版，它什么也不做。                // 步骤 1: 检查数据库文件是否存在。                // 对于 SQLite, 连接字符串 "Data Source=path/to/db" 中的路径就是文件路径。                var connectionString = DbFileNames.ConnectionString; // dbContext.Database.GetConnectionString();                var dataSource = new Microsoft.Data.Sqlite.SqliteConnectionStringBuilder(connectionString).DataSource;                if (!File.Exists(dataSource))                {                    // 路径 A: 数据库文件不存在                    // 调用 EnsureCreated()。它会:                    // 1. 创建数据库文件。                    // 2. 根据当前的 C# 模型创建所有表。                    // 3. 执行 OnModelCreating 中的 HasData 来植入种子数据。                    // 注意：它【不会】创建 __EFMigrationsHistory 表，因为它不使用迁移系统。                    _ = dbContext.Database.EnsureCreated();                    LogRun.Info($"数据库不存在，已根据当前模型创建于: {dataSource}");                }                else                {                    // 路径 B: 数据库文件已存在                    // 调用 Migrate()。它会:                    // 1. 检查 __EFMigrationsHistory 表。                    // 2. 应用所有尚未被记录的、新的迁移。                    // 3. 如果没有新的迁移，它什么也不做。                    var pendingMigrations = dbContext.Database.GetPendingMigrations().ToList();                    if (pendingMigrations.Count != 0)                    {                        LogRun.Info($"数据库已存在，发现挂起的迁移: {string.Join(", ", pendingMigrations)}。正在应用...");                        dbContext.Database.Migrate();                        LogRun.Info("迁移应用完成。");                    }                }            }        }        catch (Exception ex)        {            // 在生产环境中，迁移失败是一个严重问题，需要被记录和处理。            // 例如，弹出一个错误框告知用户，并终止应用程序。            LogRun.Error(ex, "数据库迁移失败！应用程序无法启动。");            _ = MessageBox.Show($"数据库初始化或更新失败，应用程序无法启动。\n错误: {ex.Message}", "严重错误", MessageBoxButton.OK,                MessageBoxImage.Error);            // 终止应用程序            Application.Current.Shutdown(-1);            return; // 确保在Shutdown后，后续代码不再执行        }        // --- 数据库配置结束 ---    }    /// <inheritdoc/>    protected override void RegisterRequiredTypes(IContainerRegistry containerRegistry)    {        base.RegisterRequiredTypes(containerRegistry);        // 注入弹窗服务.        _ = containerRegistry.Register<IDialogService, MaterialDialogService>();        this.RegisterRequiredTypesOfBgCommon(containerRegistry);        this.moduleManager = this.Container.Resolve<IModuleManager>();        if (this.moduleManager != null)        {            this.moduleManager.LoadModuleCompleted += ModuleManager_LoadModuleCompleted;        }    }    /// <inheritdoc/>    protected override async void OnInitialized()    {        bool isFaulted = false;        IInitializationService? initService = null;        try        {            // 1.初始化开始前调用            if (!await this.OnInitializedStarted())            {                isFaulted = true;                return;            }            // 获取初始化服务            initService = Container.Resolve<IInitializationService>();            // 2.加载其他相关的必要数据            if (!await initService.RunAsync())            {                isFaulted = true;                return;            }            this.OnCloseSplashScreen();            // 在初始化完成后关闭启动画面并显示主窗口            Application.Current.Dispatcher.Invoke(() =>            {                // 显示主窗口                if (Shell is Window mainWindow)                {                    // Application.Current.MainWindow = mainWindow;                    // this.OnCloseSplashScreen();                    mainWindow.Show();                }            });        }        catch (Exception ex)        {            isFaulted = true;            // 记录日志            LogDialog.Error(ex);        }        finally        {            if (isFaulted)            {                OnCloseSplashScreen();                // 释放已加载的系统资源                if (initService != null)                {                    initService.Dispose();                }                // 初始化失败，关闭应用程序                Application.Current.Shutdown();            }            if (this.moduleManager != null)            {                this.moduleManager.LoadModuleCompleted -= ModuleManager_LoadModuleCompleted;            }            this.OnInitializedCompleted(isFaulted);        }    }    /// <summary>    /// 初始化开始前调用.    /// </summary>    /// <returns>返回是否成功.</returns>    protected virtual Task<bool> OnInitializedStarted()    {        return Task.FromResult(true);    }    /// <summary>    /// 初始化完成后调用.    /// </summary>    /// <param name="isFault">是否发生异常.</param>    protected virtual void OnInitializedCompleted(bool isFault)    {    }    /// <inheritdoc/>    protected override IModuleCatalog CreateModuleCatalog()    {        var path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);        List<IModuleCatalogItem> components = new List<IModuleCatalogItem>();        if (ModuleDirectories != null)        {            foreach (var dir in ModuleDirectories)            {                string folder = $"{path}\\{dir}";                if (Directory.Exists(folder))                {                    var dirCatelog = new DirectoryModuleCatalog() { ModulePath = folder };                    try                    {                        // 初始化目录模块目录 其中一个加载异常也会全失败                        dirCatelog.Initialize();                    }                    catch (Exception ex)                    {                        string msg = ex.ToString() + "\r\n";                        // if (ex.InnerException != null)                        // {                        //     msg += ex.InnerException.ToString();                        // }                        _ = MessageBox.Show($"无法加载插件模块." + $"Folder:{folder}" + "\r\n" + msg);                        Environment.Exit(0);                    }                    components.AddRange(dirCatelog.Items);                }                else                {                    Console.WriteLine($"{folder} not found");                }            }        }        var catelog = new ModuleCatalog();        foreach (IModuleCatalogItem com in components)        {            catelog.Items.Add(com);        }        return catelog;    }    /// <inheritdoc/>    protected override void ConfigureViewModelLocator()    {        base.ConfigureViewModelLocator();        // 默认获取View 的VM的解决方案        ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver(this.GetViewModelType);    }    private void OnShowSplashScreen(bool isUseThread)    {        if (isUseThread)        {            // 加载界面            Thread thread = new Thread(o =>            {                // 创建启动画面                this.splashScreenView = new SplashScreenView()                {                    DataContext = this.Container.Resolve<SplashScreenViewModel>(),                    ShowInTaskbar = true,                    WindowStartupLocation = WindowStartupLocation.CenterScreen,                };                this.splashScreenView.Closed += (d, k) =>                {                    // 当窗口关闭后马上结束消息循环                    // Dispatcher.ExitAllFrames();                };                WindowHelper.SetWindowToForeground(this.splashScreenView);                _ = this.splashCreatedEvent.Set(); // 通知主线程，启动界面已经创建完毕                Dispatcher.Run(); // 启动消息循环            });            thread.SetApartmentState(ApartmentState.STA);            thread.IsBackground = true;            thread.Start();            // 等待，直到启动界面线程发出“已创建”的信号            _ = this.splashCreatedEvent.WaitOne();        }        else        {            // 创建启动画面            this.splashScreenView = new SplashScreenView()            {                DataContext = this.Container.Resolve<SplashScreenViewModel>(),                ShowInTaskbar = true,                WindowStartupLocation = WindowStartupLocation.CenterScreen,            };            WindowHelper.SetWindowToForeground(this.splashScreenView);        }    }    private void OnCloseSplashScreen()    {        // 任务完成，现在关闭启动界面        // 确保 splashScreen 不为 null，然后通过它的Dispatcher来调用它的Close方法        if (splashScreenView != null)        {            // 4. 这是最关键的修改：            // 使用 splashScreen 自己的 Dispatcher 来安全地调用它自己的 Close 方法。            splashScreenView.Dispatcher.Invoke(splashScreenView.Close);        }    }    private void ModuleManager_LoadModuleCompleted(object? sender, LoadModuleCompletedEventArgs e)    {        if (e.ModuleInfo != null)        {            string title = Ioc.GetString("[框架初始化]");            string message = Ioc.GetString("模块 {ModuleName} 加载完成。。。。。。", e.ModuleInfo.ModuleName);            _ = eventAggregator?.OnReport(0, title, message);            LogRun.Debug("{0}{1}", title, message);        }    }    /// <summary>    /// 进程推出.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">事件参数.</param>    private void App_Exit(object sender, ExitEventArgs e)    {        IInitializationService? initService = Container?.Resolve<IInitializationService>();        if (initService != null)        {            initService.Dispose();        }    }    /// <summary>    /// 处理程序集解析失败事件，尝试手动加载缺失的程序集.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="args">程序集解析事件参数.</param>    /// <returns>已加载的程序集，若未能加载则返回 null.</returns>    private Assembly? CurrentDomain_AssemblyResolve(object? sender, ResolveEventArgs args)    {        // AssemblyName assemblyName = new AssemblyName(args.Name);        // try        // {        //     ////Assembly assembly = Encryption.LoadAssembly(AppDomain.CurrentDomain.BaseDirectory + assemblyName.Name);        //     //bool flag = assembly != null;        //     //if (flag)        //     //{        //     //    return assembly;        //     //}        //     string text = Environment.CurrentDirectory + "\\" + assemblyName.Name + ".dll";        //     Console.WriteLine(text);        //     bool flag2 = File.Exists(text);        //     if (flag2)        //     {        //         return Assembly.LoadFrom(text);        //     }        // }        // catch (Exception ex)        // {        //     System.Windows.MessageBox.Show(assemblyName.Name + ex.ToString());        // }        return null;    }    /// <summary>    /// 处理程序集解析失败事件，尝试手动加载缺失的程序集.    /// </summary>    /// <param name="context">上下文.</param>    /// <param name="assemblyName">程序名称.</param>    /// <returns>已加载的程序集，若未能加载则返回 null.</returns>    private Assembly? Default_Resolving(AssemblyLoadContext context, AssemblyName assemblyName)    {        if (!Directory.Exists(FileNames.ScriptRefVisionLibsPath))        {            _ = Directory.CreateDirectory(FileNames.ScriptRefVisionLibsPath);        }        if (!Directory.Exists(FileNames.ScriptRefMotionLibsPath))        {            _ = Directory.CreateDirectory(FileNames.ScriptRefMotionLibsPath);        }        if (assemblyName.FullName.EndsWith("ContentType=WindowsRuntime", StringComparison.OrdinalIgnoreCase))        {            return null;        }        string dllName = $"{assemblyName.Name}.dll";        string exeName = $"{assemblyName.Name}.exe";        if (IfExistFile(dllName, out string assemblyPath) || IfExistFile(exeName, out assemblyPath))        {            if (!string.IsNullOrEmpty(assemblyPath))            {                // 使用LoadFromAssemblyPath来加载程序集                return context.LoadFromAssemblyPath(assemblyPath);            }        }        return null;    }    /// <summary>    /// 处理应用程序域中的未处理异常.    /// </summary>    /// <remarks>    /// 当应用程序域中引发未处理异常时调用此方法.    /// 记录异常详细信息并执行必要操作, 如生成崩溃转储并通知相应的错误处理机制.    /// 如果异常为致命异常, 会进行额外的日志记录和错误处理.    /// </remarks>    /// <param name="sender">未处理异常事件的源, 通常为发生异常的 <see cref="AppDomain"/>.</param>    /// <param name="e">包含未处理异常信息的 <see cref="UnhandledExceptionEventArgs"/>, 包括异常对象和应用程序是否终止.</param>    private async void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)    {        StringBuilder stringBuilder = new StringBuilder();        bool isTerminating = e.IsTerminating;        if (isTerminating)        {            _ = stringBuilder.Append(                "A fatal error has occurred in the programme and it will terminate, please contact the developer!\n");        }        _ = stringBuilder.Append("Catching unhandled exceptions:");        bool flag = e.ExceptionObject is Exception;        if (flag)        {            _ = stringBuilder.Append(((Exception)e.ExceptionObject).ToString());        }        else        {            _ = stringBuilder.Append(e.ExceptionObject);        }        LogRun.Error(stringBuilder.ToString());        // Dump        // BG.Utility.Helper.MiniDumpHelper.TryDump(AppDomain.CurrentDomain.BaseDirectory + $"Dumps\\软件奔溃_{DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss")}.dmp");        bool isTerminating2 = e.IsTerminating;        if (isTerminating2)        {            if (e.ExceptionObject is Exception ex)            {                LogRun.Fatal(ex);            }            _ = await Ioc.ErrorAsync(stringBuilder.ToString());        }    }    /// <summary>    /// 处理 WPF Dispatcher 未处理异常事件.    /// 捕获 UI 线程未处理异常, 记录日志并根据异常类型决定是否终止或忽略.    /// 对特定 COMException 错误码进行特殊处理, 其余异常记录详细信息并通知.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">包含异常信息的 DispatcherUnhandledExceptionEventArgs.</param>    private async void App_OnDispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)    {        try        {            if (e.Exception != null)            {                // 特定 COMException 错误码处理.                if (e.Exception is COMException ex && ex != null && ex.ErrorCode == -2147221040)                {                    e.Handled = true;                    return;                }                else if (e.Exception?.InnerException is COMException ex_ && ex_ != null && ex_.ErrorCode == -2147221040)                {                    e.Handled = true;                    return;                }                e.Handled = true;                // 针对包含"The attached property"的异常进行特殊日志记录.                bool flag = e.Exception?.ToString().Contains("The attached property") ?? false;                if (flag)                {                    string text =                        $"Catch unhandled exceptions:\r\n{e.Exception?.ToString()}\r\n{e.Exception?.StackTrace}";                    LogRun.Error(text);                    _ = await Ioc.WarnAsync(text);                }            }        }        catch (Exception ex)        {            // 捕获处理异常时自身抛出的异常, 记录并通知.            string text =                "A fatal error has occurred in the programme and it will terminate, please contact the developer!" +                "\r\n" + ex.ToString() + "\r\n" + e.Exception.StackTrace;            LogRun.Error(text);            _ = await Ioc.WarnAsync(text);        }    }    /// <summary>    /// 处理Task调度时产生的未处理的异常.    /// </summary>    /// <param name="sender">事件源.</param>    /// <param name="e">包含异常信息的 UnobservedTaskExceptionEventArgs.</param>    private async void TaskScheduler_UnobservedTaskException(object? sender, UnobservedTaskExceptionEventArgs e)    {        string text = "Catching unhandled exceptions in the thread:" + "\r\n" + e.Exception.ToString() + "\r\n" +                      e.Exception.StackTrace;        LogRun.Error(text);        e.SetObserved();        _ = await Ioc.ErrorAsync(text);    }    /// <summary>    /// 判断文件是否存在.    /// </summary>    /// <param name="assembleName">程序集名称.</param>    /// <param name="assemblyPath">输出存在的程序集路径.</param>    /// <returns>返回文件是否存在.</returns>    protected static bool IfExistFile(string assembleName, out string assemblyPath)    {        assemblyPath = string.Empty;        try        {            string[] files = Directory.GetFiles(FileNames.AppRootPath, assembleName);            if (files.Length > 0)            {                assemblyPath = files[0];                return true;            }        }        catch (Exception ex)        {            LogRun.Error(ex);        }        return false;    }}/// <summary>/// BootstrapperBase扩展方法./// </summary>public static class BootstrapperBaseExtension{    private static double currentProgress;    /// <summary>    /// Gets or sets 当前进度.    /// </summary>    internal static double CurrentProgress    {        get => currentProgress;        set => currentProgress = Math.Clamp(value, 0.0, 100.0);    }    /// <summary>    /// 上报进度信息到UI线程.    /// </summary>    /// <param name="eventAggregator">消息通知.</param>    /// <param name="progress">进度.</param>    /// <param name="title">标题.</param>    /// <param name="content">内容.</param>    /// <returns>返回当前进度.</returns>    public static double OnReport(this IEventAggregator eventAggregator, double progress, string title, string content)    {        if (CurrentProgress > progress)        {            progress = CurrentProgress;        }        CurrentProgress = progress;        string message = $"Progress: {CurrentProgress}, Title: {title}, Content: {content}";        Trace.WriteLine(message);        LogRun.Trace(message);        eventAggregator?.Publish<(double, string, string)>((progress, title, content));        return currentProgress;    }    /// <summary>    /// 上报进度信息到UI线程 异步.    /// </summary>    /// <param name="eventAggregator">消息通知.</param>    /// <param name="progress">进度.</param>    /// <param name="title">标题.</param>    /// <param name="content">内容.</param>    /// <returns>返回当前进度.</returns>    public static async Task<double> OnReportAsync(this IEventAggregator eventAggregator, double progress, string title,        string content)    {        return await Task.Run(() => eventAggregator.OnReport(progress, title, content));    }}