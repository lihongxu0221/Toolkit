using BgCommon.Core.Models;using BgCommon.Prism.Wpf.MVVM;using BgLogger;using ToolkitDemo.Models;namespace ToolKitDemo.Services;/// <summary>/// 监控服务的实现./// </summary>internal partial class MonitoringService : ViewModelBase, IMonitoringService, IDisposable{    private readonly SystemRealTimeStatus systemStatus = new SystemRealTimeStatus();    private readonly AutoResetEvent wakeUpSignal = new AutoResetEvent(false);    private readonly object syncLock = new object();    private CancellationTokenSource? cancellationTokenSource;    private Task? monitoringTask;    private MonitoringTarget currentTargets = MonitoringTarget.None;    private DateTime serviceStartTime;    // --- 用于不同频率调度的成员 ---    private const int AppStatusIntervalMs = 500;    private const int DeviceStatusIntervalMs = 5000; // 5 秒    private const int RunningStatusIntervalMs = 100;   // 基础循环频率    private long lastAppStatusCheckTicks;    private long lastDeviceStatusCheckTicks;    /// <summary>    /// Initializes a new instance of the <see cref="MonitoringService"/> class.    /// </summary>    /// <param name="container">注入的Ioc容器.</param>    /// <param name="managers">注入的设备列表.</param>    /// <param name="systemStatus">注入的系统实时状态单例.</param>    public MonitoringService(        IContainerExtension container,        SystemRealTimeStatus systemStatus)        : base(container)    {        this.systemStatus = systemStatus;    }    /// <inheritdoc/>    public SystemRealTimeStatus SystemStatus => this.systemStatus;    /// <inheritdoc/>    public MonitoringTarget CurrentTargets => this.currentTargets;    /// <inheritdoc/>    public void Dispose()    {        // 等待任务完成        this.StopAsync().Wait();        // 释放非托管资源        this.wakeUpSignal.Dispose();        GC.SuppressFinalize(this);    }    /// <inheritdoc/>    public async Task RefreshDeviceListAsync()    {        try        {            await Task.Delay(0);        }        catch (Exception ex)        {            LogRun.Error(ex, "刷新设备列表时发生错误。");        }    }    /// <inheritdoc/>    public Task<OperateResult> StartAsync()    {        if (this.monitoringTask != null && !this.monitoringTask.IsCompleted)        {            return Task.FromResult(OperateResult.ToFail(this.GetString("监控服务已在运行中")));        }        this.cancellationTokenSource = new CancellationTokenSource();        var token = this.cancellationTokenSource.Token;        this.serviceStartTime = DateTime.Now;        this.monitoringTask = Task.Run(async () => await this.MonitoringLoop(token), token);        return Task.FromResult(OperateResult.ToSuccess(0, this.GetString("监控服务已成功启动")));    }    /// <inheritdoc/>    public async Task<OperateResult> StopAsync()    {        if (this.cancellationTokenSource == null || this.cancellationTokenSource.IsCancellationRequested)        {            return OperateResult.ToFail(this.GetString("监控服务未运行"));        }        lock (this.syncLock)        {            this.currentTargets = MonitoringTarget.None;        }        this.cancellationTokenSource.Cancel();        this.wakeUpSignal.Set();        if (this.monitoringTask != null)        {            await this.monitoringTask;        }        this.cancellationTokenSource.Dispose();        this.monitoringTask = null;        this.cancellationTokenSource = null;        return OperateResult.ToSuccess(0, this.GetString("监控服务已成功停止"));    }    /// <inheritdoc/>    public Task<OperateResult> StartMonitoringAsync(MonitoringTarget target)    {        if (this.monitoringTask == null || this.monitoringTask.IsCompleted)        {            return Task.FromResult(OperateResult.ToFail(this.GetString("监控服务尚未启动，请先调用 StartAsync")));        }        lock (this.syncLock)        {            this.currentTargets |= target;        }        this.wakeUpSignal.Set();        return Task.FromResult(OperateResult.ToSuccess(0, this.GetString("已开启 {Target} 监控", target)));    }    /// <inheritdoc/>    public Task<OperateResult> StopMonitoringAsync(MonitoringTarget target)    {        // 使用按位与（&）和按位非（~）运算移除监控目标        lock (this.syncLock)        {            this.currentTargets &= ~target;        }        return Task.FromResult(OperateResult.ToSuccess(0, $"已关闭 {target} 监控。"));    }    private async Task MonitoringLoop(CancellationToken token)    {        while (!token.IsCancellationRequested)        {            // 决定是否需要等待            bool shouldWait = false;            lock (this.syncLock)            {                if (this.currentTargets == MonitoringTarget.None)                {                    // 如果没有监控目标，则进入睡眠等待信号                    shouldWait = true;                    // 醒来后重置计时器，以避免立即触发所有检查                    long initialTicks = Environment.TickCount64;                    this.lastAppStatusCheckTicks = initialTicks;                    this.lastDeviceStatusCheckTicks = initialTicks;                }            }            if (token.IsCancellationRequested)            {                break;            }            if (shouldWait)            {                // 因为锁已被释放，所以调用 StopAsync 的线程现在可以自由地获取锁。                this.wakeUpSignal.WaitOne();                // 在被唤醒后，最好立即检查是否是因为取消操作。                if (token.IsCancellationRequested)                {                    break;                }                // 在被唤醒后（通常是 StartMonitoringAsync 触发的），                // 立即继续下一次循环，以重新评估所有条件，而不是执行一次旧的检查。                continue;            }            long currentTicks = Environment.TickCount64;            // 1. 监控运行状态 (高频: 每次循环都执行)            // if ((this.currentTargets & MonitoringTarget.OperationalState) != 0)            // {            // }            // 2. 监控应用程序状态 (中频: 约500ms一次)            if ((this.currentTargets & MonitoringTarget.Application) != 0)            {                if (currentTicks - this.lastAppStatusCheckTicks >= AppStatusIntervalMs)                {                    this.MonitorApplicationStatus();                    this.lastAppStatusCheckTicks = currentTicks;                }            }            // 3. 监控设备状态 (低频: 约10秒一次)            if ((this.currentTargets & MonitoringTarget.Devices) != 0)            {                if (currentTicks - this.lastDeviceStatusCheckTicks >= DeviceStatusIntervalMs)                {                    this.lastDeviceStatusCheckTicks = currentTicks;                }            }            try            {                // 控制更新频率                // 以最高频率(最短间隔)延时                await Task.Delay(RunningStatusIntervalMs, token);            }            catch (TaskCanceledException)            {                break;            }        }    }    private void MonitorApplicationStatus()    {        var process = Process.GetCurrentProcess();        this.SystemStatus.Memory = process.PrivateMemorySize64;        this.SystemStatus.RunningTime = (DateTime.Now - this.serviceStartTime).TotalMilliseconds;        this.SystemStatus.OperatingSystemTime = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}";    }    private string MinutesToTimeText(double time)    {        return $"{((int)time).ToString("D2")}:{((int)((time - (int)time) * 60)).ToString("D2")}";    }}