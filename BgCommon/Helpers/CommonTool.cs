using System.Security.Permissions;using System.Windows;using System.Windows.Threading;using System.Xml;using System.Xml.Linq;using System.Xml.Serialization;namespace BgCommon{    public partial class CommonTool    {        public static bool Save<T>(T data, string filePath, out string msg)        {            msg = string.Empty;            string tempFilePath = filePath + ".tmp";            try            {                using (FileStream fs = new FileStream(tempFilePath, FileMode.Create, FileAccess.Write, FileShare.None))                {                    BinaryFormatter binaryFmt = new BinaryFormatter();                    fs.Seek(0, SeekOrigin.Begin);                    binaryFmt.Serialize(fs, data);                    fs.Flush(true);                    fs.Close();                }                // 原子性替换目标文件                if (File.Exists(filePath))                {                    File.Delete(filePath);                }                File.Move(tempFilePath, filePath, true);            }            catch (Exception ex)            {                // 发生异常时删除可能残留的临时文件                if (File.Exists(tempFilePath))                {                    File.Delete(tempFilePath);                }                msg = ex.Message;                return false;            }            return true;        }        public static bool Read<T>(string filePath, out T data, out string msg)        {            msg = string.Empty;            data = default;            try            {                using (FileStream fs = new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.Read, FileShare.None))                {                    fs.Seek(0, SeekOrigin.Begin);                    BinaryFormatter binaryFmt = new BinaryFormatter();                    data = (T)binaryFmt.Deserialize(fs);                }            }            catch (System.Exception ex)            {                msg = ex.Message;                return false;            }            return true;        }        public static bool TrySerialize(object obj)        {            try            {                using (Stream objectStream = new MemoryStream())                {                    IFormatter formatter = new BinaryFormatter();                    formatter.Serialize(objectStream, obj);                }                return true;            }            catch (OutOfMemoryException ex)            {                //VLog.Error(ex.StackTrace);            }            catch (Exception ex)            {                //VLog.Error(string.Format("{0}类型对象序列化失败", obj.GetType()));                //VLog.Error(ex.Message);            }            return false;        }        public static T DeepCopy<T>(T obj)        {            object retval;            using (MemoryStream ms = new MemoryStream())            {                try                {                    BinaryFormatter bf = new BinaryFormatter();                    //序列化成流                    bf.Serialize(ms, obj);                    ms.Seek(0, SeekOrigin.Begin);                    //反序列化成对象                    retval = bf.Deserialize(ms);                    return (T)retval;                }                catch (Exception ex)                {                    Trace.TraceError( $"DeepCopy异常:{ex.ToString()}");                    return default(T);                }                finally                {                    ms.Dispose();                }            }        }        ///// <summary>        ///// Json 序列化        ///// </summary>        ///// <typeparam name="T"></typeparam>        ///// <param name="obj"></param>        ///// <param name="filename"></param>        //public static bool ObjectToJson<T>(T obj, string filename) where T : class        //{        //    try        //    {        //        var json = JsonConvert.SerializeObject(obj);        //        File.WriteAllText(filename, json);        //        return true;        //    }        //    catch (Exception ex)        //    {        //        VLog.Error(ex, "ObjectToJson");        //        return false;        //    }        //}        ///// <summary>        ///// Json 反序列化        ///// </summary>        ///// <typeparam name="T"></typeparam>        ///// <param name="fileName"></param>        ///// <returns></returns>        //public static bool JsonToObject<T>(string filename, out T data)        //{        //    try        //    {        //        var json = File.ReadAllText(filename);        //        var setting = new JsonSerializerSettings        //        {        //            DateFormatHandling = DateFormatHandling.MicrosoftDateFormat,        //            DateFormatString = "yyyy-MM-dd HH:mm:ss",        //            ContractResolver = new CamelCasePropertyNamesContractResolver(),        //            PreserveReferencesHandling = PreserveReferencesHandling.Objects,        //            ReferenceLoopHandling = ReferenceLoopHandling.Serialize,        //        };        //        data = JsonConvert.DeserializeObject<T>(json, setting);        //        return true;        //    }        //    catch (Exception ex)        //    {        //        data = default(T);        //        VLog.Error(ex, "JsonToObject");        //        return false;        //    }        //}        /// <summary>        /// xml 序列化        /// </summary>        /// <typeparam name="T"></typeparam>        /// <param name="obj"></param>        /// <param name="filename"></param>        public static bool ObjectToXml<T>(T obj, string filename, out string msg)        {            msg = string.Empty;            try            {                XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();                xmlWriterSettings.Indent = true;//获取或设置一个值，该值指示是否缩进元素。                xmlWriterSettings.OmitXmlDeclaration = true;//获取或设置一个值，该值指示是否省略XML声明。                xmlWriterSettings.NewLineOnAttributes = true;                xmlWriterSettings.Encoding = System.Text.Encoding.UTF8;//设定编码,读取的时候同样编码，可以省略xml带编码行                using (XmlWriter xmlWriter = XmlWriter.Create(filename, xmlWriterSettings))                {                    XmlSerializer xmlSerializer = new XmlSerializer(typeof(T));                    xmlSerializer.Serialize(xmlWriter, obj);                }                return true;            }            catch (Exception ex)            {                msg = ex.Message;                return false;            }        }        /// <summary>        /// xml 反序列化        /// </summary>        /// <typeparam name="T"></typeparam>        /// <param name="filename"></param>        /// <returns></returns>        public static bool XmlToObject<T>(string filename, out T data, out string msg) where T : class        {            msg = string.Empty;            data = default(T);            try            {                if (!File.Exists(filename))                {                    msg = $"文件不存在！Path：{filename}";                    return false;                }                using (XmlReader xmlReader = XmlReader.Create(filename))                {                    XmlSerializer xmlSerializer = new XmlSerializer(typeof(T));                    data = (T)xmlSerializer.Deserialize(xmlReader);                }                return true;            }            catch (Exception ex)            {                msg = ex.Message;                return false;            }        }        #region 读写 xml 文件        /// <summary>        /// 读取 xml 文件        /// </summary>        /// <param name="filename"></param>        /// <param name="nodes"></param>        /// <param name="dicts"></param>        public static void ReadXml(string filename, ref List<string> nodes, ref List<Dictionary<string, string>> dicts)        {            nodes.Clear();            dicts.Clear();            XDocument xDoc = XDocument.Load(filename);            XElement root = xDoc.Root!;            // 遍历所有节点            foreach (XElement element in xDoc.Descendants())            {                string node_name = element.Name.ToString();                XElement? node = root?.Element(node_name);                // 判断非 null                if (node != null)                {                    // 根                    nodes.Add(node_name);                    // 属性                    Dictionary<string, string> dict = new Dictionary<string, string>();                    foreach (XAttribute item in root!.Elements(node_name).Attributes())                    {                        string key = item.Name.ToString();                        string value = item.Value.ToString();                        dict.Add(key, value);                    }                    dicts.Add(dict);                }            }        }        /// <summary>        /// 写入 xml 文件        /// </summary>        /// <param name="filename"></param>        /// <param name="rootName"></param>        /// <param name="nodes"></param>        /// <param name="dicts"></param>        public static void WriteXml(string filename, string rootName, List<string> nodes, List<Dictionary<string, string>> dicts)        {            // 创建文档            XDocument xDoc = new XDocument();            // 根节点 只有一个            XElement root = new XElement(rootName);            // 添加根节点            xDoc.Add(root);            for (int i = 0; i < nodes.Count; i++)            {                // 节点                XElement node = new XElement(nodes[i]);                // 添加属性                foreach (KeyValuePair<string, string> item in dicts[i])                {                    string key = item.Key;                    string value = item.Value;                    XAttribute att = new XAttribute(key, value);                    node.Add(att);                }                // 添加节点                root.Add(node);            }            // 保存            xDoc.Save(filename);        }        #endregion        public static DispatcherOperation InvokeAsyncOnUI(Action callback, DispatcherPriority priority = DispatcherPriority.Normal)        {            return System.Windows.Application.Current.Dispatcher.InvokeAsync(callback, priority);        }        public static void InvokeOnUI(Action callback, DispatcherPriority priority = DispatcherPriority.Normal)        {            System.Windows.Application.Current.Dispatcher.Invoke(callback, priority);        }        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]        public static void DoEvents()        {            DispatcherFrame frame = new DispatcherFrame();            _ = Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Background, new DispatcherOperationCallback(ExitFrames), frame);            try            {                Dispatcher.PushFrame(frame);            }            catch (InvalidOperationException)            {            }        }        private static object ExitFrames(object frame)        {            ((DispatcherFrame)frame).Continue = false;            return null;        }        public static Dispatcher Dispatcher => Application.Current?.Dispatcher ?? Dispatcher.CurrentDispatcher;        //开机到当前时钟        //时钟获取        [DllImport("kernel32.dll ")]        static extern bool QueryPerformanceCounter(ref long lpPerformanceCount);        [DllImport("kernel32.dll")]        static extern bool QueryPerformanceFrequency(ref long PerformanceFrequency);        [System.Runtime.InteropServices.DllImport("kernel32.dll")]        static extern uint GetTickCount();        static int iGetTicksMode = 0;        // 0默认用 GetTickCount()，1用系统硬件时钟        static long lTicksFrequency = 0;     //硬件时钟频率        static long lTicksCounter = 0;       //硬件时钟计数        static long lCurTicks = 0;           //当前时间ms        //初始化系统时间获取模式        public static void InitTicks()        {            iGetTicksMode = 0;            if (QueryPerformanceCounter(ref lTicksCounter))            {                if (QueryPerformanceFrequency(ref lTicksFrequency))                {                    if (lTicksFrequency > 1000)                    {                        iGetTicksMode = 1;                    }                }            }        }        //获取系统上电时间ms        public static long GetCurTicks()        {            if (iGetTicksMode == 1)            {                if (QueryPerformanceCounter(ref lTicksCounter))                {                    if (QueryPerformanceFrequency(ref lTicksFrequency))                    {                        if (lTicksFrequency > 1000)                        {                            lCurTicks = lTicksCounter * 1000 / lTicksFrequency;                        }                    }                }            }            else if (iGetTicksMode == 0)            {                lCurTicks = GetTickCount();            }            return lCurTicks;        }    }}